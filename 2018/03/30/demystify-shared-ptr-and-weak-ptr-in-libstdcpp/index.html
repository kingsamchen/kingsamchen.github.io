<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Gone with the ruins"><title>浅析 shared_ptr：Libstdc++ 篇 | KC的废墟堆</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅析 shared_ptr：Libstdc++ 篇</h1><a id="logo" href="/.">KC的废墟堆</a><p class="description">Will you serve in Heaven, or rule in Hell</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/source-code-reading/"><i class="fa fa-archive"> 源码分析</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅析 shared_ptr：Libstdc++ 篇</h1><div class="post-meta">2018-03-30<span> | </span><span class="category"><a href="/categories/PROGRAMMING/">PROGRAMMING</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/" href="/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/#disqus_thread"></a><div class="post-content"><p>序言请移步<a href="https://kingsamchen.github.io/2018/03/13/shared-ptr-internals-introduction/">此处</a></p>
<p>MSVC STL 的分析版本请移步<a href="https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">此处</a></p>
<p>注：因为这不是第一篇分析，所以会直入主题，跳过文学写作常用的累赘的过渡。</p>
<h2 id="版本选择与源码位置"><a href="#版本选择与源码位置" class="headerlink" title="版本选择与源码位置"></a>版本选择与源码位置</h2><p>目前的工作机是 Linux Mint 18，对应的是 Ubuntu 16.04 LTS。</p>
<p>这个版本的系统上源包默认提供的是 GCC 5.4 和 clang 3.8，跟随的 libstdc++ 的大版本是 6。</p>
<p>考虑到 Linux 上 clang 也是默认使用 libstdc++，且 GCC 6&#x2F;7&#x2F;8 使用的 libstdc++ 的大版本都是 6，因此直接选用目录 <code>/usr/include/c++/5</code> 下的源码作为研究对象。</p>
<span id="more"></span>

<h2 id="How-shared-ptr-new-T-differs-from-make-shared"><a href="#How-shared-ptr-new-T-differs-from-make-shared" class="headerlink" title="How shared_ptr(new T()) differs from make_shared()"></a>How shared_ptr(new T()) differs from make_shared()</h2><p>函数 <code>make_shared()</code> 位于文件 shared_ptr.h：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Create an object that is owned by a shared_ptr.</span></span><br><span class="line"><span class="comment">*  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.</span></span><br><span class="line"><span class="comment">*  @return A shared_ptr that owns the newly created object.</span></span><br><span class="line"><span class="comment">*  @throw  std::bad_alloc, or an exception thrown from the</span></span><br><span class="line"><span class="comment">*          constructor of @a _Tp.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function"><span class="title">make_shared</span><span class="params">(_Args&amp;&amp;... __args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_const&lt;_Tp&gt;::type _Tp_nc;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">allocate_shared</span>&lt;_Tp&gt;(std::<span class="built_in">allocator</span>&lt;_Tp_nc&gt;(), std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部直接将操作转交给了 <code>std::allocate_shared</code>。这个函数虽然是 <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared">C++ 11 引入</a>的，但是似乎是从 boost 沿袭而来，我们在 MSVC STL 的分析里并未见到过。</p>
<p>注：reference 上对这个函数的描述简洁明了，点名了就是用来实现一次内存分配的。事实上截止到 Visual Studi 2017 15.6.3，这个函数还只在 TR1 名字空间里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Create an object that is owned by a shared_ptr.</span></span><br><span class="line"><span class="comment">*  @param  __a     An allocator.</span></span><br><span class="line"><span class="comment">*  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.</span></span><br><span class="line"><span class="comment">*  @return A shared_ptr that owns the newly created object.</span></span><br><span class="line"><span class="comment">*  @throw  An exception thrown from @a _Alloc::allocate or from the</span></span><br><span class="line"><span class="comment">*          constructor of @a _Tp.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  A copy of @a __a will be used to allocate memory for the shared_ptr</span></span><br><span class="line"><span class="comment">*  and the new object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function"><span class="title">allocate_shared</span><span class="params">(<span class="type">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(_Sp_make_shared_tag(), __a,</span><br><span class="line">                std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by allocate_shared.</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(_Sp_make_shared_tag __tag, <span class="type">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span></span></span><br><span class="line"><span class="function">    : __shared_ptr&lt;_Tp&gt;(__tag, __a, std::forward&lt;_Args&gt;(__args)...)</span></span><br><span class="line"><span class="function">&#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>__shared_ptr</code> 是 <code>shared_ptr</code> 的基类，相当于 MSVC STL 里的 <code>_Ptr_base</code>，包含在文件 <code>shared_ptr_base.h</code> 里。</p>
<p>我们分别看一下 <code>__shared_ptr</code> 的基本成员，以及这个非标准的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr</span> &#123;</span><br><span class="line">    <span class="comment">// Omit irrelavent code</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Tp*	   	   _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by allocate_shared.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_ptr(_Sp_make_shared_tag __tag, <span class="type">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : _M_ptr(),</span><br><span class="line">      _M_refcount(__tag, (_Tp*)<span class="number">0</span>, __a, std::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line">    <span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line">    <span class="type">void</span>* __p = _M_refcount._M_get_deleter(<span class="built_in">typeid</span>(__tag));</span><br><span class="line">    _M_ptr = <span class="built_in">static_cast</span>&lt;_Tp*&gt;(__p);</span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个构造函数有两个版本的实现，分别对应是否开启 RTTI，这里选用默认的使用 RTTI 的版本。</p>
<p>基类也是有两个成员：</p>
<ol>
<li>实例指针</li>
<li>引用计数控制块</li>
</ol>
<p>实际的构造操作依旧由引用计数控制块 <code>__shared_count</code> 完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_count</span> &#123;</span><br><span class="line">    <span class="comment">// Omit irrelavent code</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_count(_Sp_make_shared_tag, _Tp*, <span class="type">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">: _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;</span><br><span class="line">    <span class="keyword">typename</span> _Sp_cp_type::__allocator_type __a2(__a);</span><br><span class="line">    <span class="keyword">auto</span> __guard = std::__allocate_guarded(__a2);</span><br><span class="line">    _Sp_cp_type* __mem = __guard.<span class="built_in">get</span>();</span><br><span class="line">    ::<span class="keyword">new</span> (__mem) _Sp_cp_type(std::<span class="built_in">move</span>(__a),</span><br><span class="line">                std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    _M_pi = __mem;</span><br><span class="line">    __guard = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分实现比 MSVC STL 要复杂，因为牵扯到了 allocator。</p>
<p>实话说，我对 allocator 不熟悉，也从来没用过 customized allocator；同时这里使用的 allocator 相关函数大多是 libstdc++ 自己定义的，因此这块仅在宏观上提一下，不做深入分析。有兴趣的可以自己跟踪一下源代码。</p>
<p>首先，<code>_Sp_counted_ptr_inplace</code> 是 <code>_Sp_counted_base</code> 的子类，这个类有一个内部类，并且类自身只有一个这个内部类的成员（略去了不相关代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line"><span class="keyword">class</span> _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    _Atomic_word  _M_use_count;     <span class="comment">// #shared</span></span><br><span class="line">    _Atomic_word  _M_weak_count;    <span class="comment">// #weak + (#shared != 0)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Sp_counted_ptr_inplace</span> <span class="keyword">final</span> : <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Impl</span> : _Sp_ebo_helper&lt;<span class="number">0</span>, _Alloc&gt; &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Alloc&gt;	_A_base;</span><br><span class="line"></span><br><span class="line">        __gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _Impl _M_impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，父类 <code>_Sp_counted_base</code> 包含了两个计数成员，同时子类 <code>_Sp_counted_ptr_inplace</code> 通过内部的 <code>_Impl</code>，引入了一块存储空间，大小是最外层 <code>share_ptr</code> 要管理的对象实例的大小。</p>
<p>这样一来，被管理对象的内存和控制块的内存也被组织在了一块内存上。</p>
<p>接下来研究如何分配那整块的内存；这和前面三句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> _Sp_cp_type::__allocator_type __a2(__a);</span><br><span class="line"><span class="keyword">auto</span> __guard = std::__allocate_guarded(__a2);</span><br><span class="line">_Sp_cp_type* __mem = __guard.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<p>有关。</p>
<p>上面通过 <code>_Sp_counted_ptr_inplace</code> 内部定义的 allocator，利用 <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/memory/allocator">allocator rebind</a>，获取能够以 <code>_Sp_counted_ptr_inplace</code> 为粒度进行分配的 allocator，并随后分配了一块内存，也就是 <code>_mem</code> 引用的那块。</p>
<p>有了内存块之后，剩下的就是调用 in-placement new 构造出 <code>_Sp_counted_ptr_inplace</code> 对象。</p>
<p>接下来看一下顶层的 <code>__Shared_ptr::_M_ptr</code> 是如何关联到 <code>_Sp_counted_ptr_inplace</code> 里的实例成员地址的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line"><span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line"><span class="type">void</span>* __p = _M_refcount._M_get_deleter(<span class="built_in">typeid</span>(__tag));</span><br><span class="line">_M_ptr = <span class="built_in">static_cast</span>&lt;_Tp*&gt;(__p);</span><br></pre></td></tr></table></figure>

<p>依赖 <code>_M_get_deleter</code> 是什么鬼…看一下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class __shared_count</span></span><br><span class="line"><span class="type">void</span>* _M_get_deleter(<span class="type">const</span> std::type_info&amp; __ti) <span class="type">const</span> <span class="type">const</span> <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class _Sp_counted_ptr_inplace</span></span><br><span class="line"><span class="comment">// Sneaky trick so __shared_ptr can get the managed pointer</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span>* _M_get_deleter(<span class="type">const</span> std::type_info&amp; __ti) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cpp_rtti</span></span><br><span class="line">	<span class="keyword">if</span> (__ti == <span class="built_in">typeid</span>(_Sp_make_shared_tag))</span><br><span class="line">	  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Tp* _M_ptr() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_impl._M_storage._M_ptr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是拿到 <code>_Sp_counted_ptr_inplace::Impl</code> 内部 <code>__gnu_cxx::__aligned_buffer</code> 的数据地址。</p>
<p>这里的 RTTI 的操作看得我一脸懵逼……</p>
<p>接下来看一下针对形如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br></pre></td></tr></table></figure>

<p>的内部实现流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Construct a %shared_ptr that owns the pointer @a __p.</span></span><br><span class="line"><span class="comment"> *  @param  __p  A pointer that is convertible to element_type*.</span></span><br><span class="line"><span class="comment"> *  @post   use_count() == 1 &amp;&amp; get() == __p</span></span><br><span class="line"><span class="comment"> *  @throw  std::bad_alloc, in which case @c delete @a __p is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line"><span class="function">    : __shared_ptr&lt;_Tp&gt;(__p)</span></span><br><span class="line"><span class="function">&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="keyword">explicit</span> __shared_ptr(_Tp1* __p)</span><br><span class="line">    : _M_ptr(__p), _M_refcount(__p) <span class="comment">// &lt;- set up instance ptr &amp; ref-count object</span></span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="built_in">static_assert</span>( !is_void&lt;_Tp1&gt;::value, <span class="string">&quot;incomplete type&quot;</span> );</span><br><span class="line">    <span class="built_in">static_assert</span>( <span class="built_in">sizeof</span>(_Tp1) &gt; <span class="number">0</span>, <span class="string">&quot;incomplete type&quot;</span> );</span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">explicit</span> __shared_count(_Ptr __p)</span><br><span class="line">    : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        _M_pi = <span class="keyword">new</span> _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);    <span class="comment">// &lt;- use _Sp_counted_ptr as ref-count object here</span></span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> __p;</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在这种使用场合下，ref-count 的具体数据类型是 <code>_Sp_counted_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counted ptr with no deleter or allocator support</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Sp_counted_ptr</span> <span class="keyword">final</span> : <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> _Sp_counted_ptr(_Ptr __p) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_ptr(__p)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span>* _M_get_deleter(<span class="type">const</span> std::type_info&amp;) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Sp_counted_ptr(<span class="type">const</span> _Sp_counted_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    _Sp_counted_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Sp_counted_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ptr _M_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>仅仅调用构造函数初始化了内部保存的 <code>_M_ptr</code>，毕竟管理的实例对象已经创建完毕了。</p>
<p>至此整个初始化流程都已经结束了。</p>
<p><strong>Conclusion</strong></p>
<p>和 MSVC STL 的实现类似，<code>make_shared()</code> 内部保证只有一次内存分配，实例对象和计数控制块都在一块内存上，而 <code>shared_ptr()</code> 的构造就简单很多，只需要初始化计数块，同时设置对应的实例指针即可。</p>
<p>并且，两种 case 下，具体使用的 ref-count 的对象是不一样的，这可以做到针对性的优化。</p>
<p>不同点也比较明显：libstdc++ STL 多了一个 <code>shared_count</code> 中间层；同时 <code>make_shared()</code> 内部的内存分配大量依赖 allocator。</p>
<h2 id="Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer"><a href="#Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer" class="headerlink" title="Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer"></a>Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer</h2><p>这种 case 是通过 <code>shared_ptr</code> 的构造函数创建对象，只需要跟相关的 ctor 即可。</p>
<p>和 MSVC STL 类似，ctor 自身也是一个 template，参数为 <code>_Tp1</code>，并且这个参数一直通过 <code>__shared_ptr</code> - <code>__shared_count</code> - <code>_Sp_counted_ptr</code> 的 ctor template 将实际类型保存到了 <code>_Sp_counted_ptr::_M_ptr</code> 中。</p>
<p>释放实例的 <code>_Sp_counted_ptr::_M_dispose()</code> 仅仅简单的调用了一下 delete expression</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="type">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type"><a href="#How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type" class="headerlink" title="How Custom Deleter Works and Why It Is Not Part of the Type"></a>How Custom Deleter Works and Why It Is Not Part of the Type</h2><p>支持 custom deleter 同样需要通过构造函数创建对应的 <code>shared_ptr</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Construct a %shared_ptr that owns the pointer @a __p</span></span><br><span class="line"><span class="comment"> *          and the deleter @a __d.</span></span><br><span class="line"><span class="comment"> *  @param  __p  A pointer.</span></span><br><span class="line"><span class="comment"> *  @param  __d  A deleter.</span></span><br><span class="line"><span class="comment"> *  @post   use_count() == 1 &amp;&amp; get() == __p</span></span><br><span class="line"><span class="comment"> *  @throw  std::bad_alloc, in which case @a __d(__p) is called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Requirements: _Deleter&#x27;s copy constructor and destructor must</span></span><br><span class="line"><span class="comment"> *  not throw</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  __shared_ptr will release __p by calling __d(__p)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line"><span class="built_in">shared_ptr</span>(_Tp1* __p, _Deleter __d)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p, __d)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，直接托管给负责干活的父类 <code>__shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line">__shared_ptr(_Tp1* __p, _Deleter __d)</span><br><span class="line">    : _M_ptr(__p),</span><br><span class="line">      _M_refcount(__p, __d)</span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="comment">// TODO requires _Deleter CopyConstructible and __d(__p) well-formed</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着又通过构造函数参数转入计数控制块 <code>_M_refcount</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line">__shared_count(_Ptr __p, _Deleter __d)</span><br><span class="line">    : __shared_count(__p, std::<span class="built_in">move</span>(__d), <span class="built_in">allocator</span>&lt;<span class="type">void</span>&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">__shared_count(_Ptr __p, _Deleter __d, _Alloc __a)</span><br><span class="line">    : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typename</span> _Sp_cd_type::__allocator_type __a2(__a);</span><br><span class="line">        <span class="keyword">auto</span> __guard = std::__allocate_guarded(__a2);</span><br><span class="line">        _Sp_cd_type* __mem = __guard.<span class="built_in">get</span>();</span><br><span class="line">        ::<span class="keyword">new</span> (__mem) _Sp_cd_type(__p, std::<span class="built_in">move</span>(__d), std::<span class="built_in">move</span>(__a));</span><br><span class="line">        _M_pi = __mem;</span><br><span class="line">        __guard = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        __d(__p); <span class="comment">// Call _Deleter on __p.</span></span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出：</p>
<ol>
<li>这种情况下使用的具体 ref-count 类型是 <code>_Sp_counted_deleter</code></li>
<li>这里的内存分配依然是通过 allocator</li>
<li>deleter 和托管实例的类型通过 template paramter 一路保存了下来。因为 deleter 可能只认识创建时传递的指针类型（考虑 aliasing construction）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support for custom deleter and/or allocator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Sp_counted_deleter</span> <span class="keyword">final</span> : <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_Impl</span> : _Sp_ebo_helper&lt;<span class="number">0</span>, _Deleter&gt;, _Sp_ebo_helper&lt;<span class="number">1</span>, _Alloc&gt; &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Deleter&gt; _Del_base;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">1</span>, _Alloc&gt; _Alloc_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        _Impl(_Ptr __p, _Deleter __d, <span class="type">const</span> _Alloc&amp; __a) <span class="keyword">noexcept</span></span><br><span class="line">            : _M_ptr(__p),</span><br><span class="line">              _Del_base(__d),</span><br><span class="line">              _Alloc_base(__a)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        _Deleter&amp; _M_del() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> _Del_base::_S_get(*<span class="keyword">this</span>); &#125;</span><br><span class="line">        _Alloc&amp; _M_alloc() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> _Alloc_base::_S_get(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">        _Ptr _M_ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __d(__p) must not throw.</span></span><br><span class="line">    _Sp_counted_deleter(_Ptr __p, _Deleter __d) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_impl(__p, __d, _Alloc()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __d(__p) must not throw.</span></span><br><span class="line">    _Sp_counted_deleter(_Ptr __p, _Deleter __d, <span class="type">const</span> _Alloc&amp; __a) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_impl(__p, __d, __a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~_Sp_counted_deleter() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _M_impl._M_del()(_M_impl._M_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span>* _M_get_deleter(<span class="type">const</span> std::type_info&amp; __ti) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cpp_rtti</span></span><br><span class="line">        <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">        <span class="comment">// 2400. shared_ptr&#x27;s get_deleter() should use addressof()</span></span><br><span class="line">        <span class="keyword">return</span> __ti == <span class="built_in">typeid</span>(_Deleter)</span><br><span class="line">            ? std::__addressof(_M_impl._M_del())</span><br><span class="line">            : <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Impl _M_impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，deleter 和 allocator 直接通过基类“组合”进了 ref-count 块。</p>
<p><strong>Conclusion</strong></p>
<p><code>shared_ptr&lt;T&gt;</code> 仅决定 <code>__shared_ptr::_M_ptr</code> 的类型，实例的运行时类型和 deleter 均保存在 <code>_Sp_counted_delter</code> 中，这个类通过 <code>__shared_ptr::_M_refcont</code> 关联。</p>
<h2 id="How-enable-shared-from-this-works"><a href="#How-enable-shared-from-this-works" class="headerlink" title="How enable_shared_from_this works"></a>How enable_shared_from_this works</h2><p>回顾一下我们知道，使用 <code>enable_shared_from_this</code> 需要满足两个条件：</p>
<ol>
<li>某个类从 <code>enable_shared_from_this</code> 继承</li>
<li>这个类的实例必须要通过 <code>shared_ptr</code> 托管。</li>
</ol>
<p>对于第一点，我们看一下这个类的成员结构（其他的部分对继承几乎没什么影响）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief Base class allowing use of member function shared_from_this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">enable_shared_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some omitted</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Tp2&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> __enable_shared_from_this_helper(<span class="type">const</span> __shared_count&lt;&gt;&amp;,</span><br><span class="line">                                                 <span class="type">const</span> enable_shared_from_this&lt;_Tp1&gt;*,</span><br><span class="line">                                                 <span class="type">const</span> _Tp2*) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt;  _M_weak_this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有一个 <code>weak_ptr</code> 成员，类型是需要继承的子类，CRTP 的典型用法咯。</p>
<p>还有一个 friend function 后面会提到。</p>
<p>接着看第二点，这里拿 <code>make_shared()</code> 的 case 做例子，看一段前面看过的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_ptr(_Sp_make_shared_tag __tag, <span class="type">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : _M_ptr(),</span><br><span class="line">      _M_refcount(__tag, (_Tp*)<span class="number">0</span>, __a, std::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line">    <span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line">    <span class="type">void</span>* __p = _M_refcount._M_get_deleter(<span class="built_in">typeid</span>(__tag));</span><br><span class="line">    _M_ptr = <span class="built_in">static_cast</span>&lt;_Tp*&gt;(__p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;- attention  here</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出核心是 <code>__enable_shared_from_this_helper()</code> 这个函数，并且：</p>
<ul>
<li>调用这个函数的之前，对象实例和 ref-count 块都已经创建完毕了</li>
<li>这个函数就是前面说的那个 friend function，所以这个而函数可以直接修改 <code>enable_shared_from_this</code> 里的 <code>_M_weak_this</code>。</li>
</ul>
<p>另外，如果托管对象并不需要这个特性，则函数重载会匹配到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __enable_shared_from_this_helper(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp;, ...) <span class="keyword">noexcept</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>看一下函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Tp2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __enable_shared_from_this_helper(<span class="type">const</span> __shared_count&lt;&gt;&amp; __pn,</span><br><span class="line">                                             <span class="type">const</span> enable_shared_from_this&lt;_Tp1&gt;* __pe,</span><br><span class="line">                                             <span class="type">const</span> _Tp2* __px) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__pe != <span class="literal">nullptr</span>)</span><br><span class="line">        __pe-&gt;_M_weak_assign(<span class="built_in">const_cast</span>&lt;_Tp2*&gt;(__px), __pn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from class enable_shared_from_this</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="type">void</span> _M_weak_assign(_Tp1* __p, <span class="type">const</span> __shared_count&lt;&gt;&amp; __n) <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _M_weak_this._M_assign(__p, __n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__weak_ptr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Used by __enable_shared_from_this.</span></span><br><span class="line">    <span class="type">void</span> _M_assign(_Tp* __ptr, <span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __refcount) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _M_ptr = __ptr;</span><br><span class="line">        _M_refcount = __refcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Tp*	 	 _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __weak_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__weak_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line"></span><br><span class="line">    _M_pi = __tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面完成了托管对象的父类 <code>enable_shared_from_this</code> 中的 <code>weak_ptr</code> 和前面通过创建 <code>shared_ptr</code> 对象时创建的 ref-count 结构关联。</p>
<p>并且可以看出，完成关联后，weak-count 的计数是2：</p>
<ol>
<li>父类 enable_shared_from_this 的构造不作任何处理</li>
<li><code>shared_ptr</code> 闯将完毕后 usage-count 和 weak-count 都是 1，然后关联的时候通过 <code>_M_wak_add_ref()</code> 增加了 weak-count</li>
</ol>
<p>另外，虽然 <code>weak_ptr</code> 的父类是 <code>__weak_ptr</code>，但是这个类和 <code>__shared_ptr</code> 一样有两个成员，并且 <code>__weak_count</code> 的成员也是 <code>_Sp_counted_base</code>，和 <code>__shared_count</code> 一样。</p>
<p>这里和 MSVC STL 稍有不同，猜测可能是 libstdc++ 为了获取 <code>shared_ptr</code> 和 <code>weak_ptr</code> 之间更大的独立性？</p>
<p>接下来看一下函数 <code>shared_from_this()</code> 的工作原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from class enable_shared_from_this</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;_Tp&gt; <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接利用了从 <code>weak-ptr</code> 构造 <code>shared_ptr</code> 的技法。</p>
<p><strong>Conclusion</strong></p>
<p>这部分的思路和 MSVC STL 一致，<code>enable_shared_from_this</code> 中保存一个 <code>weak_ptr</code> 成员，并且在构造 <code>shared_ptr</code> 对象时和 ref-count 关联。</p>
<p><code>shared_from_this()</code> 直接复用从 <code>weak-ptr</code> 构造 <code>shared_ptr</code> 的逻辑，只不过这个时候基本不存在 usage count 为 0 的情况。</p>
<p>注：libstdc++ 里有一个类似的类叫 <code>__enable_shared_from_this</code>，形式上和 <code>enable_shared_from_this</code> 很相似，只不过成员已经直接是 <code>__weak_ptr</code>。</p>
<p>至于为什么会有这个 duplication，表示不是很懂。</p>
<h2 id="How-Reference-Counting-Works"><a href="#How-Reference-Counting-Works" class="headerlink" title="How Reference Counting Works"></a>How Reference Counting Works</h2><p>通过前面的分析可以知道，引用计数是由 <code>__shared_count</code> 保存的成员指针 <code>_Sp_counted_base</code> 管理。</p>
<p>计数 usage-count 和 weak-count 的类型都是 <code>_Atomic_word</code>，这个类型定义在 <code>atomic_word.h</code> 中，实际上是 <code>int</code>。</p>
<p><code>_Sp_counted_base</code> 在构造时将两个计数都设置为 1。</p>
<p>同时提供</p>
<ul>
<li><code>_M_add_ref_copy()</code>，<code>_M_add_ref_lock()</code> 和 <code>_M_release()</code> 由上层根据上下文对 usage-count 进行增减</li>
<li><code>_M_weak_add_ref()</code> 和 <code>_M_weak_release()</code> 由上层根据上下文对 weak-count 进行增减</li>
</ul>
<p>NOTE：因为 libstdc++ 使用范围更广，所以提供了单线程版本、用锁的版本和使用原子操作的版本。同时因为具体的 atomic 实现在 libstdc++ 里有点乱，这里不研究 atomic operations 的细节，仅假设其能工作正常（废话），并站在高层抽象语义角度去分析对应的原子操作。</p>
<p>先看一下 usage-count 的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_M_add_ref_copy()</span><br><span class="line">&#123;</span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_Sp_counted_base&lt;_S_atomic&gt;::</span><br><span class="line">_M_add_ref_lock()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Perform lock-free add-if-not-zero operation.</span></span><br><span class="line">    _Atomic_word __count = _M_get_use_count();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__count == <span class="number">0</span>)</span><br><span class="line">            __throw_bad_weak_ptr();</span><br><span class="line">        <span class="comment">// Replace the current counter value with the old value + 1, as</span></span><br><span class="line">        <span class="comment">// long as it&#x27;s not changed meanwhile.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + <span class="number">1</span>,</span><br><span class="line">                                        <span class="literal">true</span>, __ATOMIC_ACQ_REL,</span><br><span class="line">                                        __ATOMIC_RELAXED));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">_Sp_counted_base&lt;_S_atomic&gt;::</span><br><span class="line">_M_add_ref_lock_nothrow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Perform lock-free add-if-not-zero operation.</span></span><br><span class="line">    _Atomic_word __count = _M_get_use_count();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Replace the current counter value with the old value + 1, as</span></span><br><span class="line">        <span class="comment">// long as it&#x27;s not changed meanwhile.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + <span class="number">1</span>,</span><br><span class="line">                                        <span class="literal">true</span>, __ATOMIC_ACQ_REL,</span><br><span class="line">                                        __ATOMIC_RELAXED));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">        _M_dispose();</span><br><span class="line">        <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">        <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">        <span class="comment">// thread that runs destroy().</span></span><br><span class="line">        <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            _GLIBCXX_READ_MEM_BARRIER;</span><br><span class="line">            _GLIBCXX_WRITE_MEM_BARRIER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,</span><br><span class="line">                <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">            _M_destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_M_add_ref_copy()</code> 就是单纯的自增 usage-count，发生在 <code>__shared_count</code> 的拷贝创建或者赋值时；而 <code>_M_add_ref_lock()</code> 以来一个完整的 CAS，根据之前对 MSVC STL 的分析，我们这里可以猜测这个函数是用来 promote 一个 <code>weak_ptr</code> 到 <code>shared_ptr</code> 的，后面可以验证一下这个猜想。</p>
<p><code>_M_release()</code> 会首先自减 usage-count，如果减到0了，就释放托管的对象实例；同时再自减 weak-count，如果此时也为 0，那么说明这个 ref-count 已经凉了，就可以整个销毁了。</p>
<p>然后是 weak-count 的计数操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_M_weak_add_ref() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_M_weak_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly. For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// See _M_release(),</span></span><br><span class="line">            <span class="comment">// destroy() must observe results of dispose()</span></span><br><span class="line">            _GLIBCXX_READ_MEM_BARRIER;</span><br><span class="line">            _GLIBCXX_WRITE_MEM_BARRIER;</span><br><span class="line">        &#125;</span><br><span class="line">        _M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本和上面一致。</p>
<p><code>_M_weak_add_ref()</code> 的调用时机基本是：</p>
<ul>
<li>从 <code>__weak_count</code> 或 <code>__shared_count</code> 拷贝构造得到一个 <code>__weak_count</code></li>
<li>将一个 <code>__weak_count</code> 或 <code>__shared_count</code> 赋值给另外一个 <code>__weak_count</code> （这种情况伴随着 <code>_M_weak_release()</code> 调用）</li>
</ul>
<p><code>_M_weak_release()</code> 除了赋值时会调用外，剩下的就是析构时。</p>
<p><strong>Conclusion</strong></p>
<p>两个引用计数的操作基本转换成了 <code>__shared_count</code> 对象和 <code>__weak_count</code> 对象之间的交互。</p>
<p>一般情况下，实现采用的方案都是通过 atomic operations 实现计数，但是根据源码我们也发现了专门针对单线程版本和不支持 atomic 的有锁版本。</p>
<h2 id="How-weak-ptr-relates-with-shared-ptr"><a href="#How-weak-ptr-relates-with-shared-ptr" class="headerlink" title="How weak_ptr relates with shared_ptr"></a>How weak_ptr relates with shared_ptr</h2><p>这部分和上一个 ref-count 的分析部分其实关系非常紧密。</p>
<p>promotion 在外部的表象就是通过 <code>weak_ptr::lock()</code> 完成。虽然通过 <code>shared_ptr</code> 的构造函数也可以，但是如果对象已经死了，构造函数会抛异常，徒增复杂度，我想应该没谁会这么折腾吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from weak_ptr</span></span><br><span class="line"><span class="function">shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function"><span class="title">lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(*<span class="keyword">this</span>, std::nothrow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from shared_ptr</span></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by weak_ptr::lock().</span></span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="type">const</span> weak_ptr&lt;_Tp&gt;&amp; __r, std::<span class="type">nothrow_t</span>)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__r, std::nothrow) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from __shared_ptr</span></span><br><span class="line"><span class="comment">// This constructor is used by __weak_ptr::lock() and</span></span><br><span class="line"><span class="comment">// shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).</span></span><br><span class="line">__shared_ptr(<span class="type">const</span> __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::<span class="type">nothrow_t</span>)</span><br><span class="line">    : _M_refcount(__r._M_refcount, std::nothrow)</span><br><span class="line">&#123;</span><br><span class="line">    _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that __weak_count is defined we can define this constructor:</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">__shared_count&lt;_Lp&gt;::</span><br><span class="line">__shared_count(<span class="type">const</span> __weak_count&lt;_Lp&gt;&amp; __r, std::<span class="type">nothrow_t</span>)</span><br><span class="line">    : _M_pi(__r._M_pi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">if</span> (!_M_pi-&gt;_M_add_ref_lock_nothrow())</span><br><span class="line">            _M_pi = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这里和 MSVC STL 大致上还是类似的。</p>
<p>利用 CAS 去加 usage-count，如果成功了，说明对象还活着，成功 promotion；反之，计数为0，自增函数返回 false，构造一个空对象。</p>
<h2 id="Thread-safety-of-shared-ptr-Instances"><a href="#Thread-safety-of-shared-ptr-Instances" class="headerlink" title="Thread-safety of shared_ptr Instances"></a>Thread-safety of shared_ptr Instances</h2><p>假设对一个 <code>shared_ptr</code> 对象 sp 又读又写：</p>
<ol>
<li>从 sp 创建一个拷贝</li>
<li>将 sp 设置为另一个 <code>shared_ptr</code> 实例</li>
</ol>
<p>这两点涉及 <code>shared_ptr</code> 的拷贝构造或拷贝赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__shared_ptr(<span class="type">const</span> __shared_ptr&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">__shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __shared_ptr&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>直接采用编译器提供的实现。</p>
<p>因为 <code>__shared_ptr</code> 存有实例对象指针和计数控制块指针，复制操作做不到原子的改变两个值。</p>
<p>至于多个对象独立的析构，前面我们可以看到，这个是通过原子的改变引用计数完成，可以保证线程安全性。</p>
<p>同时，通过上一节可以看出 <code>weak_ptr</code> 到 <code>shared_ptr</code> 的 promotion 也是通过 CAS 操作保证了安全性。</p>
<h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>Libstdc++ 的分析版本到这里也结束了。</p>
<p>相比 MSVC STL，我觉得 libstdc++ 版本分析起来更困难，原因总结有三：</p>
<ol>
<li>源码分析环境不如直接在 Windows 那么友好，一些 gnu-extension 啥的文件需要翻来覆去的找</li>
<li>部分内存分配采用 allocator，我对 allocator 真心不熟悉<br>  举例：有多少人知道 allocator 一开始不是为了 a mean of allocation 出现，而是为了屏蔽 near&#x2F;far 地址</li>
<li>因为 libstdc++ 涉及更多的平台，并且有一些扩展实现，增加了代码分析的量</li>
</ol>
</div><div class="tags"><a href="/tags/c/"><i class="fa fa-tag"></i>c++</a><a href="/tags/shared-ptr/"><i class="fa fa-tag"></i>shared_ptr</a><a href="/tags/shared-ptr-internals/"><i class="fa fa-tag"></i>shared_ptr-internals</a><a href="/tags/source-code-study/"><i class="fa fa-tag"></i>source-code-study</a><a href="/tags/weak-ptr/"><i class="fa fa-tag"></i>weak_ptr</a><a href="/tags/libstdc/"><i class="fa fa-tag"></i>libstdc++</a><a href="/tags/gcc/"><i class="fa fa-tag"></i>gcc</a><a href="/tags/clang/"><i class="fa fa-tag"></i>clang</a></div><div class="post-nav"><a class="pre" href="/2018/04/01/monthly-read-posts-in-mar-2018/">Monthly Read Posts in Mar 2018</a><a class="next" href="/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">浅析 shared_ptr：MSVC STL 篇</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://kingsamchen.github.io/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/';
    this.page.identifier = '2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/';
    this.page.title = '浅析 shared_ptr：Libstdc++ 篇';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//kingsamchen-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//kingsamchen-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://kingsamchen-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://kingsamchen.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CODE-LIFE/">CODE-LIFE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PROGRAMMING/">PROGRAMMING</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/11/18/weekly-2024-nov-2/">一周杂记 in Week 2 Nov 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/11/11/weekly-2024-nov-1/">一周杂记 in Week 1 Nov 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/11/10/must-dos-and-rescue-vagrant-vm-after-installing-windows-11/">码农安装好 Windows 11 后要做的1001件事，以及如何拯救就电脑上的 vagrant vm</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/11/04/weekly-2024-oct-5/">一周杂记 in Week 5 Oct 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/28/weekly-2024-oct-4/">一周杂记 in Week 4 Oct 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/21/weekly-2024-oct-3/">一周杂记 in Week 3 Oct 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/14/weekly-2024-oct-2/">一周杂记 in Week 2 Oct 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/08/weekly-2024-oct-1/">一周杂记 in Week 1 Oct 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/30/weekly-2024-sep-4/">一周杂记 in Week 4 Sep 2024</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/23/weekly-2024-sep-3/">一周杂记 in Week 3 Sep 2024</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/rant/" style="font-size: 15px;">rant</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/crash/" style="font-size: 15px;">crash</a> <a href="/tags/breakpad/" style="font-size: 15px;">breakpad</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/exception/" style="font-size: 15px;">exception</a> <a href="/tags/memory-fence/" style="font-size: 15px;">memory fence</a> <a href="/tags/memory-ordering/" style="font-size: 15px;">memory ordering</a> <a href="/tags/multiple-instance/" style="font-size: 15px;">multiple instance</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/enum/" style="font-size: 15px;">enum</a> <a href="/tags/flag/" style="font-size: 15px;">flag</a> <a href="/tags/bitwise%EF%BC%8C-SFINAE/" style="font-size: 15px;">bitwise， SFINAE</a> <a href="/tags/KBase/" style="font-size: 15px;">KBase</a> <a href="/tags/command-line/" style="font-size: 15px;">command-line</a> <a href="/tags/abstraction/" style="font-size: 15px;">abstraction</a> <a href="/tags/%E6%A2%AF%E5%AD%90/" style="font-size: 15px;">梯子</a> <a href="/tags/shadowsocks/" style="font-size: 15px;">shadowsocks</a> <a href="/tags/trojan/" style="font-size: 15px;">trojan</a> <a href="/tags/socat/" style="font-size: 15px;">socat</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/design/" style="font-size: 15px;">design</a> <a href="/tags/environment/" style="font-size: 15px;">environment</a> <a href="/tags/buddy-allocator/" style="font-size: 15px;">buddy-allocator</a> <a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/C-17/" style="font-size: 15px;">C++ 17</a> <a href="/tags/string-view/" style="font-size: 15px;">string_view</a> <a href="/tags/tokenizer/" style="font-size: 15px;">tokenizer</a> <a href="/tags/asio/" style="font-size: 15px;">asio</a> <a href="/tags/cmake/" style="font-size: 15px;">cmake</a> <a href="/tags/anvil/" style="font-size: 15px;">anvil</a> <a href="/tags/project-management/" style="font-size: 15px;">project management</a> <a href="/tags/atoi/" style="font-size: 15px;">atoi</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/cfs/" style="font-size: 15px;">cfs</a> <a href="/tags/non-capturing-lambda/" style="font-size: 15px;">non-capturing lambda</a> <a href="/tags/function-pointer/" style="font-size: 15px;">function pointer</a> <a href="/tags/obs-studio/" style="font-size: 15px;">obs-studio</a> <a href="/tags/inno-setup/" style="font-size: 15px;">inno setup</a> <a href="/tags/installer/" style="font-size: 15px;">installer</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Unix/" style="font-size: 15px;">Unix</a> <a href="/tags/signal/" style="font-size: 15px;">signal</a> <a href="/tags/signalfd/" style="font-size: 15px;">signalfd</a> <a href="/tags/self-pipe-trick/" style="font-size: 15px;">self-pipe trick</a> <a href="/tags/cant/" style="font-size: 15px;">cant</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/HandlerThread/" style="font-size: 15px;">HandlerThread</a> <a href="/tags/Looper/" style="font-size: 15px;">Looper</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/MessageLoop/" style="font-size: 15px;">MessageLoop</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/proxy/" style="font-size: 15px;">proxy</a> <a href="/tags/thread-pool/" style="font-size: 15px;">thread-pool</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/urlfetcher/" style="font-size: 15px;">urlfetcher</a> <a href="/tags/wireshark/" style="font-size: 15px;">wireshark</a> <a href="/tags/localhost/" style="font-size: 15px;">localhost</a> <a href="/tags/source-internals/" style="font-size: 15px;">source internals</a> <a href="/tags/message-loop/" style="font-size: 15px;">message-loop</a> <a href="/tags/SFINAE/" style="font-size: 15px;">SFINAE</a> <a href="/tags/template/" style="font-size: 15px;">template</a> <a href="/tags/visual-studio/" style="font-size: 15px;">visual studio</a> <a href="/tags/libx264/" style="font-size: 15px;">libx264</a> <a href="/tags/vcpkg/" style="font-size: 15px;">vcpkg</a> <a href="/tags/shared-ptr/" style="font-size: 15px;">shared_ptr</a> <a href="/tags/type-injection/" style="font-size: 15px;">type injection</a> <a href="/tags/shared-ptr-internals/" style="font-size: 15px;">shared_ptr-internals</a> <a href="/tags/source-code-study/" style="font-size: 15px;">source-code-study</a> <a href="/tags/weak-ptr/" style="font-size: 15px;">weak_ptr</a> <a href="/tags/base-lib/" style="font-size: 15px;">base lib</a> <a href="/tags/tag-dispatching/" style="font-size: 15px;">tag dispatching</a> <a href="/tags/boost/" style="font-size: 15px;">boost</a> <a href="/tags/libstdc/" style="font-size: 15px;">libstdc++</a> <a href="/tags/gcc/" style="font-size: 15px;">gcc</a> <a href="/tags/clang/" style="font-size: 15px;">clang</a> <a href="/tags/sfinae/" style="font-size: 15px;">sfinae</a> <a href="/tags/google-breakpad/" style="font-size: 15px;">google-breakpad</a> <a href="/tags/invalid-paramter/" style="font-size: 15px;">invalid paramter</a> <a href="/tags/operator/" style="font-size: 15px;">operator[]</a> <a href="/tags/owner-semantics/" style="font-size: 15px;">owner semantics</a> <a href="/tags/view-semantics/" style="font-size: 15px;">view semantics</a> <a href="/tags/msvc/" style="font-size: 15px;">msvc</a> <a href="/tags/ebo/" style="font-size: 15px;">ebo</a> <a href="/tags/multiple-inheritance/" style="font-size: 15px;">multiple inheritance</a> <a href="/tags/Visual-Studio/" style="font-size: 15px;">Visual Studio</a> <a href="/tags/debugger/" style="font-size: 15px;">debugger</a> <a href="/tags/UTF-8/" style="font-size: 15px;">UTF-8</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/haskell/" style="font-size: 15px;">haskell</a> <a href="/tags/infix-operator/" style="font-size: 15px;">infix operator</a> <a href="/tags/error-handling/" style="font-size: 15px;">error handling</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mint/" style="font-size: 15px;">mint</a> <a href="/tags/%E7%A3%81%E7%9B%98/" style="font-size: 15px;">磁盘</a> <a href="/tags/%E6%89%A9%E5%AE%B9/" style="font-size: 15px;">扩容</a> <a href="/tags/line-ending/" style="font-size: 15px;">line ending</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.daozhihun.com/" title="刀之魂 | 大木老师成长日记" target="_blank">刀之魂 | 大木老师成长日记</a><ul></ul><a href="https://blog.nlogn.cn/" title="帧哥 | 硅谷谈撸管" target="_blank">帧哥 | 硅谷谈撸管</a><ul></ul><a href="https://blog.chichou.me/" title="ChiChou | 首席安全地球仪切图总奸" target="_blank">ChiChou | 首席安全地球仪切图总奸</a><ul></ul><a href="https://fleurer.github.io/" title="Fleurer-lee | F叔的读书笔记（大量干货）" target="_blank">Fleurer-lee | F叔的读书笔记（大量干货）</a><ul></ul><a href="https://vizee.org/" title="Vizee | 即将走上人生巅峰推萝莉的章总" target="_blank">Vizee | 即将走上人生巅峰推萝莉的章总</a><ul></ul><a href="https://blog.thecjw.me/" title="TheCJW | 爱弹棉花的小伟" target="_blank">TheCJW | 爱弹棉花的小伟</a><ul></ul><a href="https://newbiecoder.0ginr.com/blog/" title="Newbie Coder | 萌萌哒的炉子" target="_blank">Newbie Coder | 萌萌哒的炉子</a><ul></ul><a href="https://frankpie.github.io/" title="裴草莓 | 愤怒的老司机" target="_blank">裴草莓 | 愤怒的老司机</a><ul></ul><a href="https://beanbee.me/" title="陈老师 | Beanbee.Max" target="_blank">陈老师 | Beanbee.Max</a><ul></ul><a href="https://sunus.me/" title="Sunus | 李师傅食品厂CEO" target="_blank">Sunus | 李师傅食品厂CEO</a><ul></ul><a href="http://www.tolower.net/" title="Lower | 喊大木大哥的小弟" target="_blank">Lower | 喊大木大哥的小弟</a><ul></ul><a href="http://mrljdx.com/" title="Mrljdx | 大保健老司机" target="_blank">Mrljdx | 大保健老司机</a><ul></ul><a href="https://www.mydavelv.net/" title="Davelv | 江湖人称大尾驴" target="_blank">Davelv | 江湖人称大尾驴</a></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//kingsamchen-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">KC的废墟堆.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>