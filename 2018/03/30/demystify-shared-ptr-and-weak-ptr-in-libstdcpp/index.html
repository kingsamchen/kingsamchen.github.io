<!DOCTYPE html>
<html lang="default">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="浅析 shared_ptr：Libstdc++ 篇"/>




  <meta name="keywords" content="c++, shared_ptr, shared_ptr-internals, source-code-study, weak_ptr, libstdc++, gcc, clang, KC的废墟堆" />










  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://kingsamchen.github.io/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> 浅析 shared_ptr：Libstdc++ 篇 - KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          浅析 shared_ptr：Libstdc++ 篇
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-30
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#版本选择与源码位置"><span class="toc-text">版本选择与源码位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-shared-ptr-new-T-differs-from-make-shared"><span class="toc-text">How shared_ptr(new T()) differs from make_shared()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer"><span class="toc-text">Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type"><span class="toc-text">How Custom Deleter Works and Why It Is Not Part of the Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-enable-shared-from-this-works"><span class="toc-text">How enable_shared_from_this works</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-Reference-Counting-Works"><span class="toc-text">How Reference Counting Works</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-weak-ptr-relates-with-shared-ptr"><span class="toc-text">How weak_ptr relates with shared_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-safety-of-shared-ptr-Instances"><span class="toc-text">Thread-safety of shared_ptr Instances</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Epilogue"><span class="toc-text">Epilogue</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>序言请移步<a href="https://kingsamchen.github.io/2018/03/13/shared-ptr-internals-introduction/">此处</a></p>
<p>MSVC STL 的分析版本请移步<a href="https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">此处</a></p>
<p>注：因为这不是第一篇分析，所以会直入主题，跳过文学写作常用的累赘的过渡。</p>
<h2 id="版本选择与源码位置"><a href="#版本选择与源码位置" class="headerlink" title="版本选择与源码位置"></a>版本选择与源码位置</h2><p>目前的工作机是 Linux Mint 18，对应的是 Ubuntu 16.04 LTS。</p>
<p>这个版本的系统上源包默认提供的是 GCC 5.4 和 clang 3.8，跟随的 libstdc++ 的大版本是 6。</p>
<p>考虑到 Linux 上 clang 也是默认使用 libstdc++，且 GCC 6/7/8 使用的 libstdc++ 的大版本都是 6，因此直接选用目录 <code>/usr/include/c++/5</code> 下的源码作为研究对象。</p>
<h2 id="How-shared-ptr-new-T-differs-from-make-shared"><a href="#How-shared-ptr-new-T-differs-from-make-shared" class="headerlink" title="How shared_ptr(new T()) differs from make_shared()"></a>How shared_ptr(new T()) differs from make_shared()</h2><p>函数 <code>make_shared()</code> 位于文件 shared_ptr.h：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Create an object that is owned by a shared_ptr.</span></span><br><span class="line"><span class="comment">*  @param  __args  Arguments for the @a _Tp object's constructor.</span></span><br><span class="line"><span class="comment">*  @return A shared_ptr that owns the newly created object.</span></span><br><span class="line"><span class="comment">*  @throw  std::bad_alloc, or an exception thrown from the</span></span><br><span class="line"><span class="comment">*          constructor of @a _Tp.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;</span><br><span class="line">make_shared(_Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_const&lt;_Tp&gt;::type _Tp_nc;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::allocate_shared&lt;_Tp&gt;(<span class="built_in">std</span>::allocator&lt;_Tp_nc&gt;(), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数内部直接将操作转交给了 <code>std::allocate_shared</code>。这个函数虽然是 <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared" target="_blank" rel="noopener">C++ 11 引入</a>的，但是似乎是从 boost 沿袭而来，我们在 MSVC STL 的分析里并未见到过。</p>
<p>注：reference 上对这个函数的描述简洁明了，点名了就是用来实现一次内存分配的。事实上截止到 Visual Studi 2017 15.6.3，这个函数还只在 TR1 名字空间里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Create an object that is owned by a shared_ptr.</span></span><br><span class="line"><span class="comment">*  @param  __a     An allocator.</span></span><br><span class="line"><span class="comment">*  @param  __args  Arguments for the @a _Tp object's constructor.</span></span><br><span class="line"><span class="comment">*  @return A shared_ptr that owns the newly created object.</span></span><br><span class="line"><span class="comment">*  @throw  An exception thrown from @a _Alloc::allocate or from the</span></span><br><span class="line"><span class="comment">*          constructor of @a _Tp.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  A copy of @a __a will be used to allocate memory for the shared_ptr</span></span><br><span class="line"><span class="comment">*  and the new object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;</span><br><span class="line">allocate_shared(<span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(_Sp_make_shared_tag(), __a,</span><br><span class="line">                <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by allocate_shared.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="built_in">shared_ptr</span>(_Sp_make_shared_tag __tag, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__tag, __a, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>__shared_ptr</code> 是 <code>shared_ptr</code> 的基类，相当于 MSVC STL 里的 <code>_Ptr_base</code>，包含在文件 <code>shared_ptr_base.h</code> 里。</p>
<p>我们分别看一下 <code>__shared_ptr</code> 的基本成员，以及这个非标准的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="comment">// Omit irrelavent code</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Tp*	   	   _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by allocate_shared.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_ptr(_Sp_make_shared_tag __tag, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : _M_ptr(),</span><br><span class="line">      _M_refcount(__tag, (_Tp*)<span class="number">0</span>, __a, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line">    <span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line">    <span class="keyword">void</span>* __p = _M_refcount._M_get_deleter(<span class="keyword">typeid</span>(__tag));</span><br><span class="line">    _M_ptr = <span class="keyword">static_cast</span>&lt;_Tp*&gt;(__p);</span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这个构造函数有两个版本的实现，分别对应是否开启 RTTI，这里选用默认的使用 RTTI 的版本。</p>
<p>基类也是有两个成员：</p>
<ol>
<li>实例指针</li>
<li>引用计数控制块</li>
</ol>
<p>实际的构造操作依旧由引用计数控制块 <code>__shared_count</code> 完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_count</span> &#123;</span></span><br><span class="line">    <span class="comment">// Omit irrelavent code</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_count(_Sp_make_shared_tag, _Tp*, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">: _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;</span><br><span class="line">    <span class="keyword">typename</span> _Sp_cp_type::__allocator_type __a2(__a);</span><br><span class="line">    <span class="keyword">auto</span> __guard = <span class="built_in">std</span>::__allocate_guarded(__a2);</span><br><span class="line">    _Sp_cp_type* __mem = __guard.get();</span><br><span class="line">    ::<span class="keyword">new</span> (__mem) _Sp_cp_type(<span class="built_in">std</span>::move(__a),</span><br><span class="line">                <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    _M_pi = __mem;</span><br><span class="line">    __guard = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分实现比 MSVC STL 要复杂，因为牵扯到了 allocator。</p>
<p>实话说，我对 allocator 不熟悉，也从来没用过 customized allocator；同时这里使用的 allocator 相关函数大多是 libstdc++ 自己定义的，因此这块仅在宏观上提一下，不做深入分析。有兴趣的可以自己跟踪一下源代码。</p>
<p>首先，<code>_Sp_counted_ptr_inplace</code> 是 <code>_Sp_counted_base</code> 的子类，这个类有一个内部类，并且类自身只有一个这个内部类的成员（略去了不相关代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line">class _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    _Atomic_word  _M_use_count;     <span class="comment">// #shared</span></span><br><span class="line">    _Atomic_word  _M_weak_count;    <span class="comment">// #weak + (#shared != 0)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Sp_counted_ptr_inplace</span> <span class="title">final</span> :</span> <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Impl</span> :</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Alloc&gt; &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Alloc&gt;	_A_base;</span><br><span class="line"></span><br><span class="line">        __gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _Impl _M_impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，父类 <code>_Sp_counted_base</code> 包含了两个计数成员，同时子类 <code>_Sp_counted_ptr_inplace</code> 通过内部的 <code>_Impl</code>，引入了一块存储空间，大小是最外层 <code>share_ptr</code> 要管理的对象实例的大小。</p>
<p>这样一来，被管理对象的内存和控制块的内存也被组织在了一块内存上。</p>
<p>接下来研究如何分配那整块的内存；这和前面三句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> _Sp_cp_type::__allocator_type __a2(__a);</span><br><span class="line"><span class="keyword">auto</span> __guard = <span class="built_in">std</span>::__allocate_guarded(__a2);</span><br><span class="line">_Sp_cp_type* __mem = __guard.get();</span><br></pre></td></tr></table></figure>
<p>有关。</p>
<p>上面通过 <code>_Sp_counted_ptr_inplace</code> 内部定义的 allocator，利用 <a href="http://en.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">allocator rebind</a>，获取能够以 <code>_Sp_counted_ptr_inplace</code> 为粒度进行分配的 allocator，并随后分配了一块内存，也就是 <code>_mem</code> 引用的那块。</p>
<p>有了内存块之后，剩下的就是调用 in-placement new 构造出 <code>_Sp_counted_ptr_inplace</code> 对象。</p>
<p>接下来看一下顶层的 <code>__Shared_ptr::_M_ptr</code> 是如何关联到 <code>_Sp_counted_ptr_inplace</code> 里的实例成员地址的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line"><span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line"><span class="keyword">void</span>* __p = _M_refcount._M_get_deleter(<span class="keyword">typeid</span>(__tag));</span><br><span class="line">_M_ptr = <span class="keyword">static_cast</span>&lt;_Tp*&gt;(__p);</span><br></pre></td></tr></table></figure>
<p>依赖 <code>_M_get_deleter</code> 是什么鬼…看一下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class __shared_count</span></span><br><span class="line"><span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp; __ti) <span class="keyword">const</span> <span class="keyword">const</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class _Sp_counted_ptr_inplace</span></span><br><span class="line"><span class="comment">// Sneaky trick so __shared_ptr can get the managed pointer</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp; __ti) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_rtti</span></span><br><span class="line">	<span class="keyword">if</span> (__ti == <span class="keyword">typeid</span>(_Sp_make_shared_tag))</span><br><span class="line">	  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Tp* _M_ptr() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_impl._M_storage._M_ptr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是拿到 <code>_Sp_counted_ptr_inplace::Impl</code> 内部 <code>__gnu_cxx::__aligned_buffer</code> 的数据地址。</p>
<p>这里的 RTTI 的操作看得我一脸懵逼……</p>
<p>接下来看一下针对形如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; sp(<span class="keyword">new</span> T());</span><br></pre></td></tr></table></figure>
<p>的内部实现流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Construct a %shared_ptr that owns the pointer @a __p.</span></span><br><span class="line"><span class="comment"> *  @param  __p  A pointer that is convertible to element_type*.</span></span><br><span class="line"><span class="comment"> *  @post   use_count() == 1 &amp;&amp; get() == __p</span></span><br><span class="line"><span class="comment"> *  @throw  std::bad_alloc, in which case @c delete @a __p is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="keyword">explicit</span> __shared_ptr(_Tp1* __p)</span><br><span class="line">    : _M_ptr(__p), _M_refcount(__p) <span class="comment">// &lt;- set up instance ptr &amp; ref-count object</span></span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="keyword">static_assert</span>( !is_void&lt;_Tp1&gt;::value, <span class="string">"incomplete type"</span> );</span><br><span class="line">    <span class="keyword">static_assert</span>( <span class="keyword">sizeof</span>(_Tp1) &gt; <span class="number">0</span>, <span class="string">"incomplete type"</span> );</span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">explicit</span> __shared_count(_Ptr __p)</span><br><span class="line">    : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        _M_pi = <span class="keyword">new</span> _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);    <span class="comment">// &lt;- use _Sp_counted_ptr as ref-count object here</span></span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> __p;</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在这种使用场合下，ref-count 的具体数据类型是 <code>_Sp_counted_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counted ptr with no deleter or allocator support</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Sp_counted_ptr</span> <span class="title">final</span> :</span> <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> _Sp_counted_ptr(_Ptr __p) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_ptr(__p)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp;) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Sp_counted_ptr(<span class="keyword">const</span> _Sp_counted_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    _Sp_counted_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> _Sp_counted_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ptr _M_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仅仅调用构造函数初始化了内部保存的 <code>_M_ptr</code>，毕竟管理的实例对象已经创建完毕了。</p>
<p>至此整个初始化流程都已经结束了。</p>
<p><strong>Conclusion</strong></p>
<p>和 MSVC STL 的实现类似，<code>make_shared()</code> 内部保证只有一次内存分配，实例对象和计数控制块都在一块内存上，而 <code>shared_ptr()</code> 的构造就简单很多，只需要初始化计数块，同时设置对应的实例指针即可。</p>
<p>并且，两种 case 下，具体使用的 ref-count 的对象是不一样的，这可以做到针对性的优化。</p>
<p>不同点也比较明显：libstdc++ STL 多了一个 <code>shared_count</code> 中间层；同时 <code>make_shared()</code> 内部的内存分配大量依赖 allocator。</p>
<h2 id="Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer"><a href="#Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer" class="headerlink" title="Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer"></a>Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer</h2><p>这种 case 是通过 <code>shared_ptr</code> 的构造函数创建对象，只需要跟相关的 ctor 即可。</p>
<p>和 MSVC STL 类似，ctor 自身也是一个 template，参数为 <code>_Tp1</code>，并且这个参数一直通过 <code>__shared_ptr</code> - <code>__shared_count</code> - <code>_Sp_counted_ptr</code> 的 ctor template 将实际类型保存到了 <code>_Sp_counted_ptr::_M_ptr</code> 中。</p>
<p>释放实例的 <code>_Sp_counted_ptr::_M_dispose()</code> 仅仅简单的调用了一下 delete expression</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type"><a href="#How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type" class="headerlink" title="How Custom Deleter Works and Why It Is Not Part of the Type"></a>How Custom Deleter Works and Why It Is Not Part of the Type</h2><p>支持 custom deleter 同样需要通过构造函数创建对应的 <code>shared_ptr</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Construct a %shared_ptr that owns the pointer @a __p</span></span><br><span class="line"><span class="comment"> *          and the deleter @a __d.</span></span><br><span class="line"><span class="comment"> *  @param  __p  A pointer.</span></span><br><span class="line"><span class="comment"> *  @param  __d  A deleter.</span></span><br><span class="line"><span class="comment"> *  @post   use_count() == 1 &amp;&amp; get() == __p</span></span><br><span class="line"><span class="comment"> *  @throw  std::bad_alloc, in which case @a __d(__p) is called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Requirements: _Deleter's copy constructor and destructor must</span></span><br><span class="line"><span class="comment"> *  not throw</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  __shared_ptr will release __p by calling __d(__p)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line"><span class="built_in">shared_ptr</span>(_Tp1* __p, _Deleter __d)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p, __d)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，直接托管给负责干活的父类 <code>__shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line">__shared_ptr(_Tp1* __p, _Deleter __d)</span><br><span class="line">    : _M_ptr(__p),</span><br><span class="line">      _M_refcount(__p, __d)</span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="comment">// TODO requires _Deleter CopyConstructible and __d(__p) well-formed</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着又通过构造函数参数转入计数控制块 <code>_M_refcount</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line">__shared_count(_Ptr __p, _Deleter __d)</span><br><span class="line">    : __shared_count(__p, <span class="built_in">std</span>::move(__d), allocator&lt;<span class="keyword">void</span>&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">__shared_count(_Ptr __p, _Deleter __d, _Alloc __a)</span><br><span class="line">    : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typename</span> _Sp_cd_type::__allocator_type __a2(__a);</span><br><span class="line">        <span class="keyword">auto</span> __guard = <span class="built_in">std</span>::__allocate_guarded(__a2);</span><br><span class="line">        _Sp_cd_type* __mem = __guard.get();</span><br><span class="line">        ::<span class="keyword">new</span> (__mem) _Sp_cd_type(__p, <span class="built_in">std</span>::move(__d), <span class="built_in">std</span>::move(__a));</span><br><span class="line">        _M_pi = __mem;</span><br><span class="line">        __guard = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        __d(__p); <span class="comment">// Call _Deleter on __p.</span></span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出：</p>
<ol>
<li>这种情况下使用的具体 ref-count 类型是 <code>_Sp_counted_deleter</code></li>
<li>这里的内存分配依然是通过 allocator</li>
<li>deleter 和托管实例的类型通过 template paramter 一路保存了下来。因为 deleter 可能只认识创建时传递的指针类型（考虑 aliasing construction）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support for custom deleter and/or allocator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Sp_counted_deleter</span> <span class="title">final</span> :</span> <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Impl</span> :</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Deleter&gt;, _Sp_ebo_helper&lt;<span class="number">1</span>, _Alloc&gt; &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Deleter&gt; _Del_base;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">1</span>, _Alloc&gt; _Alloc_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        _Impl(_Ptr __p, _Deleter __d, <span class="keyword">const</span> _Alloc&amp; __a) <span class="keyword">noexcept</span></span><br><span class="line">            : _M_ptr(__p),</span><br><span class="line">              _Del_base(__d),</span><br><span class="line">              _Alloc_base(__a)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        _Deleter&amp; _M_del() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> _Del_base::_S_get(*<span class="keyword">this</span>); &#125;</span><br><span class="line">        _Alloc&amp; _M_alloc() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> _Alloc_base::_S_get(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">        _Ptr _M_ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __d(__p) must not throw.</span></span><br><span class="line">    _Sp_counted_deleter(_Ptr __p, _Deleter __d) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_impl(__p, __d, _Alloc()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __d(__p) must not throw.</span></span><br><span class="line">    _Sp_counted_deleter(_Ptr __p, _Deleter __d, <span class="keyword">const</span> _Alloc&amp; __a) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_impl(__p, __d, __a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~_Sp_counted_deleter() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _M_impl._M_del()(_M_impl._M_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp; __ti) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_rtti</span></span><br><span class="line">        <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">        <span class="comment">// 2400. shared_ptr's get_deleter() should use addressof()</span></span><br><span class="line">        <span class="keyword">return</span> __ti == <span class="keyword">typeid</span>(_Deleter)</span><br><span class="line">            ? <span class="built_in">std</span>::__addressof(_M_impl._M_del())</span><br><span class="line">            : <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Impl _M_impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，deleter 和 allocator 直接通过基类“组合”进了 ref-count 块。</p>
<p><strong>Conclusion</strong></p>
<p><code>shared_ptr&lt;T&gt;</code> 仅决定 <code>__shared_ptr::_M_ptr</code> 的类型，实例的运行时类型和 deleter 均保存在 <code>_Sp_counted_delter</code> 中，这个类通过 <code>__shared_ptr::_M_refcont</code> 关联。</p>
<h2 id="How-enable-shared-from-this-works"><a href="#How-enable-shared-from-this-works" class="headerlink" title="How enable_shared_from_this works"></a>How enable_shared_from_this works</h2><p>回顾一下我们知道，使用 <code>enable_shared_from_this</code> 需要满足两个条件：</p>
<ol>
<li>某个类从 <code>enable_shared_from_this</code> 继承</li>
<li>这个类的实例必须要通过 <code>shared_ptr</code> 托管。</li>
</ol>
<p>对于第一点，我们看一下这个类的成员结构（其他的部分对继承几乎没什么影响）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief Base class allowing use of member function shared_from_this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">enable_shared_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some omitted</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Tp2&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> __enable_shared_from_this_helper(<span class="keyword">const</span> __shared_count&lt;&gt;&amp;,</span><br><span class="line">                                                 <span class="keyword">const</span> enable_shared_from_this&lt;_Tp1&gt;*,</span><br><span class="line">                                                 <span class="keyword">const</span> _Tp2*) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt;  _M_weak_this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有一个 <code>weak_ptr</code> 成员，类型是需要继承的子类，CRTP 的典型用法咯。</p>
<p>还有一个 friend function 后面会提到。</p>
<p>接着看第二点，这里拿 <code>make_shared()</code> 的 case 做例子，看一段前面看过的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_ptr(_Sp_make_shared_tag __tag, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : _M_ptr(),</span><br><span class="line">      _M_refcount(__tag, (_Tp*)<span class="number">0</span>, __a, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line">    <span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line">    <span class="keyword">void</span>* __p = _M_refcount._M_get_deleter(<span class="keyword">typeid</span>(__tag));</span><br><span class="line">    _M_ptr = <span class="keyword">static_cast</span>&lt;_Tp*&gt;(__p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;- attention  here</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出核心是 <code>__enable_shared_from_this_helper()</code> 这个函数，并且：</p>
<ul>
<li>调用这个函数的之前，对象实例和 ref-count 块都已经创建完毕了</li>
<li>这个函数就是前面说的那个 friend function，所以这个而函数可以直接修改 <code>enable_shared_from_this</code> 里的 <code>_M_weak_this</code>。</li>
</ul>
<p>另外，如果托管对象并不需要这个特性，则函数重载会匹配到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __enable_shared_from_this_helper(<span class="keyword">const</span> __shared_count&lt;_Lp&gt;&amp;, ...) <span class="keyword">noexcept</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>看一下函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Tp2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __enable_shared_from_this_helper(<span class="keyword">const</span> __shared_count&lt;&gt;&amp; __pn,</span><br><span class="line">                                             <span class="keyword">const</span> enable_shared_from_this&lt;_Tp1&gt;* __pe,</span><br><span class="line">                                             <span class="keyword">const</span> _Tp2* __px) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__pe != <span class="literal">nullptr</span>)</span><br><span class="line">        __pe-&gt;_M_weak_assign(<span class="keyword">const_cast</span>&lt;_Tp2*&gt;(__px), __pn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from class enable_shared_from_this</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="keyword">void</span> _M_weak_assign(_Tp1* __p, <span class="keyword">const</span> __shared_count&lt;&gt;&amp; __n) <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _M_weak_this._M_assign(__p, __n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">weak_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Used by __enable_shared_from_this.</span></span><br><span class="line">    <span class="keyword">void</span> _M_assign(_Tp* __ptr, <span class="keyword">const</span> __shared_count&lt;_Lp&gt;&amp; __refcount) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _M_ptr = __ptr;</span><br><span class="line">        _M_refcount = __refcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Tp*	 	 _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __weak_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__weak_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line"></span><br><span class="line">    _M_pi = __tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面完成了托管对象的父类 <code>enable_shared_from_this</code> 中的 <code>weak_ptr</code> 和前面通过创建 <code>shared_ptr</code> 对象时创建的 ref-count 结构关联。</p>
<p>并且可以看出，完成关联后，weak-count 的计数是2：</p>
<ol>
<li>父类 enable_shared_from_this 的构造不作任何处理</li>
<li><code>shared_ptr</code> 闯将完毕后 usage-count 和 weak-count 都是 1，然后关联的时候通过 <code>_M_wak_add_ref()</code> 增加了 weak-count</li>
</ol>
<p>另外，虽然 <code>weak_ptr</code> 的父类是 <code>__weak_ptr</code>，但是这个类和 <code>__shared_ptr</code> 一样有两个成员，并且 <code>__weak_count</code> 的成员也是 <code>_Sp_counted_base</code>，和 <code>__shared_count</code> 一样。</p>
<p>这里和 MSVC STL 稍有不同，猜测可能是 libstdc++ 为了获取 <code>shared_ptr</code> 和 <code>weak_ptr</code> 之间更大的独立性？</p>
<p>接下来看一下函数 <code>shared_from_this()</code> 的工作原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from class enable_shared_from_this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;_Tp&gt; shared_from_this()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接利用了从 <code>weak-ptr</code> 构造 <code>shared_ptr</code> 的技法。</p>
<p><strong>Conclusion</strong></p>
<p>这部分的思路和 MSVC STL 一致，<code>enable_shared_from_this</code> 中保存一个 <code>weak_ptr</code> 成员，并且在构造 <code>shared_ptr</code> 对象时和 ref-count 关联。</p>
<p><code>shared_from_this()</code> 直接复用从 <code>weak-ptr</code> 构造 <code>shared_ptr</code> 的逻辑，只不过这个时候基本不存在 usage count 为 0 的情况。</p>
<p>注：libstdc++ 里有一个类似的类叫 <code>__enable_shared_from_this</code>，形式上和 <code>enable_shared_from_this</code> 很相似，只不过成员已经直接是 <code>__weak_ptr</code>。</p>
<p>至于为什么会有这个 duplication，表示不是很懂。</p>
<h2 id="How-Reference-Counting-Works"><a href="#How-Reference-Counting-Works" class="headerlink" title="How Reference Counting Works"></a>How Reference Counting Works</h2><p>通过前面的分析可以知道，引用计数是由 <code>__shared_count</code> 保存的成员指针 <code>_Sp_counted_base</code> 管理。</p>
<p>计数 usage-count 和 weak-count 的类型都是 <code>_Atomic_word</code>，这个类型定义在 <code>atomic_word.h</code> 中，实际上是 <code>int</code>。</p>
<p><code>_Sp_counted_base</code> 在构造时将两个计数都设置为 1。</p>
<p>同时提供</p>
<ul>
<li><code>_M_add_ref_copy()</code>，<code>_M_add_ref_lock()</code> 和 <code>_M_release()</code> 由上层根据上下文对 usage-count 进行增减</li>
<li><code>_M_weak_add_ref()</code> 和 <code>_M_weak_release()</code> 由上层根据上下文对 weak-count 进行增减</li>
</ul>
<p>NOTE：因为 libstdc++ 使用范围更广，所以提供了单线程版本、用锁的版本和使用原子操作的版本。同时因为具体的 atomic 实现在 libstdc++ 里有点乱，这里不研究 atomic operations 的细节，仅假设其能工作正常（废话），并站在高层抽象语义角度去分析对应的原子操作。</p>
<p>先看一下 usage-count 的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_add_ref_copy()</span><br><span class="line">&#123;</span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_Sp_counted_base&lt;_S_atomic&gt;::</span><br><span class="line">_M_add_ref_lock()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Perform lock-free add-if-not-zero operation.</span></span><br><span class="line">    _Atomic_word __count = _M_get_use_count();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__count == <span class="number">0</span>)</span><br><span class="line">            __throw_bad_weak_ptr();</span><br><span class="line">        <span class="comment">// Replace the current counter value with the old value + 1, as</span></span><br><span class="line">        <span class="comment">// long as it's not changed meanwhile.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + <span class="number">1</span>,</span><br><span class="line">                                        <span class="literal">true</span>, __ATOMIC_ACQ_REL,</span><br><span class="line">                                        __ATOMIC_RELAXED));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_Sp_counted_base&lt;_S_atomic&gt;::</span><br><span class="line">_M_add_ref_lock_nothrow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Perform lock-free add-if-not-zero operation.</span></span><br><span class="line">    _Atomic_word __count = _M_get_use_count();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Replace the current counter value with the old value + 1, as</span></span><br><span class="line">        <span class="comment">// long as it's not changed meanwhile.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + <span class="number">1</span>,</span><br><span class="line">                                        <span class="literal">true</span>, __ATOMIC_ACQ_REL,</span><br><span class="line">                                        __ATOMIC_RELAXED));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">        _M_dispose();</span><br><span class="line">        <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">        <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">        <span class="comment">// thread that runs destroy().</span></span><br><span class="line">        <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            _GLIBCXX_READ_MEM_BARRIER;</span><br><span class="line">            _GLIBCXX_WRITE_MEM_BARRIER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,</span><br><span class="line">                <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">            _M_destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_M_add_ref_copy()</code> 就是单纯的自增 usage-count，发生在 <code>__shared_count</code> 的拷贝创建或者赋值时；而 <code>_M_add_ref_lock()</code> 以来一个完整的 CAS，根据之前对 MSVC STL 的分析，我们这里可以猜测这个函数是用来 promote 一个 <code>weak_ptr</code> 到 <code>shared_ptr</code> 的，后面可以验证一下这个猜想。</p>
<p><code>_M_release()</code> 会首先自减 usage-count，如果减到0了，就释放托管的对象实例；同时再自减 weak-count，如果此时也为 0，那么说明这个 ref-count 已经凉了，就可以整个销毁了。</p>
<p>然后是 weak-count 的计数操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_weak_add_ref() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_weak_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly. For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// See _M_release(),</span></span><br><span class="line">            <span class="comment">// destroy() must observe results of dispose()</span></span><br><span class="line">            _GLIBCXX_READ_MEM_BARRIER;</span><br><span class="line">            _GLIBCXX_WRITE_MEM_BARRIER;</span><br><span class="line">        &#125;</span><br><span class="line">        _M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本和上面一致。</p>
<p><code>_M_weak_add_ref()</code> 的调用时机基本是：</p>
<ul>
<li>从 <code>__weak_count</code> 或 <code>__shared_count</code> 拷贝构造得到一个 <code>__weak_count</code></li>
<li>将一个 <code>__weak_count</code> 或 <code>__shared_count</code> 赋值给另外一个 <code>__weak_count</code> （这种情况伴随着 <code>_M_weak_release()</code> 调用）</li>
</ul>
<p><code>_M_weak_release()</code> 除了赋值时会调用外，剩下的就是析构时。</p>
<p><strong>Conclusion</strong></p>
<p>两个引用计数的操作基本转换成了 <code>__shared_count</code> 对象和 <code>__weak_count</code> 对象之间的交互。</p>
<p>一般情况下，实现采用的方案都是通过 atomic operations 实现计数，但是根据源码我们也发现了专门针对单线程版本和不支持 atomic 的有锁版本。</p>
<h2 id="How-weak-ptr-relates-with-shared-ptr"><a href="#How-weak-ptr-relates-with-shared-ptr" class="headerlink" title="How weak_ptr relates with shared_ptr"></a>How weak_ptr relates with shared_ptr</h2><p>这部分和上一个 ref-count 的分析部分其实关系非常紧密。</p>
<p>promotion 在外部的表象就是通过 <code>weak_ptr::lock()</code> 完成。虽然通过 <code>shared_ptr</code> 的构造函数也可以，但是如果对象已经死了，构造函数会抛异常，徒增复杂度，我想应该没谁会这么折腾吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from weak_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;_Tp&gt;</span><br><span class="line">lock() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(*<span class="keyword">this</span>, <span class="built_in">std</span>::nothrow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from shared_ptr</span></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by weak_ptr::lock().</span></span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="keyword">const</span> weak_ptr&lt;_Tp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__r, <span class="built_in">std</span>::nothrow) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from __shared_ptr</span></span><br><span class="line"><span class="comment">// This constructor is used by __weak_ptr::lock() and</span></span><br><span class="line"><span class="comment">// shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).</span></span><br><span class="line">__shared_ptr(<span class="keyword">const</span> __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : _M_refcount(__r._M_refcount, <span class="built_in">std</span>::nothrow)</span><br><span class="line">&#123;</span><br><span class="line">    _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that __weak_count is defined we can define this constructor:</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">__shared_count&lt;_Lp&gt;::</span><br><span class="line">__shared_count(<span class="keyword">const</span> __weak_count&lt;_Lp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : _M_pi(__r._M_pi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">if</span> (!_M_pi-&gt;_M_add_ref_lock_nothrow())</span><br><span class="line">            _M_pi = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这里和 MSVC STL 大致上还是类似的。</p>
<p>利用 CAS 去加 usage-count，如果成功了，说明对象还活着，成功 promotion；反之，计数为0，自增函数返回 false，构造一个空对象。</p>
<h2 id="Thread-safety-of-shared-ptr-Instances"><a href="#Thread-safety-of-shared-ptr-Instances" class="headerlink" title="Thread-safety of shared_ptr Instances"></a>Thread-safety of shared_ptr Instances</h2><p>假设对一个 <code>shared_ptr</code> 对象 sp 又读又写：</p>
<ol>
<li>从 sp 创建一个拷贝</li>
<li>将 sp 设置为另一个 <code>shared_ptr</code> 实例</li>
</ol>
<p>这两点涉及 <code>shared_ptr</code> 的拷贝构造或拷贝赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__shared_ptr(<span class="keyword">const</span> __shared_ptr&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">__shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_ptr&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>直接采用编译器提供的实现。</p>
<p>因为 <code>__shared_ptr</code> 存有实例对象指针和计数控制块指针，复制操作做不到原子的改变两个值。</p>
<p>至于多个对象独立的析构，前面我们可以看到，这个是通过原子的改变引用计数完成，可以保证线程安全性。</p>
<p>同时，通过上一节可以看出 <code>weak_ptr</code> 到 <code>shared_ptr</code> 的 promotion 也是通过 CAS 操作保证了安全性。</p>
<h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>Libstdc++ 的分析版本到这里也结束了。</p>
<p>相比 MSVC STL，我觉得 libstdc++ 版本分析起来更困难，原因总结有三：</p>
<ol>
<li>源码分析环境不如直接在 Windows 那么友好，一些 gnu-extension 啥的文件需要翻来覆去的找</li>
<li>部分内存分配采用 allocator，我对 allocator 真心不熟悉<br>举例：有多少人知道 allocator 一开始不是为了 a mean of allocation 出现，而是为了屏蔽 near/far 地址</li>
<li>因为 libstdc++ 涉及更多的平台，并且有一些扩展实现，增加了代码分析的量</li>
</ol>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://kingsamchen.github.io">Kingsley Chen</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://kingsamchen.github.io/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/">http://kingsamchen.github.io/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/c/">c++</a>
            
              <a href="/tags/shared-ptr/">shared_ptr</a>
            
              <a href="/tags/shared-ptr-internals/">shared_ptr-internals</a>
            
              <a href="/tags/source-code-study/">source-code-study</a>
            
              <a href="/tags/weak-ptr/">weak_ptr</a>
            
              <a href="/tags/libstdc/">libstdc++</a>
            
              <a href="/tags/gcc/">gcc</a>
            
              <a href="/tags/clang/">clang</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/04/01/monthly-read-posts-in-mar-2018/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Monthly Read Posts in Mar 2018</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">
        <span class="next-text nav-default">浅析 shared_ptr：MSVC STL 篇</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://kingsamchen.github.io/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/';
        this.page.identifier = '2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/';
        this.page.title = '浅析 shared_ptr：Libstdc++ 篇';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//kingsamchen-github-io.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
