<!DOCTYPE html>
<html lang="default">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="浅析 RefCounted 和 WeakPtr：Chromium Base 篇"/>




  <meta name="keywords" content="c++, chromium, shared_ptr, shared_ptr-internals, source-code-study, weak_ptr, base lib, KC的废墟堆" />










  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://kingsamchen.github.io/2018/05/14/demystify-ref-counted-and-weak-ptr-in-chromium-base/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  









    <title> 浅析 RefCounted 和 WeakPtr：Chromium Base 篇 - KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          浅析 RefCounted 和 WeakPtr：Chromium Base 篇
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-05-14
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#目标版本选择"><span class="toc-text">目标版本选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RefCountedBase-和-RefCounted"><span class="toc-text">RefCountedBase 和 RefCounted</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAII-for-Reference-Counting-scoped-refptr"><span class="toc-text">RAII for Reference Counting: scoped_refptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakPtr-related-Utils"><span class="toc-text">WeakPtr-related Utils</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Epilogue"><span class="toc-text">Epilogue</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>序言请移步<a href="https://kingsamchen.github.io/2018/03/13/shared-ptr-internals-introduction/">此处</a></p>
<p>MSVC STL 的分析版本请移步<a href="https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">此处</a></p>
<p>Libstdc++ 的分析版本请移步<a href="https://kingsamchen.github.io/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/">此处</a></p>
<p>Boost 的分析版本请移步<a href="https://kingsamchen.github.io/2018/05/02/demystify-shared-ptr-and-weak-ptr-in-boost/">此处</a></p>
<p>注 1：因为这不是第一篇分析，所以会直入主题，跳过文学写作常用的累赘的过渡。</p>
<p>注 2：这是系列最后一篇。</p>
<h2 id="目标版本选择"><a href="#目标版本选择" class="headerlink" title="目标版本选择"></a>目标版本选择</h2><p>Chromium tag 68.0.3421.1</p>
<p>代码位置：<code>base/memory/ref_counted.{h, cc}</code></p>
<h2 id="RefCountedBase-和-RefCounted"><a href="#RefCountedBase-和-RefCounted" class="headerlink" title="RefCountedBase 和 RefCounted"></a>RefCountedBase 和 RefCounted</h2><p>两个类实现了非线程安全的引用计数，即：内部计数使用的是 built-in integer</p>
<p>先看看 <code>RefCountedBase</code> 的大致结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCountedBase</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RefCountedBase</span><span class="params">(StartRefCountFromZeroTag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RefCountedBase</span><span class="params">(StartRefCountFromOneTag)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~RefCountedBase();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddRef</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Release</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">uint32_t</span> ref_count_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DCHECK_IS_ON()</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> needs_adopt_ref_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> in_dtor_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">mutable</span> SequenceChecker sequence_checker_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    DISALLOW_COPY_AND_ASSIGN(RefCountedBase);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出核心 <code>ref_count_</code> 类型是 <code>uint32_t</code></p>
<p>ctor 和 dtor 都被定义为 protected，说明这类使用做基类；同时提供了 <code>AddRef()</code> 和 <code>Release()</code>，进行内部的计数增减。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddRef</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DCHECK_IS_ON()</span></span><br><span class="line">    DCHECK(!in_dtor_);</span><br><span class="line">    DCHECK(!needs_adopt_ref_)</span><br><span class="line">        &lt;&lt; <span class="string">"This RefCounted object is created with non-zero reference count."</span></span><br><span class="line">        &lt;&lt; <span class="string">" The first reference to such a object has to be made by AdoptRef or"</span></span><br><span class="line">        &lt;&lt; <span class="string">" MakeRefCounted."</span>;</span><br><span class="line">    <span class="keyword">if</span> (ref_count_ &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        DCHECK(CalledOnValidSequence());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    AddRefImpl();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> RefCountedBase::AddRefImpl() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// Check if |ref_count_| overflow only on 64 bit archs since the number of</span></span><br><span class="line">    <span class="comment">// objects may exceed 2^32.</span></span><br><span class="line">    <span class="comment">// To avoid the binary size bloat, use non-inline function here.</span></span><br><span class="line">    CHECK(++ref_count_ &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns true if the object should self-delete. </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Release</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    --ref_count_;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DCHECK_IS_ON()</span></span><br><span class="line">    DCHECK(!in_dtor_);</span><br><span class="line">    <span class="keyword">if</span> (ref_count_ == <span class="number">0</span>)</span><br><span class="line">        in_dtor_ = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ref_count_ &gt;= <span class="number">1</span>)</span><br><span class="line">        DCHECK(CalledOnValidSequence());</span><br><span class="line">    <span class="keyword">if</span> (ref_count_ == <span class="number">1</span>)</span><br><span class="line">        sequence_checker_.DetachFromSequence();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ref_count_ == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个函数除了计数增减外，还有相当多用于调试检查的代码。</p>
<p>吐槽一句，这里把两个函数标记为 const，同时使用 mutable 成员的操作真是…</p>
<p>接下来看一下 <code>RefCounted</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DefaultRefCountedTraits</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destruct</span><span class="params">(<span class="keyword">const</span> T* x)</span> </span>&#123;</span><br><span class="line">    RefCounted&lt;T, DefaultRefCountedTraits&gt;::DeleteInternal(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">typename</span> <span class="title">Traits</span> = <span class="title">DefaultRefCountedTraits</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RefCounted</span> :</span> <span class="keyword">public</span> subtle::RefCountedBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> subtle::StartRefCountFromZeroTag kRefCountPreference =</span><br><span class="line">      subtle::kStartRefCountFromZeroTag;</span><br><span class="line"> </span><br><span class="line">  RefCounted() : subtle::RefCountedBase(T::kRefCountPreference) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddRef</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    subtle::RefCountedBase::AddRef();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subtle::RefCountedBase::Release()) &#123;</span><br><span class="line">      <span class="comment">// Prune the code paths which the static analyzer may take to simulate</span></span><br><span class="line">      <span class="comment">// object destruction. Use-after-free errors aren't possible given the</span></span><br><span class="line">      <span class="comment">// lifetime guarantees of the refcounting system.</span></span><br><span class="line">      ANALYZER_SKIP_THIS_PATH();</span><br><span class="line"> </span><br><span class="line">      Traits::Destruct(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ~RefCounted() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">DefaultRefCountedTraits</span>&lt;T&gt;;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteInternal</span><span class="params">(<span class="keyword">const</span> U* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(RefCounted);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个实现可以算是 CRTP 的经典实现，毕竟父类要正确的 delete 子类必须要保证操作能拿到子类的实际类型。</p>
<p>具体的 deletion 可以通过模板参数注入，默认的策略就是使用 <code>delete this</code></p>
<p>还有一点需要注意一下：<code>RefCounted</code> 的构造函数结束后，计数仍然是0，除非子类修改了 preferred start-count；这意味着 <code>scoped_refptr</code> 一定会在构造时候手动调用 <code>AddRef()</code>，这点后面可以看到。</p>
<p>接下来看一下线程安全的 <code>RefCountedThreadSafeBase</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> AtomicRefCount ref_count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// for AddRef()</span></span><br><span class="line">ref_count_.Increment();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// for Release()</span></span><br><span class="line"><span class="keyword">if</span> (!ref_count_.Decrement()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>这个版本的 <code>AtomicRefCount</code> 内部实现是 <code>std::atomic_int</code>，代码位置在 <code>base/atomic_ref_count.h</code></p>
<p>因为 <code>RefCountedThreadSafe</code> 实现基本和 <code>RefCounted</code> 一致，这里就不细究了。</p>
<p><strong>Ref-count Start Policy</strong></p>
<p>当 <code>RefCounted</code> / <code>RefCountedThreadSafe</code> 初始化他们的父类时，会传入 <code>kRefCountPreference</code>，这个值指明引用计数应该从0还是1开始。这个值可以被子类重定义。</p>
<p><strong>对比 shared_ptr</strong></p>
<p>base 的 <code>RefCounted(ThreadSafe)</code> 是侵入式的实现，并且 deleter 的提供是直接作为类型一部分。</p>
<p>另外，因为侵入式，所以不需要 <code>std::enable_shared_from_this</code> 这类东西了。</p>
<h2 id="RAII-for-Reference-Counting-scoped-refptr"><a href="#RAII-for-Reference-Counting-scoped-refptr" class="headerlink" title="RAII for Reference Counting: scoped_refptr"></a>RAII for Reference Counting: scoped_refptr</h2><p><code>scoped_refptr</code> 在这里完全就是一个引用计数操作的 RAII 设施</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">scoped_refptr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T element_type;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// omitted</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  T* ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它的 <code>AddRef()</code> 和 <code>Release()</code> 被定义为了 static functions：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-inline helpers to allow:</span></span><br><span class="line"><span class="comment">//     class Opaque;</span></span><br><span class="line"><span class="comment">//     extern template class scoped_refptr&lt;Opaque&gt;;</span></span><br><span class="line"><span class="comment">// Otherwise the compiler will complain that Opaque is an incomplete type.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRef</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Release</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> scoped_refptr&lt;T&gt;::AddRef(T* ptr) &#123;</span><br><span class="line">  ptr-&gt;AddRef();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> scoped_refptr&lt;T&gt;::Release(T* ptr) &#123;</span><br><span class="line">  ptr-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，这里有两种方式创建一个 <code>scoped_refptr</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The old-fashioned way</span></span><br><span class="line">scoped_refptr&lt;MyFoo&gt; foo(<span class="keyword">new</span> MyFoo());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The make-way</span></span><br><span class="line">scoped_refptr&lt;MyFoo&gt; foo = MakeRefCounted&lt;MyFoo&gt;();</span><br><span class="line"></span><br><span class="line">we check the old-fashioned way first, examing what it will <span class="keyword">do</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructs from raw pointer. constexpr if |p| is null.</span></span><br><span class="line">constexpr scoped_refptr(T* p) : ptr_(p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr_)</span><br><span class="line">    AddRef(ptr_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看传统方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructs from raw pointer. constexpr if |p| is null.</span></span><br><span class="line">constexpr scoped_refptr(T* p) : ptr_(p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr_)</span><br><span class="line">    AddRef(ptr_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了两件事：赋值 + 加计数</p>
<p>接下来看一下新版的 <code>MakeRefCounted()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructs an instance of T, which is a ref counted type, and wraps the</span></span><br><span class="line"><span class="comment">// object into a scoped_refptr&lt;T&gt;.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">scoped_refptr&lt;T&gt; MakeRefCounted(Args&amp;&amp;... args) &#123;</span><br><span class="line">  T* obj = <span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="keyword">return</span> subtle::AdoptRefIfNeeded(obj, T::kRefCountPreference);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> subtle &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">scoped_refptr&lt;T&gt; AdoptRefIfNeeded(T* obj, StartRefCountFromZeroTag) &#123;</span><br><span class="line">  <span class="keyword">return</span> scoped_refptr&lt;T&gt;(obj);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">scoped_refptr&lt;T&gt; AdoptRefIfNeeded(T* obj, StartRefCountFromOneTag) &#123;</span><br><span class="line">  <span class="keyword">return</span> AdoptRef(obj);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;  <span class="comment">// namespace subtle</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Creates a scoped_refptr from a raw pointer without incrementing the reference</span></span><br><span class="line"><span class="comment">// count. Use this only for a newly created object whose reference count starts</span></span><br><span class="line"><span class="comment">// from 1 instead of 0.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">scoped_refptr&lt;T&gt; AdoptRef(T* obj) &#123;</span><br><span class="line">  <span class="keyword">using</span> Tag = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(T::kRefCountPreference)&gt;;</span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;subtle::StartRefCountFromOneTag, Tag&gt;::value,</span><br><span class="line">                <span class="string">"Use AdoptRef only for the reference count starts from one."</span>);</span><br><span class="line"> </span><br><span class="line">  DCHECK(obj);</span><br><span class="line">  DCHECK(obj-&gt;HasOneRef());</span><br><span class="line">  obj-&gt;Adopted();</span><br><span class="line">  <span class="keyword">return</span> scoped_refptr&lt;T&gt;(obj, subtle::kAdoptRefTag);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">scoped_refptr(T* p, base::subtle::AdoptRefTag) : ptr_(p)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是 ref-count-start-policy aware，如果选择计数从1开始，那么构造时就不会自增。</p>
<p>相比较而言，这也是 preferable way</p>
<p>剩下的最重要的点就是复制和移动，毕竟 ref-counted 最重要的就是计数相关的语义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy constructor. This is required in addition to the copy conversion</span></span><br><span class="line"><span class="comment">// constructor below.</span></span><br><span class="line">scoped_refptr(<span class="keyword">const</span> scoped_refptr&amp; r) : scoped_refptr(r.ptr_)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy conversion constructor.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">              <span class="built_in">std</span>::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;</span><br><span class="line">scoped_refptr(<span class="keyword">const</span> scoped_refptr&lt;U&gt;&amp; r) : scoped_refptr(r.ptr_)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Move constructor. This is required in addition to the move conversion</span></span><br><span class="line"><span class="comment">// constructor below.</span></span><br><span class="line">scoped_refptr(scoped_refptr&amp;&amp; r) <span class="keyword">noexcept</span> : ptr_(r.ptr_) &#123;</span><br><span class="line">  r.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Move conversion constructor.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">              <span class="built_in">std</span>::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;</span><br><span class="line">scoped_refptr(scoped_refptr&lt;U&gt;&amp;&amp; r) <span class="keyword">noexcept</span> : ptr_(r.ptr_) &#123;</span><br><span class="line">  r.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">scoped_refptr&amp; <span class="keyword">operator</span>=(T* p) &#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span> = scoped_refptr(p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Unified assignment operator.</span></span><br><span class="line">scoped_refptr&amp; <span class="keyword">operator</span>=(scoped_refptr r) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  swap(r);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WeakPtr-related-Utils"><a href="#WeakPtr-related-Utils" class="headerlink" title="WeakPtr-related Utils"></a>WeakPtr-related Utils</h2><p>base 提供了诸如 <code>WeakPtr</code> 允许使用者检查一个对象是否已经析构（毕竟千古难题）</p>
<p>但是和 <code>std::weak_ptr</code> 依赖 <code>std::shared_ptr</code> 不一样，<code>WeakPtr</code> 和 <code>RefCounted</code> 是（逻辑上）互相独立的</p>
<p>常规用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span></span></span><br><span class="line">        : str_(std::move(s)), weak_factory_(this)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    ~Foo() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">str</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    base::WeakPtr&lt;Foo&gt; as_weak_ptr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weak_factory_.GetWeakPtr();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str_;</span><br><span class="line">    base::WeakPtrFactory&lt;Foo&gt; weak_factory_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">base::WeakPtr&lt;Foo&gt; ptr;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(<span class="string">"test"</span>)</span></span>;</span><br><span class="line">    ptr = f.as_weak_ptr();</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr-&gt;str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The foo has been dead\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先从 <code>WeakPtrFactory</code> 入手：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BASE_EXPORT</span> <span class="title">WeakPtrFactoryBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  WeakPtrFactoryBase(<span class="keyword">uintptr_t</span> ptr)</span><br><span class="line">  : ptr_(ptr)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  ~WeakPtrFactoryBase() &#123;</span><br><span class="line">    ptr_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  internal::WeakReferenceOwner weak_reference_owner_;</span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace internal</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">WeakPtrFactory</span> :</span> <span class="keyword">public</span> internal::WeakPtrFactoryBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WeakPtrFactory</span><span class="params">(T* ptr)</span>   <span class="comment">// Note: ptr here usually is this-ptr.</span></span></span><br><span class="line">      : WeakPtrFactoryBase(reinterpret_cast&lt;uintptr_t&gt;(ptr)) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  ~WeakPtrFactory() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  WeakPtr&lt;T&gt; GetWeakPtr() &#123;</span><br><span class="line">    DCHECK(ptr_);</span><br><span class="line">    <span class="keyword">return</span> WeakPtr&lt;T&gt;(weak_reference_owner_.GetRef(),</span><br><span class="line">                      <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(ptr_));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Omitted...</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  DISALLOW_IMPLICIT_CONSTRUCTORS(WeakPtrFactory);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>WeakPtrFactory</code> 没有直接定义任何成员，唯二的两个定义在父类 <code>WeakPtrFactoryBase</code>中：</p>
<ul>
<li><code>ptr_</code> 保存了管理对象的指针</li>
<li><code>weak_reference_owner_</code> 用来跟踪对象是否还活着</li>
</ul>
<p>所以看一下 <code>WeakReferenceOwner</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BASE_EXPORT</span> <span class="title">WeakReferenceOwner</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  WeakReferenceOwner() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  ~WeakReferenceOwner();</span><br><span class="line"> </span><br><span class="line">  <span class="function">WeakReference <span class="title">GetRef</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">HasRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> flag_ &amp;&amp; !flag_-&gt;HasOneRef(); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Invalidate</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> scoped_refptr&lt;WeakReference::Flag&gt; flag_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">WeakReferenceOwner::~WeakReferenceOwner() &#123;</span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">WeakReference WeakReferenceOwner::GetRef() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// If we hold the last reference to the Flag then create a new one.</span></span><br><span class="line">  <span class="keyword">if</span> (!HasRefs())</span><br><span class="line">    flag_ = <span class="keyword">new</span> WeakReference::Flag();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> WeakReference(flag_);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> WeakReferenceOwner::Invalidate() &#123;</span><br><span class="line">  <span class="keyword">if</span> (flag_) &#123;</span><br><span class="line">    flag_-&gt;Invalidate();</span><br><span class="line">    flag_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// An inner class of WeakReference</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BASE_EXPORT</span> <span class="title">Flag</span> :</span> <span class="keyword">public</span> RefCountedThreadSafe&lt;Flag&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Flag();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Invalidate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">base</span>:</span>:RefCountedThreadSafe&lt;Flag&gt;;</span><br><span class="line"> </span><br><span class="line">  ~Flag();</span><br><span class="line"> </span><br><span class="line">  SequenceChecker sequence_checker_;</span><br><span class="line">  <span class="keyword">bool</span> is_valid_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>WeakReferenceOwner</code> 内部维护了 <code>WeakReference::Flag</code>，which 是一个引用计数对象，并且 <code>WeakReferenceOwner</code> 可以通过这个 flag 创建 <code>WeakReference</code> 对象，这个就是 <code>WeakReferenceOwner::GetRef()</code> 做的事儿。</p>
<p>所以我们可以提出一个假设：所有相关的 <code>WeakReference</code> 内部都有一个相同的 flag，并且这个 flag 由一个 <code>WeakReferenceOwner</code> 控制：如果 invalidate 这个 flag，比如 <code>WeakReferenceOwner</code> 进入析构了，那么所有的 <code>WeakReference</code> 都能知道他们关心的对象要狗带了。</p>
<p>为了证实这个假设，我们看一下 <code>WeakReference</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BASE_EXPORT</span> <span class="title">WeakReference</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  WeakReference() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WeakReference</span><span class="params">(<span class="keyword">const</span> scoped_refptr&lt;Flag&gt;&amp; flag)</span></span>;</span><br><span class="line">  ~WeakReference() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  WeakReference(WeakReference&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakReference(<span class="keyword">const</span> WeakReference&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakReference&amp; <span class="keyword">operator</span>=(WeakReference&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakReference&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> WeakReference&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  scoped_refptr&lt;<span class="keyword">const</span> Flag&gt; flag_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">WeakReference::WeakReference(<span class="keyword">const</span> scoped_refptr&lt;Flag&gt;&amp; flag) : flag_(flag)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> WeakReference::is_valid() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> flag_ &amp;&amp; flag_-&gt;IsValid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的实现可以看出，<code>WeakReference</code> 实例实际上代表对 flag 的一个引用访问。</p>
<p>接下来我们看一下 <code>WeakPtr</code> 是怎么把这些东西组合在一起的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BASE_EXPORT</span> <span class="title">WeakPtrBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  WeakPtrBase();</span><br><span class="line">  ~WeakPtrBase();</span><br><span class="line"> </span><br><span class="line">  WeakPtrBase(<span class="keyword">const</span> WeakPtrBase&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakPtrBase(WeakPtrBase&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakPtrBase&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> WeakPtrBase&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakPtrBase&amp; <span class="keyword">operator</span>=(WeakPtrBase&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_ = internal::WeakReference();</span><br><span class="line">    ptr_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  WeakPtrBase(<span class="keyword">const</span> WeakReference&amp; ref, <span class="keyword">uintptr_t</span> ptr);</span><br><span class="line"> </span><br><span class="line">  WeakReference ref_;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// This pointer is only valid when ref_.is_valid() is true.  Otherwise, its</span></span><br><span class="line">  <span class="comment">// value is undefined (as opposed to nullptr).</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">WeakPtrBase::WeakPtrBase() : ptr_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">WeakPtrBase::~WeakPtrBase() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">WeakPtrBase::WeakPtrBase(<span class="keyword">const</span> WeakReference&amp; ref, <span class="keyword">uintptr_t</span> ptr)</span><br><span class="line">    : ref_(ref), ptr_(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span> :</span> <span class="keyword">public</span> internal::WeakPtrBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  WeakPtr() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line">  WeakPtr(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Allow conversion from U to T provided U "is a" T. Note that this</span></span><br><span class="line">  <span class="comment">// is separate from the (implicit) copy and move constructors.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  WeakPtr(<span class="keyword">const</span> WeakPtr&lt;U&gt;&amp; other) : WeakPtrBase(other) &#123;</span><br><span class="line">    <span class="comment">// Need to cast from U* to T* to do pointer adjustment in case of multiple</span></span><br><span class="line">    <span class="comment">// inheritance. This also enforces the "U is a T" rule.</span></span><br><span class="line">    T* t = <span class="keyword">reinterpret_cast</span>&lt;U*&gt;(other.ptr_);</span><br><span class="line">    ptr_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  WeakPtr(WeakPtr&lt;U&gt;&amp;&amp; other) : WeakPtrBase(<span class="built_in">std</span>::move(other)) &#123;</span><br><span class="line">    <span class="comment">// Need to cast from U* to T* to do pointer adjustment in case of multiple</span></span><br><span class="line">    <span class="comment">// inheritance. This also enforces the "U is a T" rule.</span></span><br><span class="line">    T* t = <span class="keyword">reinterpret_cast</span>&lt;U*&gt;(other.ptr_);</span><br><span class="line">    ptr_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(t);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ref_.is_valid() ? <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(ptr_) : <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">    DCHECK(get() != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> *get();</span><br><span class="line">  &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    DCHECK(get() != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> get();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Allow conditionals to test validity, e.g. if (weak_ptr) &#123;...&#125;;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> get() != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">internal</span>:</span>:SupportsWeakPtrBase;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakPtr</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportsWeakPtr</span>&lt;T&gt;;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakPtrFactory</span>&lt;T&gt;;</span></span><br><span class="line"> </span><br><span class="line">  WeakPtr(<span class="keyword">const</span> internal::WeakReference&amp; ref, T* ptr)</span><br><span class="line">      : WeakPtrBase(ref, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(ptr)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>WeakPtr</code> 有两个成员：</p>
<ul>
<li><code>ref_</code> 来反映被管理对象的生命周期</li>
<li><code>ptr_</code> 保存被管理对象的地址，仅当 <code>ref_</code> 有效时这个成员才是可以安全访问的</li>
</ul>
<p><strong>Conclusion</strong></p>
<p>这部分实现和 <code>std::weak_ptr</code> 颇有类似，核心都是通过：被多个探测器(<code>WeakPtr</code>)共享的一个引用技术控制块，这里是 <code>WeakReference::Flag</code>，来保存被管理对象的状态，因为控制块的生命周期可以远超过对象本身，因此即使对象狗带了，这个控制块也可以被访问到。</p>
<p>当对象行将就木之际，控制块设置为 invalid 状态，这样 <code>WeakPtr::get()</code> 就能探测到对象已经挂了，返回 nullptr。</p>
<p>base 版本的实现的最大的缺点是：这部分不是线程安全的。</p>
<p>不过有时候这也是一个优点，强迫规范线程的使用，同时结合 CSP 来尽可能促进一个对象的生老病死只发生在一个县城。</p>
<h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>这篇 post 是整个系列的最后一篇了，这四篇分析过来基本也可以对 reference counting 以及 weak-reference idiom 有了一定的了解。</p>
<p>从这几篇 post 的源代码可以看出，Chromium 的 C++ 写的并不好，但是工程化做的很漂亮。有时候可能这点更加重要。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://kingsamchen.github.io">Kingsley Chen</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://kingsamchen.github.io/2018/05/14/demystify-ref-counted-and-weak-ptr-in-chromium-base/">http://kingsamchen.github.io/2018/05/14/demystify-ref-counted-and-weak-ptr-in-chromium-base/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/c/">c++</a>
            
              <a href="/tags/chromium/">chromium</a>
            
              <a href="/tags/shared-ptr/">shared_ptr</a>
            
              <a href="/tags/shared-ptr-internals/">shared_ptr-internals</a>
            
              <a href="/tags/source-code-study/">source-code-study</a>
            
              <a href="/tags/weak-ptr/">weak_ptr</a>
            
              <a href="/tags/base-lib/">base lib</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/05/30/build-your-own-thread-pool-with-cpp/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Build Your Own Threadpool With C++</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/05/02/demystify-shared-ptr-and-weak-ptr-in-boost/">
        <span class="next-text nav-default">浅析 shared_ptr：Boost 篇</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://kingsamchen.github.io/2018/05/14/demystify-ref-counted-and-weak-ptr-in-chromium-base/';
        this.page.identifier = '2018/05/14/demystify-ref-counted-and-weak-ptr-in-chromium-base/';
        this.page.title = '浅析 RefCounted 和 WeakPtr：Chromium Base 篇';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//kingsamchen-github-io.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
