<!DOCTYPE html>
<html lang="default">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Chromium Base MessageLoop Internals (1)"/>




  <meta name="keywords" content="chromium, source internals, message-loop, KC的废墟堆" />










  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://kingsamchen.github.io/2018/11/25/chromium-base-message-loop-internals-1/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Chromium Base MessageLoop Internals (1) - KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Chromium Base MessageLoop Internals (1)
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-11-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#class-MessageLoop"><span class="toc-text">class MessageLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MessageLoop-Type"><span class="toc-text">MessageLoop Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-a-MessageLoop"><span class="toc-text">Create a MessageLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Run-a-MessageLoop"><span class="toc-text">Run a MessageLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-MessagePump"><span class="toc-text">class MessagePump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Post-Tasks"><span class="toc-text">Post Tasks</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h2 id="class-MessageLoop"><a href="#class-MessageLoop" class="headerlink" title="class MessageLoop"></a>class MessageLoop</h2><p>Version: r70_3538<br>File: <code>base/message_loop/message_loop.{h, cc}</code></p>
<p>A <code>MessageLoop</code> is used to process events for a particular thread, i.e. the core infrastructure for implementing Communicating Sequential Process (CSP) model.</p>
<p>There is at most one MessageLoop instance on a thread.</p>
<p><code>MessageLoop</code> is a farily complex class, it driveds from multiple base classes:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BASE_EXPORT</span> <span class="title">MessageLoop</span> :</span> <span class="keyword">public</span> MessagePump::Delegate,</span><br><span class="line">                                <span class="keyword">public</span> RunLoop::Delegate,</span><br><span class="line">                                <span class="keyword">public</span> MessageLoopCurrent &#123;</span><br><span class="line">    <span class="comment">// omitted...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="MessageLoop-Type"><a href="#MessageLoop-Type" class="headerlink" title="MessageLoop Type"></a>MessageLoop Type</h3><p>A MessageLoop has a particular type, differred by the set of asynchronous events it is capable of handling.<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// TYPE_DEFAULT</span></span><br><span class="line">  <span class="comment">//   This type of ML only supports tasks and timers.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TYPE_UI</span></span><br><span class="line">  <span class="comment">//   This type of ML also supports native UI events (e.g., Windows messages).</span></span><br><span class="line">  <span class="comment">//   See also MessageLoopForUI.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TYPE_IO</span></span><br><span class="line">  <span class="comment">//   This type of ML also supports asynchronous IO.  See also</span></span><br><span class="line">  <span class="comment">//   MessageLoopForIO.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TYPE_JAVA</span></span><br><span class="line">  <span class="comment">//   This type of ML is backed by a Java message handler which is responsible</span></span><br><span class="line">  <span class="comment">//   for running the tasks added to the ML. This is only for use on Android.</span></span><br><span class="line">  <span class="comment">//   TYPE_JAVA behaves in essence like TYPE_UI, except during construction</span></span><br><span class="line">  <span class="comment">//   where it does not use the main thread specific pump factory.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TYPE_CUSTOM</span></span><br><span class="line">  <span class="comment">//   MessagePump was supplied to constructor.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    TYPE_DEFAULT,</span><br><span class="line">    TYPE_UI,</span><br><span class="line">    TYPE_CUSTOM,</span><br><span class="line">    TYPE_IO,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">    TYPE_JAVA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// defined(OS_ANDROID)</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>The <code>TYPE_CUSTOM</code> is recently added, IIRC.</p>
<h3 id="Create-a-MessageLoop"><a href="#Create-a-MessageLoop" class="headerlink" title="Create a MessageLoop"></a>Create a MessageLoop</h3><p>The common usage of MessageLoop is as follows</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a TYPE_DEFAULT message-loop.</span></span><br><span class="line">base::MessageLoop loop;</span><br><span class="line"></span><br><span class="line">base::RunLoop run_loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run_loop internally calls loop.Run()</span></span><br><span class="line">run_loop.Run();</span><br></pre></td></tr></table></figure>
<p>Although <code>base::MessageLoop::Run()</code> is private, it is actually inherited from <code>base::RunLoop::Delegate</code>, in which the function is public. So we simply skip <code>base::RunLoop</code> related context here and just focus on <code>base::MessageLoop</code> itself.</p>
<p>Let’s first check its constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MessagePumpFactoryCallback =</span><br><span class="line">    OnceCallback&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessagePump&gt;()&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type = TYPE_DEFAULT</span></span><br><span class="line">MessageLoop::MessageLoop(Type type)</span><br><span class="line">    : MessageLoop(type, MessagePumpFactoryCallback()) &#123;</span><br><span class="line">  BindToCurrentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The ctor</p>
<ol>
<li>delegates the construction to another ctor</li>
<li>calls <code>BindToCurrentThread()</code></li>
</ol>
<p>and we know that pump factory callback must whatever returns a <code>std::unique_ptr&lt;MessagePump&gt;()</code> instance, and for the message-loop in default-type, the factory callback is empty.</p>
<p>Now, we should better continue our construction-adventure, examing what the delegatee constructor does.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MessageLoop::MessageLoop(Type type, MessagePumpFactoryCallback pump_factory)</span><br><span class="line">    : MessageLoopCurrent(<span class="keyword">this</span>),</span><br><span class="line">      type_(type),</span><br><span class="line">      pump_factory_(<span class="built_in">std</span>::move(pump_factory)),</span><br><span class="line">      message_loop_controller_(</span><br><span class="line">          <span class="keyword">new</span> Controller(<span class="keyword">this</span>)),  <span class="comment">// Ownership transferred on the next line.</span></span><br><span class="line">      underlying_task_runner_(MakeRefCounted&lt;internal::MessageLoopTaskRunner&gt;(</span><br><span class="line">          WrapUnique(message_loop_controller_))),</span><br><span class="line">      sequenced_task_source_(underlying_task_runner_.get()),</span><br><span class="line">      task_runner_(underlying_task_runner_) &#123;</span><br><span class="line">  <span class="comment">// If type is TYPE_CUSTOM non-null pump_factory must be given.</span></span><br><span class="line">  DCHECK(type_ != TYPE_CUSTOM || !pump_factory_.is_null());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bound in BindToCurrentThread();</span></span><br><span class="line">  DETACH_FROM_THREAD(bound_thread_checker_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One of its bases, <code>MessageLoopCurrent</code> is created, as we are creating a MessageLoop bound for the current thread.</p>
<p>Next few fancy members are actually <code>underlying_task_runner</code>-centric; a <code>MessageLoopTaskRunner</code> receives and queues tasks destined to its owning <code>MessageLoop</code>, and this <code>MessageLoop</code> will extract its tasks from the <code>underlying_task_runner</code>.</p>
<p>So, we can think this underlying task runner is the source of tasks the message-loop demands.</p>
<p><code>message_loop_controller</code>, in <code>MessageLoop::Controller</code>, is used by the uderlying-task-runner, to control its owning message-loop in some limited ways.</p>
<p>Note, <code>DETACH_FROM_THREAD()</code> here has nothing to do with our topic, so we skip it too and turn our spotlight on <code>BindToCurrentThread()</code>.</p>
<p>This function configures various members and binds this message loop to the current thread.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::BindToCurrentThread() &#123;</span><br><span class="line">  DCHECK_CALLED_ON_VALID_THREAD(bound_thread_checker_);</span><br><span class="line"></span><br><span class="line">  DCHECK(!pump_);</span><br><span class="line">  <span class="keyword">if</span> (!pump_factory_.is_null())</span><br><span class="line">    pump_ = <span class="built_in">std</span>::move(pump_factory_).Run();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pump_ = CreateMessagePumpForType(type_);</span><br><span class="line"></span><br><span class="line">  DCHECK(!MessageLoopCurrent::IsSet())</span><br><span class="line">      &lt;&lt; <span class="string">"should only have one message loop per thread"</span>;</span><br><span class="line">  MessageLoopCurrent::BindToCurrentThreadInternal(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  underlying_task_runner_-&gt;BindToCurrentThread();</span><br><span class="line">  message_loop_controller_-&gt;StartScheduling();</span><br><span class="line">  SetThreadTaskRunnerHandle();</span><br><span class="line">  thread_id_ = PlatformThread::CurrentId();</span><br><span class="line"></span><br><span class="line">  scoped_set_sequence_local_storage_map_for_current_thread_ = <span class="built_in">std</span>::make_unique&lt;</span><br><span class="line">      internal::ScopedSetSequenceLocalStorageMapForCurrentThread&gt;(</span><br><span class="line">      &amp;sequence_local_storage_map_);</span><br><span class="line"></span><br><span class="line">  RunLoop::RegisterDelegateForCurrentThread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">  <span class="comment">// On Android, attach to the native loop when there is one.</span></span><br><span class="line">  <span class="keyword">if</span> (type_ == TYPE_UI || type_ == TYPE_JAVA)</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;MessagePumpForUI*&gt;(pump_.get())-&gt;Attach(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For what interests us, this function mainly</p>
<ol>
<li>creates the message-pump the loop is going to use.</li>
<li>binds the instance to <code>MessageLoopCurrent</code>‘s TLS member</li>
<li>binds the underlying-task-runner to the thread</li>
<li>starts scheduling via message-loop-controller</li>
</ol>
<p>Then we see what does <code>message_loop_controller_-&gt;StartScheduling()</code> do inside.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::Controller::StartScheduling() &#123;</span><br><span class="line">  <span class="function">AutoLock <span class="title">lock</span><span class="params">(message_loop_lock_)</span></span>;</span><br><span class="line">  DCHECK(message_loop_);</span><br><span class="line">  DCHECK(!is_ready_for_scheduling_);</span><br><span class="line">  is_ready_for_scheduling_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (pending_schedule_work_)</span><br><span class="line">    message_loop_-&gt;ScheduleWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Initially, <code>is_ready_for_scheduling_</code> and <code>pending_schedule_work_</code> are both <code>false</code>, and the latter aren’t <code>true</code> until <code>MessageLoop::Controller::DidQueueTask()</code> is called.</p>
<p>Thus, this function is more like to declare that the message-loop is ready for scheduling/running; and, I guess, <code>pending_schedue_work_</code> being true here should be rare and only in unusual cases.</p>
<h3 id="Run-a-MessageLoop"><a href="#Run-a-MessageLoop" class="headerlink" title="Run a MessageLoop"></a>Run a MessageLoop</h3><p>From our example</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_loop.Run();</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base::MessageLoop loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application_tasks_allowed == true</span></span><br><span class="line">loop.Run(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>Let’s see it.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::Run(<span class="keyword">bool</span> application_tasks_allowed) &#123;</span><br><span class="line">  DCHECK_CALLED_ON_VALID_THREAD(bound_thread_checker_);</span><br><span class="line">  <span class="keyword">if</span> (application_tasks_allowed &amp;&amp; !task_execution_allowed_) &#123;</span><br><span class="line">    <span class="comment">// Allow nested task execution as explicitly requested.</span></span><br><span class="line">    DCHECK(RunLoop::IsNestedOnCurrentThread());</span><br><span class="line">    task_execution_allowed_ = <span class="literal">true</span>;</span><br><span class="line">    pump_-&gt;Run(<span class="keyword">this</span>);</span><br><span class="line">    task_execution_allowed_ = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pump_-&gt;Run(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Key point here is</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pump_-&gt;Run(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>and calling this function will ‘block’ on here, until the message-pump quits.</p>
<p>Similarly for <code>MessageLoop::Quit()</code>, which forwards the call to <code>MessagePump::Quit()</code>.</p>
<p>So I guess member <code>pump_</code>‘s type, <code>MessagePump</code> its our next big guy to trace.</p>
<h3 id="class-MessagePump"><a href="#class-MessagePump" class="headerlink" title="class MessagePump"></a>class MessagePump</h3><p>File: <code>base/message_loop/message_pump*.{h, cc}</code></p>
<p><code>MessagePump</code> is an abstract/interface class and its whole hierarchy is fairly complex; and yet, it defines the basic routine of what <code>MessagePump::Run()</code> should do.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The anatomy of a typical run loop:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="keyword">bool</span> did_work = DoInternalWork();</span><br><span class="line">  <span class="keyword">if</span> (should_quit_)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  did_work |= delegate_-&gt;DoWork();</span><br><span class="line">  <span class="keyword">if</span> (should_quit_)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  TimeTicks next_time;</span><br><span class="line">  did_work |= delegate_-&gt;DoDelayedWork(&amp;next_time);</span><br><span class="line">  <span class="keyword">if</span> (should_quit_)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (did_work)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  did_work = delegate_-&gt;DoIdleWork();</span><br><span class="line">  <span class="keyword">if</span> (should_quit_)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (did_work)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  WaitForWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DoInternalDowrk()</code> is highly related with the actual pump we are using:</p>
<ul>
<li>for UI-pump, it receives and dispatches UI events from native system</li>
<li>for IO-pump, it receives and notifies IO events</li>
<li>but for Default-pump, it even does not provide this kind of function, because there is no such <em>internal</em> work for this kind of pump.</li>
</ul>
<p>And for simplicity, we focus on the class <code>MessagePumpDefault</code> this time.</p>
<p>The <code>MessagePumpDefault</code> is simple and succinct, yet with full capabilities for normal message-loop uses.</p>
<p>Ctor and dtor of the class are both simple:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessagePumpDefault::MessagePumpDefault()</span><br><span class="line">    : keep_running_(<span class="literal">true</span>),</span><br><span class="line">      event_(WaitableEvent::ResetPolicy::AUTOMATIC,</span><br><span class="line">             WaitableEvent::InitialState::NOT_SIGNALED) &#123;&#125;</span><br><span class="line"></span><br><span class="line">MessagePumpDefault::~MessagePumpDefault() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p><code>event_</code> is a <code>WaitableEvent</code> and used for controlling execution of the pump.</p>
<p>Now let us see the key function, <code>Run()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpDefault::Run(Delegate* delegate) &#123;</span><br><span class="line">  AutoReset&lt;<span class="keyword">bool</span>&gt; auto_reset_keep_running(&amp;keep_running_, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_MACOSX)</span></span><br><span class="line">    mac::ScopedNSAutoreleasePool autorelease_pool;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> did_work = delegate-&gt;DoWork();</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    did_work |= delegate-&gt;DoDelayedWork(&amp;delayed_work_time_);</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (did_work)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    did_work = delegate-&gt;DoIdleWork();</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (did_work)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    ThreadRestrictions::ScopedAllowWait allow_wait;</span><br><span class="line">    <span class="keyword">if</span> (delayed_work_time_.is_null()) &#123;</span><br><span class="line">      event_.Wait();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No need to handle already expired |delayed_work_time_| in any special</span></span><br><span class="line">      <span class="comment">// way. When |delayed_work_time_| is in the past TimeWaitUntil returns</span></span><br><span class="line">      <span class="comment">// promptly and |delayed_work_time_| will re-initialized on a next</span></span><br><span class="line">      <span class="comment">// DoDelayedWork call which has to be called in order to get here again.</span></span><br><span class="line">      event_.TimedWaitUntil(delayed_work_time_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Since event_ is auto-reset, we don't need to do anything special here</span></span><br><span class="line">    <span class="comment">// other than service each delegate method.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Some observations:</p>
<ul>
<li>no internal work for default pump</li>
<li>if had work done, try to handle subsequent work immedately</li>
<li>otherwise, block until being wakeup or for a given period (<code>delayed_work_time_</code>)</li>
<li>actual works are done by pump’s owner, the owning <code>MessageLoop</code>, via <code>MessagePump::Delegate</code>.</li>
<li>after execution of each kind of work, it checks if the loop should quit, which is indicated by <code>keep_running_</code></li>
</ul>
<p>This loop model, doesn’t handles all pending tasks at once, it instead handles one task of a specific kind at one iteration, to make the whole loop more responsive.</p>
<p>By the way, quitting the pump-loop is simply to make <code>keep_running_ = false</code>, which is exactly what <code>MessagePump::Quit()</code> does:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpDefault::Quit() &#123;</span><br><span class="line">  keep_running_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We now focus on <code>MessageLoop</code> again, to examine how works are processed.</p>
<p>From code above, we know there are three categories of work:</p>
<ul>
<li>work</li>
<li>delayed work</li>
<li>idle work</li>
</ul>
<p>Let’s go through one-by-one:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoop::DoWork() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!task_execution_allowed_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute oldest task.</span></span><br><span class="line">  <span class="keyword">while</span> (sequenced_task_source_-&gt;HasTasks()) &#123;</span><br><span class="line">    PendingTask pending_task = sequenced_task_source_-&gt;TakeTask();</span><br><span class="line">    <span class="keyword">if</span> (pending_task.task.IsCancelled())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pending_task.delayed_run_time.is_null()) &#123;</span><br><span class="line">      <span class="keyword">int</span> sequence_num = pending_task.sequence_num;</span><br><span class="line">      TimeTicks delayed_run_time = pending_task.delayed_run_time;</span><br><span class="line">      pending_task_queue_.delayed_tasks().Push(<span class="built_in">std</span>::move(pending_task));</span><br><span class="line">      <span class="comment">// If we changed the topmost task, then it is time to reschedule.</span></span><br><span class="line">      <span class="keyword">if</span> (pending_task_queue_.delayed_tasks().Peek().sequence_num ==</span><br><span class="line">          sequence_num) &#123;</span><br><span class="line">        pump_-&gt;ScheduleDelayedWork(delayed_run_time);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DeferOrRunPendingTask(<span class="built_in">std</span>::move(pending_task))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Nothing happened.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MessageLoop::DeferOrRunPendingTask(PendingTask pending_task) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pending_task.nestable == Nestable::kNestable ||</span><br><span class="line">      !RunLoop::IsNestedOnCurrentThread()) &#123;</span><br><span class="line">    RunTask(&amp;pending_task);</span><br><span class="line">    <span class="comment">// Show that we ran a task (Note: a new one might arrive as a</span></span><br><span class="line">    <span class="comment">// consequence!).</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We couldn't run the task now because we're in a nested run loop</span></span><br><span class="line">  <span class="comment">// and the task isn't nestable.</span></span><br><span class="line">  pending_task_queue_.deferred_tasks().Push(<span class="built_in">std</span>::move(pending_task));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function first checks to see if there is any pending task in the <code>sequenced_task_source_</code>, then exracts it out and</p>
<ul>
<li>saves into the <code>pending_task_queue_.delayed_task</code> queue, if the task is a delayed-task</li>
<li>runs the pending task</li>
</ul>
<p>Note, if the delayed task would expire earlier than any tasks in the delayed queue, the message-loop will reset expiration time.</p>
<p>This is done via <code>MessagePump::ScheduleDelayedWork()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpDefault::ScheduleDelayedWork(</span><br><span class="line">    <span class="keyword">const</span> TimeTicks&amp; delayed_work_time) &#123;</span><br><span class="line">  <span class="comment">// We know that we can't be blocked on Wait right now since this method can</span></span><br><span class="line">  <span class="comment">// only be called on the same thread as Run, so we only need to update our</span></span><br><span class="line">  <span class="comment">// record of how long to sleep when we do sleep.</span></span><br><span class="line">  delayed_work_time_ = delayed_work_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Delayed tasks in <code>pending_task_queue_.delayed_task</code> will be processed subsequentely inside <code>MessageLoop::DoDelayedWork()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!task_execution_allowed_ ||</span><br><span class="line">      !pending_task_queue_.delayed_tasks().HasTasks()) &#123;</span><br><span class="line">    *next_delayed_work_time = TimeTicks();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When we "fall behind", there will be a lot of tasks in the delayed work</span></span><br><span class="line">  <span class="comment">// queue that are ready to run.  To increase efficiency when we fall behind,</span></span><br><span class="line">  <span class="comment">// we will only call Time::Now() intermittently, and then process all tasks</span></span><br><span class="line">  <span class="comment">// that are ready to run before calling it again.  As a result, the more we</span></span><br><span class="line">  <span class="comment">// fall behind (and have a lot of ready-to-run delayed tasks), the more</span></span><br><span class="line">  <span class="comment">// efficient we'll be at handling the tasks.</span></span><br><span class="line"></span><br><span class="line">  TimeTicks next_run_time =</span><br><span class="line">      pending_task_queue_.delayed_tasks().Peek().delayed_run_time;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_run_time &gt; recent_time_) &#123;</span><br><span class="line">    recent_time_ = TimeTicks::Now();  <span class="comment">// Get a better view of Now();</span></span><br><span class="line">    <span class="keyword">if</span> (next_run_time &gt; recent_time_) &#123;</span><br><span class="line">      *next_delayed_work_time = CapAtOneDay(next_run_time);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PendingTask pending_task = pending_task_queue_.delayed_tasks().Pop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pending_task_queue_.delayed_tasks().HasTasks()) &#123;</span><br><span class="line">    *next_delayed_work_time = CapAtOneDay(</span><br><span class="line">        pending_task_queue_.delayed_tasks().Peek().delayed_run_time);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> DeferOrRunPendingTask(<span class="built_in">std</span>::move(pending_task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function runs every tasks that has been expired.</p>
<p>Because we said before, that the pump handles a task at a time, so the above code contains a minor optimization for handling delayed takss: it calls <code>TimeTicks::Now()</code> only when <code>next_run_time</code> maybe in the future.</p>
<p>Doing so can reduce number of times it calls <code>Time::Now()</code>.</p>
<p>Function <code>MessageLoop::DoIdleWork()</code> is rather boring, it does some metrics work only.</p>
<h3 id="Post-Tasks"><a href="#Post-Tasks" class="headerlink" title="Post Tasks"></a>Post Tasks</h3><p>Two frequently used functions for adding a task to the message-loop are:</p>
<ul>
<li>PostTask()</li>
<li>PostDelayedTask()</li>
</ul>
<p>and in fact, <code>PostTask()</code> is merely a call of <code>PostDelayedTask()</code> with 0-delay.</p>
<p>And in our example, this function is implemented by class <code>MessageLoopTaskRunner</code>.</p>
<p>For brevity, I deleted some not-so-related code on purpose:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoopTaskRunner::PostDelayedTask(<span class="keyword">const</span> Location&amp; from_here,</span><br><span class="line">                                            OnceClosure task,</span><br><span class="line">                                            base::TimeDelta delay) &#123;</span><br><span class="line">  <span class="keyword">return</span> AddToIncomingQueue(from_here, <span class="built_in">std</span>::move(task), delay,</span><br><span class="line">                            Nestable::kNestable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MessageLoopTaskRunner::AddToIncomingQueue(<span class="keyword">const</span> Location&amp; from_here,</span><br><span class="line">                                               OnceClosure task,</span><br><span class="line">                                               TimeDelta delay,</span><br><span class="line">                                               Nestable nestable) &#123;</span><br><span class="line">  PendingTask pending_task(from_here, std::move(task),</span><br><span class="line">                           CalculateDelayedRuntime(from_here, delay), nestable);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_WIN)</span></span><br><span class="line">  <span class="comment">// We consider the task needs a high resolution timer if the delay is</span></span><br><span class="line">  <span class="comment">// more than 0 and less than 32ms. This caps the relative error to</span></span><br><span class="line">  <span class="comment">// less than 50% : a 33ms wait can wake at 48ms since the default</span></span><br><span class="line">  <span class="comment">// resolution on Windows is between 10 and 15ms.</span></span><br><span class="line">  <span class="keyword">if</span> (delay &gt; TimeDelta() &amp;&amp;</span><br><span class="line">      delay.InMilliseconds() &lt; (<span class="number">2</span> * Time::kMinLowResolutionThresholdMs)) &#123;</span><br><span class="line">    pending_task.is_high_res = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> was_empty;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">AutoLock <span class="title">auto_lock</span><span class="params">(incoming_queue_lock_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (accept_new_tasks_) &#123;</span><br><span class="line">      <span class="comment">// Initialize the sequence number. The sequence number is used for delayed</span></span><br><span class="line">      <span class="comment">// tasks (to facilitate FIFO sorting when two tasks have the same</span></span><br><span class="line">      <span class="comment">// delayed_run_time value) and for identifying the task in about:tracing.</span></span><br><span class="line">      pending_task.sequence_num = next_sequence_num_++;</span><br><span class="line"></span><br><span class="line">      task_source_observer_-&gt;WillQueueTask(&amp;pending_task);</span><br><span class="line"></span><br><span class="line">      was_empty = outgoing_queue_empty_ &amp;&amp; incoming_queue_.empty();</span><br><span class="line">      incoming_queue_.push(<span class="built_in">std</span>::move(pending_task));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Let |task_source_observer_| know about the task just queued. It's important</span></span><br><span class="line">  <span class="comment">// to do this outside of |incoming_queue_lock_| to avoid blocking tasks</span></span><br><span class="line">  <span class="comment">// incoming from other threads on the resolution of DidQueueTask().</span></span><br><span class="line">  task_source_observer_-&gt;DidQueueTask(was_empty);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimeTicks <span class="title">CalculateDelayedRuntime</span><span class="params">(<span class="keyword">const</span> Location&amp; from_here, TimeDelta delay)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> delay &gt; TimeDelta() ? TimeTicks::Now() + delay : TimeTicks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can see that, if a task is a delayed task, its time-detal will be converted into an absolute time-tick.</p>
<p>Then the task is enqueued into <code>incoming_queue_</code>, which is</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> TaskQueue = base::<span class="built_in">queue</span>&lt;PendingTask&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An incoming queue of tasks that are acquired under a mutex for processing</span></span><br><span class="line"><span class="comment">// on this instance's thread. These tasks have not yet been been pushed to</span></span><br><span class="line"><span class="comment">// |outgoing_queue_|.</span></span><br><span class="line">TaskQueue incoming_queue_;</span><br></pre></td></tr></table></figure>
<p>Insertion is done with a lock being hold, because the task may come from other threads.</p>
<p>Finally it notifies a task was queued, to let the pump reschedule if necessary.</p>
<p>Retrieval of tasks out of the runner is not so complicated too:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tasks to be returned to TakeTask(). Reloaded from |incoming_queue_| when</span></span><br><span class="line"><span class="comment">// it becomes empty.</span></span><br><span class="line">TaskQueue outgoing_queue_;</span><br><span class="line"></span><br><span class="line">PendingTask MessageLoopTaskRunner::TakeTask() &#123;</span><br><span class="line">  <span class="comment">// Must be called on execution sequence, unless clearing tasks from an unbound</span></span><br><span class="line">  <span class="comment">// MessageLoop.</span></span><br><span class="line">  DCHECK(RunsTasksInCurrentSequence() || valid_thread_id_ == kInvalidThreadId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HasTasks() will reload the queue if necessary (there should always be</span></span><br><span class="line">  <span class="comment">// pending tasks by contract).</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> has_tasks = HasTasks();</span><br><span class="line">  DCHECK(has_tasks);</span><br><span class="line"></span><br><span class="line">  PendingTask pending_task = <span class="built_in">std</span>::move(outgoing_queue_.front());</span><br><span class="line">  outgoing_queue_.pop();</span><br><span class="line">  <span class="keyword">return</span> pending_task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MessageLoopTaskRunner::HasTasks() &#123;</span><br><span class="line">  <span class="comment">// Must be called on execution sequence, unless clearing tasks from an unbound</span></span><br><span class="line">  <span class="comment">// MessageLoop.</span></span><br><span class="line">  DCHECK(RunsTasksInCurrentSequence() || valid_thread_id_ == kInvalidThreadId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outgoing_queue_.empty()) &#123;</span><br><span class="line">    <span class="function">AutoLock <span class="title">lock</span><span class="params">(incoming_queue_lock_)</span></span>;</span><br><span class="line">    incoming_queue_.swap(outgoing_queue_);</span><br><span class="line">    outgoing_queue_empty_ = outgoing_queue_.empty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !outgoing_queue_.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HasTasks()</code> has major side-effects, it reloads <code>outgoing_queue_</code> from <code>incoming_queue_</code> when necessary; while <code>TaskTask()</code> simply extracts a task from the <code>outgoing_queue_</code>.</p>
<p><strong>NOTE</strong>: accesses to <code>outgoing_queue_</code> is thread-safe without locks, because we only dequeue tasks on the thread running the message-loop.</p>
<p>Using two queues here, is to reduce contention.</p>
<p>For completeness, we now take a look at <code>pending_task_queue_.delayed_tasks</code>, which stores timed-tasks.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DelayedQueue delayed_tasks_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The queue for holding tasks that should be run later and sorted by expected</span></span><br><span class="line"><span class="comment">// run time.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedQueue</span> :</span> <span class="keyword">public</span> Queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DelayedQueue();</span><br><span class="line">  ~DelayedQueue() override;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  DelayedTaskQueue queue_;</span><br><span class="line"></span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(DelayedQueue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PendingTasks are sorted by their |delayed_run_time| property.</span></span><br><span class="line"><span class="keyword">using</span> DelayedTaskQueue = <span class="built_in">std</span>::priority_queue&lt;base::PendingTask&gt;;</span><br></pre></td></tr></table></figure>
<p>um…it is a simple priority queue.</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://kingsamchen.github.io">Kingsley Chen</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://kingsamchen.github.io/2018/11/25/chromium-base-message-loop-internals-1/">http://kingsamchen.github.io/2018/11/25/chromium-base-message-loop-internals-1/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/chromium/">chromium</a>
            
              <a href="/tags/source-internals/">source internals</a>
            
              <a href="/tags/message-loop/">message-loop</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2018/11/24/running-bash-and-wsl-under-mintty-in-cmder/">
        <span class="next-text nav-default">在 cmder 里以 mintty 为终端的方式运行 bash 和 wsl</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://kingsamchen.github.io/2018/11/25/chromium-base-message-loop-internals-1/';
        this.page.identifier = '2018/11/25/chromium-base-message-loop-internals-1/';
        this.page.title = 'Chromium Base MessageLoop Internals (1)';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//kingsamchen-github-io.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
