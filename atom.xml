<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KC的废墟堆</title>
  
  <subtitle>Will you serve in Heaven, or rule in Hell</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kingsamchen.github.io/"/>
  <updated>2019-02-10T12:49:50.720Z</updated>
  <id>http://kingsamchen.github.io/</id>
  
  <author>
    <name>Kingsley Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 工程依赖管理新方向：CMake &amp; Git</title>
    <link href="http://kingsamchen.github.io/2019/02/10/use-cmake-and-git-as-your-cpp-dependency-manager/"/>
    <id>http://kingsamchen.github.io/2019/02/10/use-cmake-and-git-as-your-cpp-dependency-manager/</id>
    <published>2019-02-10T06:52:21.000Z</published>
    <updated>2019-02-10T12:49:50.720Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文内容中提及的 CMake 均指提倡 target-based properties 的 &lt;a href=&quot;https://kingsamchen.github.io/2018/06/19/modern-cmake/&quot;&gt;modern cmake&lt;/a&gt;，而非史前版本的 legacy cmake。&lt;/p&gt;
&lt;h3 id=&quot;The-Right-Way-源码依赖&quot;&gt;&lt;a href=&quot;#The-Right-Way-源码依赖&quot; class=&quot;headerlink&quot; title=&quot;The Right Way: 源码依赖&quot;&gt;&lt;/a&gt;The Right Way: 源码依赖&lt;/h3&gt;&lt;p&gt;对于 C++ 工程而言，只要 ABI 的问题还存在，源码依赖就是最稳妥最普适最可靠的依赖引入方式；即使这些引入的源码在构建中会单独编译成（动/静态）库。&lt;/p&gt;
&lt;p&gt;同时，GitHub 成为开源文化社区的标杆后，获取实现了某一功能的第三方库的源代码的难度大大降低。&lt;/p&gt;
&lt;p&gt;因此个人倾向上：只要允许，都应该以特定版本的源码引入的方式去依赖一个第三方库。&lt;/p&gt;
&lt;p&gt;事实上，Google Facebook 这些大厂内部实行的 monorepo 也是源码依赖的一种实现方式，因为某个工程需要的依赖源码都可以一并获取到。&lt;/p&gt;
&lt;p&gt;在使用 CMake 作为构建系统的工程体系下，要以源码依赖的方式添加一个子工程只需要使用 &lt;code&gt;add_subdirectory()&lt;/code&gt; 添加目标工程的顶层目录（根 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 所在的目录）。&lt;/p&gt;
&lt;h3 id=&quot;Git-Submodule-一次不完美的尝试&quot;&gt;&lt;a href=&quot;#Git-Submodule-一次不完美的尝试&quot; class=&quot;headerlink&quot; title=&quot;Git Submodule: 一次不完美的尝试&quot;&gt;&lt;/a&gt;Git Submodule: 一次不完美的尝试&lt;/h3&gt;&lt;p&gt;我的个人项目 KBase 和 ezio，在此之前都是通过 git submodule 的方式引入自己需要的依赖源代码，然后通过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio 子工程添加到解决方案（Windows 平台）&lt;/li&gt;
&lt;li&gt;CMake &lt;code&gt;add_subdirectory()&lt;/code&gt; 建联（*nix 平台）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依赖的版本管理直接复用 submodule 提供的特性。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="c++" scheme="http://kingsamchen.github.io/tags/c/"/>
    
      <category term="git" scheme="http://kingsamchen.github.io/tags/git/"/>
    
      <category term="cmake" scheme="http://kingsamchen.github.io/tags/cmake/"/>
    
      <category term="dependency management" scheme="http://kingsamchen.github.io/tags/dependency-management/"/>
    
  </entry>
  
  <entry>
    <title>Monthly Read Posts in Jan 2019</title>
    <link href="http://kingsamchen.github.io/2019/02/06/monthly-read-posts-in-jan-2019/"/>
    <id>http://kingsamchen.github.io/2019/02/06/monthly-read-posts-in-jan-2019/</id>
    <published>2019-02-06T11:32:23.000Z</published>
    <updated>2019-02-10T06:50:22.886Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Programming-Languages&quot;&gt;&lt;a href=&quot;#Programming-Languages&quot; class=&quot;headerlink&quot; title=&quot;Programming Languages&quot;&gt;&lt;/a&gt;Programming
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="c++" scheme="http://kingsamchen.github.io/tags/c/"/>
    
      <category term="linux" scheme="http://kingsamchen.github.io/tags/linux/"/>
    
      <category term="performance" scheme="http://kingsamchen.github.io/tags/performance/"/>
    
      <category term="allocator" scheme="http://kingsamchen.github.io/tags/allocator/"/>
    
      <category term="spinlock" scheme="http://kingsamchen.github.io/tags/spinlock/"/>
    
      <category term="ptrace" scheme="http://kingsamchen.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>调整 ezio 的 TCPConnection 状态事件</title>
    <link href="http://kingsamchen.github.io/2019/01/27/made-changes-on-tcp-connection-events-for-ezio/"/>
    <id>http://kingsamchen.github.io/2019/01/27/made-changes-on-tcp-connection-events-for-ezio/</id>
    <published>2019-01-27T03:05:48.000Z</published>
    <updated>2019-01-27T06:28:10.584Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;上上周的时候给 ezio 做了一个&lt;a href=&quot;https://github.com/kingsamchen/ezio/commit/d9e7bde28155b5bb2f144dd4c42083d95ef7b674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调整&lt;/a&gt;，稍微修改了一下 &lt;code&gt;TCPConnection&lt;/code&gt; 对外暴露的几个状态变化的事件。&lt;/p&gt;
&lt;p&gt;起因是在写 &lt;a href=&quot;https://github.com/kingsamchen/ezio/blob/9a2ea3ffa43578555e8dfcfe769db10bb45e0087/examples/chat/chat_client.cpp#L62&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;example/chat-client&lt;/a&gt; 的时候，因为主线程单独跑了一个事件循环从 &lt;code&gt;stdin&lt;/code&gt; 中读取用户输入，所以 &lt;code&gt;ChatClient&lt;/code&gt; 以及内部的 &lt;code&gt;TCPClient&lt;/code&gt; 是跑在另外的工作线程上。&lt;/p&gt;
&lt;p&gt;因为那个时候 &lt;code&gt;TCPClient&lt;/code&gt; 之对外暴露了 connection 和 disconnection 的事件回调（这两个事件还统一成了一个 &lt;code&gt;on_connection()&lt;/code&gt;），所以自然选择在 disconnection 的时候进行退出主循环的操作。&lt;/p&gt;
&lt;p&gt;但是这个时候会出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主循环结束后立马析构 &lt;code&gt;ChatClient&lt;/code&gt;，连同内部的 &lt;code&gt;TCPClient&lt;/code&gt; 一起销毁。因为这部分代码跑在主线程上，所以不会和工作线程有任何 coordination。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TCPClient&lt;/code&gt; 会在触发 &lt;code&gt;on_connection()&lt;/code&gt; 来表明连接断开后会继续做一些内部清理工作；然而因为前面已经将 &lt;code&gt;TCPClient&lt;/code&gt; 析构了，导致 UAF&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而当时为了解决这个问题，采用的 workaround 时，&lt;code&gt;ChatClient::OnConnection()&lt;/code&gt; 在发现连接断开后，通过 &lt;code&gt;RunTaskAfter()&lt;/code&gt; 的方式延后执行 &lt;code&gt;EventLoop::Quit()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个做法非常丑陋而且不可靠。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="ezio" scheme="http://kingsamchen.github.io/tags/ezio/"/>
    
      <category term="tcp" scheme="http://kingsamchen.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>来一口 golang 做的玻璃渣</title>
    <link href="http://kingsamchen.github.io/2019/01/08/bad-smells-in-golang/"/>
    <id>http://kingsamchen.github.io/2019/01/08/bad-smells-in-golang/</id>
    <published>2019-01-08T14:35:57.000Z</published>
    <updated>2019-01-27T03:03:43.579Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;转到后端差不多也快三个月了，拿 golang 糊代码的时间算上自己平时写的一些练手 demo 加起来差不多也有一个月。&lt;/p&gt;
&lt;p&gt;这将近一个月的时间过来差不多能体会到 golang 的设计精髓，那就是：&lt;em&gt;simple &amp;amp; stupid, being convenient as the first class support&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;换句话说就是：短平快糙猛，满口玻璃渣，怎么方便怎么来。&lt;/p&gt;
&lt;p&gt;所以接下来不免俗地是吐槽 golang 设计的内容。&lt;/p&gt;
&lt;p&gt;吐槽不考虑 PLT 上的设计，纯粹从日常堆业务逻辑出发。毕竟理论的东西我一个鶸也不懂，且 golang 的设计目的就是方便应届毕业生快速堆业务代码。&lt;/p&gt;
&lt;p&gt;以下吐槽点的顺序为自己在实际中遇到的顺序逆序。&lt;/p&gt;
&lt;h3 id=&quot;Flaky-Goroutines&quot;&gt;&lt;a href=&quot;#Flaky-Goroutines&quot; class=&quot;headerlink&quot; title=&quot;Flaky Goroutines&quot;&gt;&lt;/a&gt;Flaky Goroutines&lt;/h3&gt;&lt;p&gt;golang 里起一个 goroutine 很方便，但是目前感觉 goroutine 太过于 flaky，有点飘。一旦没用 &lt;code&gt;chan struct{}&lt;/code&gt; 或者 &lt;code&gt;sync.WaitGroup&lt;/code&gt; ”固定好“，就总有一种这玩意儿是不是已经脱离自己手心的感觉。&lt;/p&gt;
&lt;p&gt;另外不知道是不是很多用 golang 的人之前都是 php / python 的背景，相当一部分人其实对 goroutine-safe 没有什么概念。不过严格来说这个不是 golang 自身的问题。&lt;/p&gt;
&lt;h3 id=&quot;Cannot-assign-to-fields-within-short-declaration-notation&quot;&gt;&lt;a href=&quot;#Cannot-assign-to-fields-within-short-declaration-notation&quot; class=&quot;headerlink&quot; title=&quot;Cannot assign to fields within short declaration notation&quot;&gt;&lt;/a&gt;Cannot assign to fields within short declaration notation&lt;/h3&gt;&lt;p&gt;代码段&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foobar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; err error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ok, err := foobar()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;error&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Println(ok)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;是合法的，因为 &lt;code&gt;ok&lt;/code&gt; 之前并没有被定义，所以这里 &lt;code&gt;err&lt;/code&gt; 可以蹭着使用 &lt;code&gt;:=&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CODE-LIFE" scheme="http://kingsamchen.github.io/categories/CODE-LIFE/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="rant" scheme="http://kingsamchen.github.io/tags/rant/"/>
    
  </entry>
  
  <entry>
    <title>Monthly Read Posts in Dec 2018</title>
    <link href="http://kingsamchen.github.io/2019/01/01/monthly-read-posts-in-dec-2018/"/>
    <id>http://kingsamchen.github.io/2019/01/01/monthly-read-posts-in-dec-2018/</id>
    <published>2019-01-01T07:36:47.000Z</published>
    <updated>2019-01-01T08:05:24.007Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Programming-Languages&quot;&gt;&lt;a href=&quot;#Programming-Languages&quot; class=&quot;headerlink&quot; title=&quot;Programming Languages&quot;&gt;&lt;/a&gt;Programming Languages&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/golangspec/init-functions-in-go-eac191b3860a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;init functions in Go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇 post 总结起来就是深入浅出。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://www.fluentcpp.com/2017/01/05/the-importance-of-knowing-stl-algorithms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The importance of knowing STL algorithms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;能熟练运用 STL algorithms 是一个 experienced c++ programmer 的基本要求。&lt;/p&gt;
&lt;p&gt;另外里面提到了使用 algorithms 的两个 pitfalls，其中一个是滥用 &lt;code&gt;for_each()&lt;/code&gt;，这个确实有点意思。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="algorithms" scheme="http://kingsamchen.github.io/tags/algorithms/"/>
    
      <category term="redis" scheme="http://kingsamchen.github.io/tags/redis/"/>
    
      <category term="code quality" scheme="http://kingsamchen.github.io/tags/code-quality/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机 Linux Mint 磁盘扩容</title>
    <link href="http://kingsamchen.github.io/2018/12/16/expand-linux-vm-disk-size/"/>
    <id>http://kingsamchen.github.io/2018/12/16/expand-linux-vm-disk-size/</id>
    <published>2018-12-16T09:39:19.000Z</published>
    <updated>2018-12-16T10:04:31.894Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前在虚拟机里创建 mint 时磁盘就给了 20G 的 SSD，最近发现可用容量捉襟见肘，必须要扩容一波。&lt;/p&gt;
&lt;p&gt;摸索了一下发现给虚拟机里的 linux 磁盘扩容并不是那么简单直白，至少有几个坑，所以稍微做了一些记录，以备日后不时之需。&lt;/p&gt;
&lt;h3
        
      
    
    </summary>
    
      <category term="CODE-LIFE" scheme="http://kingsamchen.github.io/categories/CODE-LIFE/"/>
    
    
      <category term="linux" scheme="http://kingsamchen.github.io/tags/linux/"/>
    
      <category term="mint" scheme="http://kingsamchen.github.io/tags/mint/"/>
    
      <category term="磁盘" scheme="http://kingsamchen.github.io/tags/%E7%A3%81%E7%9B%98/"/>
    
      <category term="扩容" scheme="http://kingsamchen.github.io/tags/%E6%89%A9%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>放弃给 ezio 加 SIGINT Handler</title>
    <link href="http://kingsamchen.github.io/2018/12/09/give-up-adding-sigint-handler-for-ezio/"/>
    <id>http://kingsamchen.github.io/2018/12/09/give-up-adding-sigint-handler-for-ezio/</id>
    <published>2018-12-08T16:18:14.000Z</published>
    <updated>2018-12-08T16:34:40.264Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;原本的计划是今天给 &lt;a href=&quot;https://github.com/kingsamchen/ezio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ezio&lt;/a&gt; 加上 SIGINT 的处理：自动退出运行的
        
      
    
    </summary>
    
      <category term="CODE-LIFE" scheme="http://kingsamchen.github.io/categories/CODE-LIFE/"/>
    
    
      <category term="Windows" scheme="http://kingsamchen.github.io/tags/Windows/"/>
    
      <category term="ezio" scheme="http://kingsamchen.github.io/tags/ezio/"/>
    
      <category term="sigint" scheme="http://kingsamchen.github.io/tags/sigint/"/>
    
      <category term="signal" scheme="http://kingsamchen.github.io/tags/signal/"/>
    
      <category term="Linux" scheme="http://kingsamchen.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own HandlerThread Part Finale</title>
    <link href="http://kingsamchen.github.io/2018/12/07/build-your-own-handlerthread-part-finale/"/>
    <id>http://kingsamchen.github.io/2018/12/07/build-your-own-handlerthread-part-finale/</id>
    <published>2018-12-06T17:00:48.000Z</published>
    <updated>2018-12-08T14:02:42.471Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;至此，我们整个系列宣告完结。&lt;/p&gt;
&lt;p&gt;现在回过头往前看，是不是觉得其实这些底层的东西也没这么难？有时候只是需要一些基础和解决问题的方法罢了。&lt;/p&gt;
&lt;p&gt;Rant：做业务才真的难呢，框架和流程都给你定死了，一坨又一坨用了几年的不明觉厉的封装，如果内部文档哪个不详，又
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="Android" scheme="http://kingsamchen.github.io/tags/Android/"/>
    
      <category term="HandlerThread" scheme="http://kingsamchen.github.io/tags/HandlerThread/"/>
    
      <category term="Looper" scheme="http://kingsamchen.github.io/tags/Looper/"/>
    
      <category term="Handler" scheme="http://kingsamchen.github.io/tags/Handler/"/>
    
      <category term="MessageLoop" scheme="http://kingsamchen.github.io/tags/MessageLoop/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own HandlerThread Part 4</title>
    <link href="http://kingsamchen.github.io/2018/12/07/build-your-own-handlerthread-part-4/"/>
    <id>http://kingsamchen.github.io/2018/12/07/build-your-own-handlerthread-part-4/</id>
    <published>2018-12-06T16:50:37.000Z</published>
    <updated>2018-12-08T14:02:42.470Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;有了前面的铺垫我们终于可以开始实现我们的主角 ActiveThread 了，虽然它登场的有点晚。&lt;/p&gt;
&lt;p&gt;这个系列的开头我们提到 &lt;code&gt;ActiveThread&lt;/code&gt; 有两个鲜明的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它是线程，可以运行，代表一个单独的执行上下文（execution unit/context）&lt;/li&gt;
&lt;li&gt;每个 &lt;code&gt;ActiveThread&lt;/code&gt; 内部运行一个 message-loop，方便持续的执行我们提交的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两点和 Android 原生提供的 &lt;code&gt;HandlerThread&lt;/code&gt; 是一模一样的。&lt;/p&gt;
&lt;p&gt;不过和 &lt;code&gt;HandlerThread&lt;/code&gt; 不同，我们这里不打算采用继承 &lt;code&gt;Thread&lt;/code&gt; 的方式，而是采用 composition。原因之一是我个人非常反感传统的 OO 继承手法；并且 Java 8 开始正式支持 lambda 之后，不用继承我们的工作也可以做得很好。&lt;/p&gt;
&lt;p&gt;不适用继承同时有个好处，我们可以只暴露我们需要的接口，避免误用（比如经典的用 &lt;code&gt;run()&lt;/code&gt; 而不是 &lt;code&gt;start()&lt;/code&gt;）&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="Android" scheme="http://kingsamchen.github.io/tags/Android/"/>
    
      <category term="HandlerThread" scheme="http://kingsamchen.github.io/tags/HandlerThread/"/>
    
      <category term="Looper" scheme="http://kingsamchen.github.io/tags/Looper/"/>
    
      <category term="Handler" scheme="http://kingsamchen.github.io/tags/Handler/"/>
    
      <category term="MessageLoop" scheme="http://kingsamchen.github.io/tags/MessageLoop/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own HandlerThread Part 3</title>
    <link href="http://kingsamchen.github.io/2018/12/06/build-your-own-handlerthread-part-3/"/>
    <id>http://kingsamchen.github.io/2018/12/06/build-your-own-handlerthread-part-3/</id>
    <published>2018-12-06T14:34:48.000Z</published>
    <updated>2018-12-08T14:02:42.470Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;前面我们实现了 &lt;code&gt;MessageLoop&lt;/code&gt;，现在该轮到 &lt;code&gt;TaskRunner&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;在我们的设计中，&lt;code&gt;TaskRunner&lt;/code&gt; 的定位是类似
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="Android" scheme="http://kingsamchen.github.io/tags/Android/"/>
    
      <category term="HandlerThread" scheme="http://kingsamchen.github.io/tags/HandlerThread/"/>
    
      <category term="Looper" scheme="http://kingsamchen.github.io/tags/Looper/"/>
    
      <category term="Handler" scheme="http://kingsamchen.github.io/tags/Handler/"/>
    
      <category term="MessageLoop" scheme="http://kingsamchen.github.io/tags/MessageLoop/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own HandlerThread Part 2</title>
    <link href="http://kingsamchen.github.io/2018/12/05/build-your-own-handlerthread-part-2/"/>
    <id>http://kingsamchen.github.io/2018/12/05/build-your-own-handlerthread-part-2/</id>
    <published>2018-12-05T15:49:29.000Z</published>
    <updated>2018-12-08T14:02:42.470Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;有了 &lt;code&gt;MessagePumpDefault&lt;/code&gt;  之后，我们就可以开始着手实现最核心的 &lt;code&gt;MessageLoop&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;不过在此之前，我们还首先需要实现一个辅助设施：&lt;code&gt;PendingTask&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;PendingTask&quot;&gt;&lt;a href=&quot;#PendingTask&quot; class=&quot;headerlink&quot; title=&quot;PendingTask&quot;&gt;&lt;/a&gt;PendingTask&lt;/h3&gt;&lt;p&gt;一个 &lt;code&gt;PendingTask&lt;/code&gt; instance 表示一个等待被执行的 task，并且这个 task 可能是一个 delayed task。&lt;/p&gt;
&lt;p&gt;因此 &lt;code&gt;PendingTask&lt;/code&gt; 需要能够表示时序上的顺序，这个可以利用 &lt;code&gt;Instant&lt;/code&gt; 类型的一个时间戳，结合一个 &lt;code&gt;long&lt;/code&gt; 类型的 sequence-number。因为有可能两个 delayed tasks 的时间戳相同，此时就必须要用 seq-num  来区分先后顺序。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;PendingTask&lt;/code&gt; 为了能够表示 task 语义，他必须可以被执行。这可以通过内部存储一个 &lt;code&gt;Runnable&lt;/code&gt; 或者 &lt;code&gt;Callable&lt;/code&gt; 成员做到。&lt;/p&gt;
&lt;p&gt;我们的实现选择 &lt;code&gt;Runnable&lt;/code&gt;，因为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们当前的实现不考虑返回值，因为实现返回值和我们的主题没有直接关系。&lt;br&gt;CSP 的并发模型上如果要考虑使用某个任务的返回值，一般会使用类似于 &lt;code&gt;PostTaskAndReplyWithResult()&lt;/code&gt; 来组合两个函数；或者更一般的，使用 continuation 来 lifting restrictions&lt;/li&gt;
&lt;li&gt;懒得处理异常&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PendingTask&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; AtomicLong s_seqNumGenerator = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AtomicLong(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; _seqNum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Instant _endTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Runnable _task;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PendingTask(Runnable task, Instant endTime) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _seqNum = s_seqNumGenerator.getAndIncrement();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _endTime = endTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _task = task;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _task.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Instant &lt;span class=&quot;title&quot;&gt;endTime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _endTime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;seqNum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _seqNum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们使用了 &lt;code&gt;AtomicLong&lt;/code&gt; 来存储当前的 sequence-number，因为我们不知道某个 &lt;code&gt;PendingTask&lt;/code&gt; 会在哪个线程上被创建。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="Android" scheme="http://kingsamchen.github.io/tags/Android/"/>
    
      <category term="HandlerThread" scheme="http://kingsamchen.github.io/tags/HandlerThread/"/>
    
      <category term="Looper" scheme="http://kingsamchen.github.io/tags/Looper/"/>
    
      <category term="Handler" scheme="http://kingsamchen.github.io/tags/Handler/"/>
    
      <category term="MessageLoop" scheme="http://kingsamchen.github.io/tags/MessageLoop/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own HandlerThread Part 1</title>
    <link href="http://kingsamchen.github.io/2018/12/04/build-your-own-handlerthread-part-1/"/>
    <id>http://kingsamchen.github.io/2018/12/04/build-your-own-handlerthread-part-1/</id>
    <published>2018-12-04T01:51:41.000Z</published>
    <updated>2018-12-08T14:02:42.469Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MessagePump&quot;&gt;&lt;a href=&quot;#MessagePump&quot; class=&quot;headerlink&quot; title=&quot;MessagePump&quot;&gt;&lt;/a&gt;MessagePump&lt;/h3&gt;&lt;p&gt;对于我们的 ActiveThread 来说，核心仍然是持续不断运行的 message-loop；但是在实现 message-loop 前，我们需要首先来实现它的“引擎”：&lt;code&gt;MessagePump&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大体上，message-loop 要维持运转，就要能够源源不断地从某个地方获取消息/事件，而获取消息/事件的这个行为，就是由 message-pump 来完成，正如他的名字一样。&lt;/p&gt;
&lt;p&gt;这里可能会产生一个疑问，为什么要单独抽出一个 message-pump，而不是直接把这部分实现做到 message-loop 里呢？&lt;/p&gt;
&lt;p&gt;原因是：一个复杂的系统可能会有多个消息/事件来源，每个来源会有专门的获取、分发的方式。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;界面消息可能是从系统的 GUI 消息系统中获得。一个典型的例子是 Win32 GUI 程序所使用的 &lt;code&gt;GetMessage()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;网络活动事件通常从 native 系统提供的 I/O multiplexor 中获得。例子包括 POSIX 标准的 &lt;code&gt;select(2)&lt;/code&gt;, &lt;code&gt;poll(2)&lt;/code&gt;；Linux 独有的 &lt;code&gt;epoll&lt;/code&gt;；以及 Windows 提供的真-异步I/O机制 IO Completion Port。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：GUI 系统中多使用 messages（消息）作为术语；而网络 I/O 等倾向于使用 events（事件）作为使用术语。因为此系列文章不涉及网络 I/O，因此以后均采用&lt;em&gt;消息&lt;/em&gt;作为我们的使用术语。&lt;/p&gt;
&lt;p&gt;注1：对于 Android 系统，他的 GUI 事件实质上是通过 &lt;code&gt;epoll&lt;/code&gt; 监听关联到 device 抽象的 pipe fd 来完成的；Linux 的各类 X-Window 实现大多也是类似做法。&lt;/p&gt;
&lt;p&gt;所以为了解耦具体的消息来源，同时让我们的实现看上去更加有逼格，我们采取分离实现 message-pump 和 message-loop。&lt;/p&gt;
&lt;p&gt;前面说到可能有多种 pump，所以这里我们的 &lt;code&gt;MessagePump&lt;/code&gt; 应该是一个 interface，规定了一个 message-pump 应该具有哪些基本的行为：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.time.Instant;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MessagePump&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Delegate&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doDelayedWork&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;Instant &lt;span class=&quot;title&quot;&gt;nextDelayedWorkExpiration&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Delegate delegate)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Quit the pump.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This method can only be called on the thread that called run().&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Thread-safe&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时我们定义了一个 &lt;code&gt;Delegate&lt;/code&gt; interface，message-loop 需要实现这个 interface，以便让 message-pump 可以通过这个 interface 来按照自己的实现来操作 message-loop。&lt;/p&gt;
&lt;h3 id=&quot;什么都不做的-MessagePumpDefault&quot;&gt;&lt;a href=&quot;#什么都不做的-MessagePumpDefault&quot; class=&quot;headerlink&quot; title=&quot;什么都不做的 MessagePumpDefault&quot;&gt;&lt;/a&gt;什么都不做的 MessagePumpDefault&lt;/h3&gt;&lt;p&gt;我们的 ActiveThread 运行的纯 Java 环境，不需要像 Android 那样能够获取设备输入消息（Frankly，你想做还做不了呢，我哪来的设备信息获取啊），有点类似 worker HandlerThread.&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="Android" scheme="http://kingsamchen.github.io/tags/Android/"/>
    
      <category term="HandlerThread" scheme="http://kingsamchen.github.io/tags/HandlerThread/"/>
    
      <category term="Looper" scheme="http://kingsamchen.github.io/tags/Looper/"/>
    
      <category term="Handler" scheme="http://kingsamchen.github.io/tags/Handler/"/>
    
      <category term="MessageLoop" scheme="http://kingsamchen.github.io/tags/MessageLoop/"/>
    
  </entry>
  
  <entry>
    <title>Build Your Own HandlerThread Part 0</title>
    <link href="http://kingsamchen.github.io/2018/12/03/build-your-own-handlerthread-part-0/"/>
    <id>http://kingsamchen.github.io/2018/12/03/build-your-own-handlerthread-part-0/</id>
    <published>2018-12-03T15:50:08.000Z</published>
    <updated>2018-12-08T14:02:42.468Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;立一个-Flag&quot;&gt;&lt;a href=&quot;#立一个-Flag&quot; class=&quot;headerlink&quot; title=&quot;立一个 Flag&quot;&gt;&lt;/a&gt;立一个 Flag&lt;/h3&gt;&lt;p&gt;&lt;code&gt;HandlerThread&lt;/code&gt; 是 Android runtime
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="Android" scheme="http://kingsamchen.github.io/tags/Android/"/>
    
      <category term="HandlerThread" scheme="http://kingsamchen.github.io/tags/HandlerThread/"/>
    
      <category term="Looper" scheme="http://kingsamchen.github.io/tags/Looper/"/>
    
      <category term="Handler" scheme="http://kingsamchen.github.io/tags/Handler/"/>
    
      <category term="MessageLoop" scheme="http://kingsamchen.github.io/tags/MessageLoop/"/>
    
  </entry>
  
  <entry>
    <title>Monthly Read Posts in Nov 2018</title>
    <link href="http://kingsamchen.github.io/2018/12/01/monthly-read-posts-in-nov-2018/"/>
    <id>http://kingsamchen.github.io/2018/12/01/monthly-read-posts-in-nov-2018/</id>
    <published>2018-12-01T07:55:31.000Z</published>
    <updated>2018-12-01T07:57:20.976Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Algorithms&quot;&gt;&lt;a href=&quot;#Algorithms&quot; class=&quot;headerlink&quot; title=&quot;Algorithms&quot;&gt;&lt;/a&gt;Algorithms&lt;/h2&gt;&lt;p&gt;&lt;a
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="shuffling" scheme="http://kingsamchen.github.io/tags/shuffling/"/>
    
      <category term="concurrent programming" scheme="http://kingsamchen.github.io/tags/concurrent-programming/"/>
    
      <category term="noexcept" scheme="http://kingsamchen.github.io/tags/noexcept/"/>
    
      <category term="cache server" scheme="http://kingsamchen.github.io/tags/cache-server/"/>
    
      <category term="api design" scheme="http://kingsamchen.github.io/tags/api-design/"/>
    
      <category term="pthread" scheme="http://kingsamchen.github.io/tags/pthread/"/>
    
      <category term="philosophy" scheme="http://kingsamchen.github.io/tags/philosophy/"/>
    
  </entry>
  
  <entry>
    <title>Chromium Base MessageLoop Internals (1)</title>
    <link href="http://kingsamchen.github.io/2018/11/25/chromium-base-message-loop-internals-1/"/>
    <id>http://kingsamchen.github.io/2018/11/25/chromium-base-message-loop-internals-1/</id>
    <published>2018-11-25T14:47:07.000Z</published>
    <updated>2018-11-25T14:50:56.087Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;class-MessageLoop&quot;&gt;&lt;a href=&quot;#class-MessageLoop&quot; class=&quot;headerlink&quot; title=&quot;class MessageLoop&quot;&gt;&lt;/a&gt;class MessageLoop&lt;/h2&gt;&lt;p&gt;Version: r70_3538&lt;br&gt;File: &lt;code&gt;base/message_loop/message_loop.{h, cc}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;MessageLoop&lt;/code&gt; is used to process events for a particular thread, i.e. the core infrastructure for implementing Communicating Sequential Process (CSP) model.&lt;/p&gt;
&lt;p&gt;There is at most one MessageLoop instance on a thread.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MessageLoop&lt;/code&gt; is a farily complex class, it driveds from multiple base classes:&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BASE_EXPORT&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MessageLoop&lt;/span&gt; :&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; MessagePump::Delegate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; RunLoop::Delegate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; MessageLoopCurrent &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// omitted...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;MessageLoop-Type&quot;&gt;&lt;a href=&quot;#MessageLoop-Type&quot; class=&quot;headerlink&quot; title=&quot;MessageLoop Type&quot;&gt;&lt;/a&gt;MessageLoop Type&lt;/h3&gt;&lt;p&gt;A MessageLoop has a particular type, differred by the set of asynchronous events it is capable of handling.&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="chromium" scheme="http://kingsamchen.github.io/tags/chromium/"/>
    
      <category term="source internals" scheme="http://kingsamchen.github.io/tags/source-internals/"/>
    
      <category term="message-loop" scheme="http://kingsamchen.github.io/tags/message-loop/"/>
    
  </entry>
  
  <entry>
    <title>在 cmder 里以 mintty 为终端的方式运行 bash 和 wsl</title>
    <link href="http://kingsamchen.github.io/2018/11/24/running-bash-and-wsl-under-mintty-in-cmder/"/>
    <id>http://kingsamchen.github.io/2018/11/24/running-bash-and-wsl-under-mintty-in-cmder/</id>
    <published>2018-11-24T15:26:04.000Z</published>
    <updated>2018-11-24T15:36:58.841Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在 cmder 里如果不指定运行的 terminal 则会默认使用 windows cmd，而这在使用 git-bash 或者 wsl 时会经常遇到问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;性能底下导致交互出现显著延迟（这个发生在使用 tig 等重型 bash 命令或者使用
        
      
    
    </summary>
    
      <category term="CODE-LIFE" scheme="http://kingsamchen.github.io/categories/CODE-LIFE/"/>
    
    
      <category term="wsl" scheme="http://kingsamchen.github.io/tags/wsl/"/>
    
      <category term="cmder" scheme="http://kingsamchen.github.io/tags/cmder/"/>
    
      <category term="mintty" scheme="http://kingsamchen.github.io/tags/mintty/"/>
    
      <category term="bash" scheme="http://kingsamchen.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>MSVC 对多继承下的 EBO 支持的一个 workaround</title>
    <link href="http://kingsamchen.github.io/2018/11/11/ebo-with-multiple-inheritance-in-msvc/"/>
    <id>http://kingsamchen.github.io/2018/11/11/ebo-with-multiple-inheritance-in-msvc/</id>
    <published>2018-11-11T02:44:37.000Z</published>
    <updated>2018-11-11T03:24:28.971Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;首先简单介绍一下 EBO（Empty Base Class Optimization）。&lt;/p&gt;
&lt;p&gt;因为 C++ 规定，任何一个 instance 在内存中必须要有唯一的地址，因此一个空的 class/struct 会在编译时被偷偷插入一个外人看不到的 &lt;code&gt;char mem;&lt;/code&gt;，于是这个空类的每一个 instance 都可以有一个唯一的地址了。&lt;/p&gt;
&lt;p&gt;但是如果将这个空类作为某个类的成员时，这个隐藏的成员会被计入内存布局之中，考虑到 memory padding，有时候会导致类对象体积膨涨一倍。&lt;/p&gt;
&lt;p&gt;例如考虑：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;E&lt;/span&gt; &amp;#123;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A1&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    E e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;assert(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(E) == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;assert(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(A1) == &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们会发现每一个 &lt;code&gt;A1&lt;/code&gt; 的 instance 都占了 8-byte，比起 4-byte 足足翻了一倍。&lt;/p&gt;
&lt;p&gt;占用内存无端变大导致 cache 问题啥的就不讲了，这方面的内容任何讲 computer architecture 的书应该都会有。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="c++" scheme="http://kingsamchen.github.io/tags/c/"/>
    
      <category term="msvc" scheme="http://kingsamchen.github.io/tags/msvc/"/>
    
      <category term="ebo" scheme="http://kingsamchen.github.io/tags/ebo/"/>
    
      <category term="multiple inheritance" scheme="http://kingsamchen.github.io/tags/multiple-inheritance/"/>
    
  </entry>
  
  <entry>
    <title>Chromium Base MessageLoop Internals (0)</title>
    <link href="http://kingsamchen.github.io/2018/11/04/chromium-base-message-loop-internals-0/"/>
    <id>http://kingsamchen.github.io/2018/11/04/chromium-base-message-loop-internals-0/</id>
    <published>2018-11-04T02:04:38.000Z</published>
    <updated>2018-11-04T02:09:41.590Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Our fancy star in this post is class &lt;code&gt;base::MessageLoopCurrent&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;MessageLoopCurrent&quot;&gt;&lt;a href=&quot;#MessageLoopCurrent&quot; class=&quot;headerlink&quot; title=&quot;MessageLoopCurrent&quot;&gt;&lt;/a&gt;MessageLoopCurrent&lt;/h2&gt;&lt;p&gt;Version: r70_3538&lt;br&gt;File: &lt;code&gt;base/message_loop/message_loop_current.{h, cc}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;MessageLoopCurernt is a proxy class for interactions with the MessageLoop bound to the current thread.&lt;/p&gt;
&lt;p&gt;It is introduced to avoid direct uses of &lt;code&gt;MessageLoop::current()&lt;/code&gt;, quoting from original comments:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Why: Historically MessageLoop::current() gave access to the full MessageLoop API, preventing both addition of powerful owner-only APIs as well as making it harder to remove callers of deprecated APIs (that need to stick around for a few owner-only use cases and re-accrue callers after cleanup per remaining publicly available).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because it is a light-weight proxy, it contains only a single pointer to the MessageLoop bound to the current thread.&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="chromium" scheme="http://kingsamchen.github.io/tags/chromium/"/>
    
      <category term="source internals" scheme="http://kingsamchen.github.io/tags/source-internals/"/>
    
      <category term="message-loop" scheme="http://kingsamchen.github.io/tags/message-loop/"/>
    
  </entry>
  
  <entry>
    <title>Monthly Read Posts in Oct 2018</title>
    <link href="http://kingsamchen.github.io/2018/11/04/monthly-read-posts-in-oct-2018/"/>
    <id>http://kingsamchen.github.io/2018/11/04/monthly-read-posts-in-oct-2018/</id>
    <published>2018-11-04T01:38:36.000Z</published>
    <updated>2018-11-04T01:39:08.316Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Concurrency&quot;&gt;&lt;a href=&quot;#Concurrency&quot; class=&quot;headerlink&quot; title=&quot;Concurrency&quot;&gt;&lt;/a&gt;Concurrency&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://nullprogram.com/blog/2014/09/02/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C11 Lock-free Stack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用C 11 atomic operations 实现一个轻量的 lock-free stack&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pre-allocation，不需要考虑单个节点的销毁问题，所以不需要使用 hazard pointer&lt;/li&gt;
&lt;li&gt;free 和 head 两个列表，两个单独的 head 均可用做 sentinel&lt;/li&gt;
&lt;li&gt;使用 aba counter 来避免 ABA problem&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://www.souyunku.com/2018/07/30/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL/InnoDB中，乐观锁、悲观锁、共享锁、排它锁、行锁、表锁、死锁概念的理解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉这篇讲的好混乱，几个概念是明显正交的都混在一起了。&lt;/p&gt;
&lt;p&gt;瞄了一眼，基本脑子里都在找平常 locking mechanism 里的概念做映射了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@copyconstruct/the-method-to-epolls-madness-d9d2d6378642&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The method to epoll’s madness&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总体写的一般，而且内容有点乱。&lt;/p&gt;
&lt;p&gt;madness 应该指的就是 epoll 对外表现的是引用 file descriptor 但是内部维护的确实 file descrption。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="c++" scheme="http://kingsamchen.github.io/tags/c/"/>
    
      <category term="tcp" scheme="http://kingsamchen.github.io/tags/tcp/"/>
    
      <category term="goroutine" scheme="http://kingsamchen.github.io/tags/goroutine/"/>
    
      <category term="epoll" scheme="http://kingsamchen.github.io/tags/epoll/"/>
    
      <category term="network" scheme="http://kingsamchen.github.io/tags/network/"/>
    
      <category term="RFC" scheme="http://kingsamchen.github.io/tags/RFC/"/>
    
  </entry>
  
  <entry>
    <title>Non-blocking Connect(2) and Error Handling</title>
    <link href="http://kingsamchen.github.io/2018/10/27/non-blocking-connect-2-and-error-handling/"/>
    <id>http://kingsamchen.github.io/2018/10/27/non-blocking-connect-2-and-error-handling/</id>
    <published>2018-10-27T14:56:18.000Z</published>
    <updated>2018-10-27T15:32:01.762Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这是我在实现 &lt;a href=&quot;https://github.com/kingsamchen/ezio/blob/master/ezio/connector_posix.cpp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ezio
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="linux" scheme="http://kingsamchen.github.io/tags/linux/"/>
    
      <category term="epoll" scheme="http://kingsamchen.github.io/tags/epoll/"/>
    
      <category term="non-blocking" scheme="http://kingsamchen.github.io/tags/non-blocking/"/>
    
      <category term="connect" scheme="http://kingsamchen.github.io/tags/connect/"/>
    
  </entry>
  
</feed>
