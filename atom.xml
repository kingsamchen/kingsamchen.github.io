<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KC的废墟堆</title>
  
  <subtitle>Will you serve in Heaven, or rule in Hell</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kingsamchen.github.io/"/>
  <updated>2020-08-16T08:39:01.043Z</updated>
  <id>http://kingsamchen.github.io/</id>
  
  <author>
    <name>Kingsley Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再谈 passkey idiom</title>
    <link href="http://kingsamchen.github.io/2020/08/16/passkey-idiom-part-2/"/>
    <id>http://kingsamchen.github.io/2020/08/16/passkey-idiom-part-2/</id>
    <published>2020-08-16T08:18:35.000Z</published>
    <updated>2020-08-16T08:39:01.043Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;我在 &lt;a href=&quot;/2020/07/02/passkey-idiom-for-make-functions/&quot; title=&quot;Passkey Idiom&quot;&gt;Passkey Idiom&lt;/a&gt; 这篇文章中介绍了如何使用 passkey idiom
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="passkey" scheme="http://kingsamchen.github.io/tags/passkey/"/>
    
      <category term="explicit" scheme="http://kingsamchen.github.io/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>The std::byte For Byte Addressing</title>
    <link href="http://kingsamchen.github.io/2020/07/14/the-std-byte/"/>
    <id>http://kingsamchen.github.io/2020/07/14/the-std-byte/</id>
    <published>2020-07-13T16:55:59.000Z</published>
    <updated>2020-08-16T08:16:19.270Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;时隔多年，C++ 17 终于迎来了专门用于 byte-oriented access 的数据类型 &lt;code&gt;std::byte&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;之所以引入一个新的类型是因为之前不管是 &lt;code&gt;char&lt;/code&gt; 还是 &lt;code&gt;unsigned
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Passkey Idiom</title>
    <link href="http://kingsamchen.github.io/2020/07/02/passkey-idiom-for-make-functions/"/>
    <id>http://kingsamchen.github.io/2020/07/02/passkey-idiom-for-make-functions/</id>
    <published>2020-07-01T16:28:19.000Z</published>
    <updated>2020-07-04T08:55:14.196Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;如果出于某些目的希望将某个类的构造函数设置为 private，并提供工厂函数 &lt;code&gt;Make()&lt;/code&gt; 创建最终对象；工厂函数中通常会使用 &lt;code&gt;std::make_unique()&lt;/code&gt; 或者
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="make_unique" scheme="http://kingsamchen.github.io/tags/make-unique/"/>
    
      <category term="make_shared" scheme="http://kingsamchen.github.io/tags/make-shared/"/>
    
      <category term="passkey" scheme="http://kingsamchen.github.io/tags/passkey/"/>
    
  </entry>
  
  <entry>
    <title>Golang&#39;s Options Pattern</title>
    <link href="http://kingsamchen.github.io/2020/06/30/golang-options-pattern/"/>
    <id>http://kingsamchen.github.io/2020/06/30/golang-options-pattern/</id>
    <published>2020-06-30T01:29:23.000Z</published>
    <updated>2020-07-04T08:55:14.196Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;可以将 Golang 的 &lt;em&gt;Options Pattern&lt;/em&gt; 视作（有副作用）函数式版的 &lt;em&gt;Builder Pattern&lt;/em&gt;，其核心是：特定的 option-function 调用会生成对应的类型为 Option 的闭包，执行闭包会修改内部的
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="options" scheme="http://kingsamchen.github.io/tags/options/"/>
    
      <category term="design patterns" scheme="http://kingsamchen.github.io/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>保持 ASIO io_context 无任务时运行</title>
    <link href="http://kingsamchen.github.io/2020/06/28/keep-asio-io-context-running/"/>
    <id>http://kingsamchen.github.io/2020/06/28/keep-asio-io-context-running/</id>
    <published>2020-06-28T15:03:22.000Z</published>
    <updated>2020-06-28T15:17:24.037Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;ASIO 的 &lt;code&gt;io_context::run()&lt;/code&gt; 如果发现没有 pending 的任务就会返回，对于 server 的监听线程来说这是符合常理的，因为无论如何至少有个 &lt;code&gt;acceptor::async_accept()&lt;/code&gt; 在
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="asio" scheme="http://kingsamchen.github.io/tags/asio/"/>
    
      <category term="io_context" scheme="http://kingsamchen.github.io/tags/io-context/"/>
    
      <category term="work_guard" scheme="http://kingsamchen.github.io/tags/work-guard/"/>
    
  </entry>
  
  <entry>
    <title>atoi With Overflow Handled</title>
    <link href="http://kingsamchen.github.io/2020/05/04/atoi-with-overflow-handled/"/>
    <id>http://kingsamchen.github.io/2020/05/04/atoi-with-overflow-handled/</id>
    <published>2020-05-04T07:03:26.000Z</published>
    <updated>2020-05-04T07:53:16.256Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;leetcode 上有一题是让你实现一个 &lt;code&gt;atoi()&lt;/code&gt;，但是因为函数类型是 32-bit int，所以可以直接内部转换到 64-bit int，避免需要直接处理溢出的情况。&lt;/p&gt;
&lt;p&gt;如果要针对 &lt;code&gt;int64&lt;/code&gt; 实现一个
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="atoi" scheme="http://kingsamchen.github.io/tags/atoi/"/>
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Allow Connections From LAN for Trojan-qt5</title>
    <link href="http://kingsamchen.github.io/2020/04/19/allow-connections-from-lan-for-trojan-qt5/"/>
    <id>http://kingsamchen.github.io/2020/04/19/allow-connections-from-lan-for-trojan-qt5/</id>
    <published>2020-04-19T04:33:18.000Z</published>
    <updated>2020-04-19T05:02:37.488Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;因为众所周知的原因，机场的服务商把协议从 SS 切换到了 Trojan。但是之前的 SS windows 客户端只支持 SS 协议，所以切换后只能换 Trojan-qt5 作为客户端。&lt;/p&gt;
&lt;p&gt;但是这个客户端做的实在不怎么样，作者似乎是在原来的 ss-qt5
        
      
    
    </summary>
    
      <category term="CODE-LIFE" scheme="http://kingsamchen.github.io/categories/CODE-LIFE/"/>
    
    
      <category term="梯子" scheme="http://kingsamchen.github.io/tags/%E6%A2%AF%E5%AD%90/"/>
    
      <category term="shadowsocks" scheme="http://kingsamchen.github.io/tags/shadowsocks/"/>
    
      <category term="trojan" scheme="http://kingsamchen.github.io/tags/trojan/"/>
    
      <category term="socat" scheme="http://kingsamchen.github.io/tags/socat/"/>
    
  </entry>
  
  <entry>
    <title>Randomly Generate Base62 for URL Shortening</title>
    <link href="http://kingsamchen.github.io/2020/04/11/randomly-generate-base62-for-url-shortening/"/>
    <id>http://kingsamchen.github.io/2020/04/11/randomly-generate-base62-for-url-shortening/</id>
    <published>2020-04-11T14:23:49.000Z</published>
    <updated>2020-04-11T15:54:08.829Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Last week I wrote a post about how to design an URL shortening service, like TinyURL, and came up with 2 strategies to encode an URL,
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="url shortening" scheme="http://kingsamchen.github.io/tags/url-shortening/"/>
    
      <category term="base62" scheme="http://kingsamchen.github.io/tags/base62/"/>
    
  </entry>
  
  <entry>
    <title>How To Design a URL Shortening Service</title>
    <link href="http://kingsamchen.github.io/2020/04/04/how-to-design-a-url-shortening-system/"/>
    <id>http://kingsamchen.github.io/2020/04/04/how-to-design-a-url-shortening-system/</id>
    <published>2020-04-04T09:32:38.000Z</published>
    <updated>2020-04-04T09:36:44.280Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Encoding-Actual-URL&quot;&gt;&lt;a href=&quot;#1-Encoding-Actual-URL&quot; class=&quot;headerlink&quot; title=&quot;1. Encoding Actual URL&quot;&gt;&lt;/a&gt;1. Encoding Actual URL&lt;/h2&gt;&lt;p&gt;The path part, which we would call it &lt;em&gt;key&lt;/em&gt;, of an encoded URL can consist of 6 ~ 8 digits in base62, up to desired uniqueness rate.&lt;/p&gt;
&lt;h3 id=&quot;Randomly-Generated&quot;&gt;&lt;a href=&quot;#Randomly-Generated&quot; class=&quot;headerlink&quot; title=&quot;Randomly Generated&quot;&gt;&lt;/a&gt;Randomly Generated&lt;/h3&gt;&lt;p&gt;We can randomly generate those digits each within the range [0, 61].&lt;/p&gt;
&lt;p&gt;Then we must check if the generated key is unique by consulting our key storage.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Aside: this checking process can be optimized with data structures like bloom-filter, provided we have to deal hundres of million records.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If we are unlucky, we may have a key collision; in this case, just re-generate another key until its unique.&lt;/p&gt;
&lt;p&gt;To make encoding more efficient, we can have a standalone &lt;em&gt;Key Generation Service(KGS)&lt;/em&gt; that generates those random key beforehand, and store them.&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="system design" scheme="http://kingsamchen.github.io/tags/system-design/"/>
    
      <category term="url shortening" scheme="http://kingsamchen.github.io/tags/url-shortening/"/>
    
      <category term="tinyurl" scheme="http://kingsamchen.github.io/tags/tinyurl/"/>
    
      <category term="bit.ly" scheme="http://kingsamchen.github.io/tags/bit-ly/"/>
    
  </entry>
  
  <entry>
    <title>CMake 入门指南</title>
    <link href="http://kingsamchen.github.io/2020/02/08/how-to-learn-cmake-as-the-beginner/"/>
    <id>http://kingsamchen.github.io/2020/02/08/how-to-learn-cmake-as-the-beginner/</id>
    <published>2020-02-08T13:11:51.000Z</published>
    <updated>2020-02-08T13:33:45.038Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章来自于我在知乎上的这个&lt;a href=&quot;https://www.zhihu.com/question/58949190/answer/999701073&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;回答&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;天知道为什么当初会花时间写一个这么严肃的答案，考虑到国内社区的审查力度保不准哪天我的帐号就GG了，这里特意做一个备份。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作为一个从2018年下半年开始到现在断断续续折腾了一年半 CMake 的人，刚好经历了 CMake 从懵逼到入门阶段。&lt;/p&gt;
&lt;p&gt;注：虽然问题是17年提的，但是考虑到 CMake 的频繁迭代和最佳实践的变化，希望以下内容仍有帮助。&lt;/p&gt;
&lt;h3 id=&quot;Why-CMake-？&quot;&gt;&lt;a href=&quot;#Why-CMake-？&quot; class=&quot;headerlink&quot; title=&quot;Why CMake ？&quot;&gt;&lt;/a&gt;Why CMake ？&lt;/h3&gt;&lt;p&gt;先回答括号中的问题：&lt;strong&gt;被逼的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这三个字是认真的。&lt;/p&gt;
&lt;p&gt;不管 CMake 是否是一个优秀的构建工具，不管你是否认同 CMake，都无法否认 CMake 目前是 C++ 的 de facto build system[^1]。&lt;/p&gt;
&lt;p&gt;所以在社区以及生态的影响下，使用 CMake 作为构建工具的项目会越来越多。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cmake" scheme="http://kingsamchen.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>SYN Queue and Accept Queue</title>
    <link href="http://kingsamchen.github.io/2019/12/21/syn-queue-and-accept-queue/"/>
    <id>http://kingsamchen.github.io/2019/12/21/syn-queue-and-accept-queue/</id>
    <published>2019-12-21T14:23:19.000Z</published>
    <updated>2019-12-21T14:33:35.910Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-A-Single-Queue-or-Two-Queues&quot;&gt;&lt;a href=&quot;#0x00-A-Single-Queue-or-Two-Queues&quot; class=&quot;headerlink&quot; title=&quot;0x00 A Single Queue or Two Queues&quot;&gt;&lt;/a&gt;0x00 A Single Queue or Two Queues&lt;/h2&gt;&lt;p&gt;TCP/IP stack has two options to implement the backlog queue for a socket in the &lt;code&gt;LISTEN&lt;/code&gt; state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Door #1: A Single Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A single queue can contain connections in two different states:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SYN RECEIVED&lt;/li&gt;
&lt;li&gt;ESTABLISHED&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And only connections in &lt;code&gt;ESTABLISHED&lt;/code&gt; state can be returned to the application by calling the &lt;code&gt;accept()&lt;/code&gt; syscall.&lt;/p&gt;
&lt;p&gt;Therefore, the length of this queue is determined by the &lt;code&gt;backlog&lt;/code&gt; argument of the &lt;code&gt;listen()&lt;/code&gt; syscall.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Door #2: A SYN Queue &amp;amp; An Accept Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this case, connections in state &lt;code&gt;SYN RECEIVED&lt;/code&gt; are added to the SYN queue, and later moved to the accept queue when their state changes to &lt;code&gt;ESTABLISHED&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="tcp" scheme="http://kingsamchen.github.io/tags/tcp/"/>
    
      <category term="listen" scheme="http://kingsamchen.github.io/tags/listen/"/>
    
      <category term="backlog" scheme="http://kingsamchen.github.io/tags/backlog/"/>
    
  </entry>
  
  <entry>
    <title>Toml to Golang Struct</title>
    <link href="http://kingsamchen.github.io/2019/12/08/toml-to-golang-struct/"/>
    <id>http://kingsamchen.github.io/2019/12/08/toml-to-golang-struct/</id>
    <published>2019-12-08T13:47:16.000Z</published>
    <updated>2019-12-08T13:54:48.686Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前写某个东西的副产品，本质上和 &lt;a href=&quot;https://xuri.me/toml-to-go/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xuri.me/toml-to-go/&lt;/a&gt; 一样。&lt;/p&gt;
&lt;p&gt;解析 Toml
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="toml" scheme="http://kingsamchen.github.io/tags/toml/"/>
    
  </entry>
  
  <entry>
    <title>auto-cfs-cores C++ 版 automaxprocs</title>
    <link href="http://kingsamchen.github.io/2019/11/24/auto-cfs-cores-cpp-version-of-automaxprocs/"/>
    <id>http://kingsamchen.github.io/2019/11/24/auto-cfs-cores-cpp-version-of-automaxprocs/</id>
    <published>2019-11-24T09:10:41.000Z</published>
    <updated>2019-11-24T09:20:54.150Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前写了一篇分析 uber 的 automaxprocs 的源码，后面抽个了时间写了一个 C++ 版本的。&lt;/p&gt;
&lt;p&gt;其一是为了加深对原库的理解；其二是避免太长时间没写 C++ 手生，以及顺带体验一下 C++ 17 的感觉。&lt;/p&gt;
&lt;p&gt;代码在：&lt;a
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="docker" scheme="http://kingsamchen.github.io/tags/docker/"/>
    
      <category term="cfs" scheme="http://kingsamchen.github.io/tags/cfs/"/>
    
  </entry>
  
  <entry>
    <title>uber automaxprocs 源码分析</title>
    <link href="http://kingsamchen.github.io/2019/11/09/src-study-uber-automaxprocs/"/>
    <id>http://kingsamchen.github.io/2019/11/09/src-study-uber-automaxprocs/</id>
    <published>2019-11-08T16:43:11.000Z</published>
    <updated>2019-11-08T17:03:00.810Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近直播内部的 golang 服务都使用了 uber 出品的 automaxprocs 这个库。&lt;/p&gt;
&lt;p&gt;据伟大的 @ice 马总说，这个库解决了一个困扰B站整个golang（container）技术栈一年多的问题。&lt;/p&gt;
&lt;p&gt;出于好奇这个库到底做了什么 magic，能够解决这个持续了一年多的 pain in the ass，抽了一点时间，稍微翻了一下库的源代码，记录如下。&lt;/p&gt;
&lt;h1 id=&quot;automaxprocs-解决了什么问题&quot;&gt;&lt;a href=&quot;#automaxprocs-解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;automaxprocs 解决了什么问题&quot;&gt;&lt;/a&gt;automaxprocs 解决了什么问题&lt;/h1&gt;&lt;p&gt;线上容器里的服务通常都对 CPU 资源做了限制，例如默认的 4C。&lt;/p&gt;
&lt;p&gt;但是在容器里通过 &lt;code&gt;lscpu&lt;/code&gt; 仍然能看到宿主机的所有 CPU 核心：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rchitecture:          x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU op-mode(s):        32-bit, 64-bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Byte Order:            Little Endian&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU(s):                48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On-line CPU(s) list:   0-47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Thread(s) per core:    2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Core(s) per socket:    12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Socket(s):             2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NUMA node(s):          2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vendor ID:             GenuineIntel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU family:            6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Model:                 79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Model name:            Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stepping:              1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就导致 golang 服务默认会拿宿主机的 CPU 核心数来调用 &lt;code&gt;runtime.GOMAXPROCS()&lt;/code&gt;，导致 P 数量远远大于可用的 CPU 核心，引起频繁上下文切换，影响高负载情况下的服务性能。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="automaxprocs" scheme="http://kingsamchen.github.io/tags/automaxprocs/"/>
    
  </entry>
  
  <entry>
    <title>一个轮子：基于 token bucket 的 rate-limit</title>
    <link href="http://kingsamchen.github.io/2019/11/04/token-bucket-based-rate-limit/"/>
    <id>http://kingsamchen.github.io/2019/11/04/token-bucket-based-rate-limit/</id>
    <published>2019-11-04T12:31:14.000Z</published>
    <updated>2019-11-04T14:09:43.877Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;地址：&lt;a href=&quot;https://github.com/kingsamchen/Eureka/tree/master/token-bucket-rate-limit&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="algorithm" scheme="http://kingsamchen.github.io/tags/algorithm/"/>
    
      <category term="token bucket" scheme="http://kingsamchen.github.io/tags/token-bucket/"/>
    
      <category term="rate-limit" scheme="http://kingsamchen.github.io/tags/rate-limit/"/>
    
  </entry>
  
  <entry>
    <title>Windows 上使用 Git Tips 两则</title>
    <link href="http://kingsamchen.github.io/2019/10/19/two-git-tips-on-windows/"/>
    <id>http://kingsamchen.github.io/2019/10/19/two-git-tips-on-windows/</id>
    <published>2019-10-19T09:12:14.000Z</published>
    <updated>2019-10-19T09:27:44.767Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Windows-Terminal-中-git-log-显示-UTF-8-编码的中文&quot;&gt;&lt;a href=&quot;#Windows-Terminal-中-git-log-显示-UTF-8-编码的中文&quot; class=&quot;headerlink&quot; title=&quot;Windows
        
      
    
    </summary>
    
      <category term="CODE-LIFE" scheme="http://kingsamchen.github.io/categories/CODE-LIFE/"/>
    
    
      <category term="git" scheme="http://kingsamchen.github.io/tags/git/"/>
    
      <category term="powershell" scheme="http://kingsamchen.github.io/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>复习：DCLP 和 Memory Reordering</title>
    <link href="http://kingsamchen.github.io/2019/10/01/review-dclp-and-memory-reordering/"/>
    <id>http://kingsamchen.github.io/2019/10/01/review-dclp-and-memory-reordering/</id>
    <published>2019-10-01T04:29:03.000Z</published>
    <updated>2019-10-01T08:40:09.015Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 Jeff Preshing 的 &lt;a href=&quot;https://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Double Checked Locking Is Fixed in C++ 11&lt;/a&gt; 笔记。&lt;/p&gt;
&lt;h3 id=&quot;0x00-传统实现&quot;&gt;&lt;a href=&quot;#0x00-传统实现&quot; class=&quot;headerlink&quot; title=&quot;0x00 传统实现&quot;&gt;&lt;/a&gt;0x00 传统实现&lt;/h3&gt;&lt;p&gt;因为 synchronization 只需要在实例第一次创建时保证；此后（ &lt;code&gt;instance != nullptr&lt;/code&gt; 时）都不需要锁来保证 synchronization。&lt;/p&gt;
&lt;p&gt;在第一次判断实例为空和上锁之间存在一个 potential race，因此上锁后需要再一次判断实例是否为空。&lt;/p&gt;
&lt;p&gt;这也是 double checked 的来由。&lt;/p&gt;
&lt;p&gt;所以一个传统但并不100%正确的 DCLP 实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton* &lt;span class=&quot;title&quot;&gt;GetInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::lock_guard&amp;lt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::mutex&amp;gt; lock(mtx);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();				&lt;span class=&quot;comment&quot;&gt;// &amp;lt;-- key point&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// omit explicit static field initialization.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::mutex mtx;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton* instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这基本是早起 C++ DCLP 的实现架子。&lt;/p&gt;
&lt;h3 id=&quot;0x01-问题：内存乱序以及为什么锁帮不了忙&quot;&gt;&lt;a href=&quot;#0x01-问题：内存乱序以及为什么锁帮不了忙&quot; class=&quot;headerlink&quot; title=&quot;0x01 问题：内存乱序以及为什么锁帮不了忙&quot;&gt;&lt;/a&gt;0x01 问题：内存乱序以及为什么锁帮不了忙&lt;/h3&gt;&lt;p&gt;语句&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 C++ 中实际上等效于&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tmp = &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(Singleton));  &lt;span class=&quot;comment&quot;&gt;// step 1: allocate memory via operator new&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;(tmp) Singleton;                     &lt;span class=&quot;comment&quot;&gt;// step 2: placement-new for construction&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance = tmp;                         &lt;span class=&quot;comment&quot;&gt;// step 3: assign addr to instance&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：其中除了分配内存是固定第一步之外，构造对象和赋值内存地址的&lt;strong&gt;生成代码顺序&lt;/strong&gt;是由编译器自己决定。这里的顺序只是一种可能性。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="singleton" scheme="http://kingsamchen.github.io/tags/singleton/"/>
    
      <category term="memory-reordering" scheme="http://kingsamchen.github.io/tags/memory-reordering/"/>
    
  </entry>
  
  <entry>
    <title>ASIO Buffer 使用简记</title>
    <link href="http://kingsamchen.github.io/2019/09/22/simple-notes-on-using-asio-buffer/"/>
    <id>http://kingsamchen.github.io/2019/09/22/simple-notes-on-using-asio-buffer/</id>
    <published>2019-09-22T12:27:48.000Z</published>
    <updated>2019-09-22T14:15:31.794Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;近段有相当一部分时间在&lt;a href=&quot;https://github.com/kingsamchen/Eureka/tree/master/learn-asio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;熟悉和练习 ASIO&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;练习过程中发现 ASIO 中如何使用&amp;amp;管理 buffer 是新手大概率会遇到的问题。&lt;/p&gt;
&lt;p&gt;结合最近几个 practice demo，稍微简单总结了一下使用经验：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0x00&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const_buffer&lt;/code&gt; 和 &lt;code&gt;mutable_buffer&lt;/code&gt; 是两个 fundamental buffer classes。二者的区别在语义上表达的很明显了。&lt;/p&gt;
&lt;p&gt;实现上二者提供的接口非常一致，除了一个面向 &lt;code&gt;const void*&lt;/code&gt;，另一个面向 &lt;code&gt;void*&lt;/code&gt;。这点可以从 ctor 和 &lt;code&gt;data()&lt;/code&gt; 中看出。&lt;/p&gt;
&lt;p&gt;另外，为了和 C++ 现有的 const cast semantics 保持一致，一个 &lt;code&gt;mutable_buffer&lt;/code&gt; 对象可以 implicitly converted to &lt;code&gt;const_buffer&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="ASIO" scheme="http://kingsamchen.github.io/tags/ASIO/"/>
    
      <category term="networking" scheme="http://kingsamchen.github.io/tags/networking/"/>
    
      <category term="buffer" scheme="http://kingsamchen.github.io/tags/buffer/"/>
    
  </entry>
  
  <entry>
    <title>避免在 Linux 上使用 signals</title>
    <link href="http://kingsamchen.github.io/2019/09/09/avoid-using-signals-on-linux/"/>
    <id>http://kingsamchen.github.io/2019/09/09/avoid-using-signals-on-linux/</id>
    <published>2019-09-09T12:27:09.000Z</published>
    <updated>2019-09-13T11:12:35.372Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;首先承认这个标题乍看之下很像 troll，但真的不是 troll；“避免使用”总的来说更接近 &lt;em&gt;whenever possible&lt;/em&gt; 的意思。&lt;/p&gt;
&lt;p&gt;另外，这篇 post 面向的主要是偏底层的、直接使用 system calls 或其 runtime wrapper（glibc）的开发者，最典型的比如 C/C++ 开发者。&lt;/p&gt;
&lt;p&gt;其他语言的开发者通常因为要么 runtime “屏蔽”了这部分内容（如 Java）；要么 runtime 自身对这部分做了较大的抽象/改造（如 Golang），因此很难对此 post 提到的各种观点/做法产生共鸣。&lt;/p&gt;
&lt;p&gt;FYI：自从工作后中文写作能力一直在退化，因此这篇文章如果存在语句不通顺或者用词不当的地方，烦请见谅。&lt;/p&gt;
&lt;h2 id=&quot;0x00-背景回顾：什么是-signal？&quot;&gt;&lt;a href=&quot;#0x00-背景回顾：什么是-signal？&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景回顾：什么是 signal？&quot;&gt;&lt;/a&gt;0x00 背景回顾：什么是 signal？&lt;/h2&gt;&lt;p&gt;signal 源自 Unix，后来成为 POSIX 标准的一部分，现在则被几乎所有的 *nix 系统支持。&lt;/p&gt;
&lt;p&gt;signal 本质上是一种通讯机制，用于系统在某个事件（event）发生时通知某个进程（或线程）。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="signal" scheme="http://kingsamchen.github.io/tags/signal/"/>
    
      <category term="Linux" scheme="http://kingsamchen.github.io/tags/Linux/"/>
    
      <category term="Unix" scheme="http://kingsamchen.github.io/tags/Unix/"/>
    
      <category term="signalfd" scheme="http://kingsamchen.github.io/tags/signalfd/"/>
    
      <category term="self-pipe trick" scheme="http://kingsamchen.github.io/tags/self-pipe-trick/"/>
    
  </entry>
  
  <entry>
    <title>Monthly Read Posts in Aug 2019</title>
    <link href="http://kingsamchen.github.io/2019/09/01/monthly-read-posts-in-aug-2019/"/>
    <id>http://kingsamchen.github.io/2019/09/01/monthly-read-posts-in-aug-2019/</id>
    <published>2019-09-01T12:13:28.000Z</published>
    <updated>2019-09-01T12:16:22.898Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Concurrency&quot;&gt;&lt;a href=&quot;#Concurrency&quot; class=&quot;headerlink&quot; title=&quot;Concurrency&quot;&gt;&lt;/a&gt;Concurrency&lt;/h2&gt;&lt;p&gt;&lt;a
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="memory fence" scheme="http://kingsamchen.github.io/tags/memory-fence/"/>
    
      <category term="mysql" scheme="http://kingsamchen.github.io/tags/mysql/"/>
    
      <category term="lock-free" scheme="http://kingsamchen.github.io/tags/lock-free/"/>
    
      <category term="atomic" scheme="http://kingsamchen.github.io/tags/atomic/"/>
    
      <category term="systemd" scheme="http://kingsamchen.github.io/tags/systemd/"/>
    
  </entry>
  
</feed>
