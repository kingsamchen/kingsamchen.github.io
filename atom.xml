<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KC的废墟堆</title>
  
  <subtitle>Will you serve in Heaven, or rule in Hell</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kingsamchen.github.io/"/>
  <updated>2020-09-20T13:05:18.567Z</updated>
  <id>http://kingsamchen.github.io/</id>
  
  <author>
    <name>Kingsley Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redigo 源码学习：Pipeline</title>
    <link href="http://kingsamchen.github.io/2020/09/20/src-study-redigo-using-pipeline/"/>
    <id>http://kingsamchen.github.io/2020/09/20/src-study-redigo-using-pipeline/</id>
    <published>2020-09-20T13:02:04.000Z</published>
    <updated>2020-09-20T13:05:18.567Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何使用-pipeline&quot;&gt;&lt;a href=&quot;#如何使用-pipeline&quot; class=&quot;headerlink&quot; title=&quot;如何使用 pipeline&quot;&gt;&lt;/a&gt;如何使用 pipeline&lt;/h2&gt;&lt;p&gt;先来回顾一下如何在 redigo 中使用 pipeline&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c := pool.Get()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; c.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.Send(&lt;span class=&quot;string&quot;&gt;&quot;SET&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.Send(&lt;span class=&quot;string&quot;&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.Flush()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c.Receive() &lt;span class=&quot;comment&quot;&gt;// reply from SET&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v, err = c.Receive() &lt;span class=&quot;comment&quot;&gt;// reply from GET&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;核心是 Send — Flush — Receive 三个步骤。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="redis" scheme="http://kingsamchen.github.io/tags/redis/"/>
    
      <category term="redigo" scheme="http://kingsamchen.github.io/tags/redigo/"/>
    
      <category term="pipeline" scheme="http://kingsamchen.github.io/tags/pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Error Handling is Operation Cancellation</title>
    <link href="http://kingsamchen.github.io/2020/09/12/error-handling-is-operation-cancellation/"/>
    <id>http://kingsamchen.github.io/2020/09/12/error-handling-is-operation-cancellation/</id>
    <published>2020-09-12T12:21:46.000Z</published>
    <updated>2020-09-12T12:27:54.827Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近看了&lt;a href=&quot;https://akrzemi1.wordpress.com/2019/04/25/handling-errors-is-canceling-operations/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;有一种顿悟感，想着写点总结加深理解。&lt;/p&gt;
&lt;p&gt;如果嫌原文太长可以直接看这篇总结；不过别人咀嚼过的不一定适合你，所以还是推荐一块把原文也看了😁。&lt;/p&gt;
&lt;h2 id=&quot;Operation-Cancellation&quot;&gt;&lt;a href=&quot;#Operation-Cancellation&quot; class=&quot;headerlink&quot; title=&quot;Operation Cancellation&quot;&gt;&lt;/a&gt;Operation Cancellation&lt;/h2&gt;&lt;p&gt;假设一个函数 &lt;code&gt;foo()&lt;/code&gt; 中的某个操作发生了错误，并且后续操作&lt;strong&gt;直接或间接地依赖&lt;/strong&gt;当前操作的正确行为；那么，不管使用何种错误处理/汇报手段，这里都需要 (1) 中止后续操作并 (2) 向上汇报错误。&lt;/p&gt;
&lt;p&gt;这里称这种行为为 &lt;em&gt;operation cancellation&lt;/em&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="error handling" scheme="http://kingsamchen.github.io/tags/error-handling/"/>
    
      <category term="exception" scheme="http://kingsamchen.github.io/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>Python fileinput 换行编码问题</title>
    <link href="http://kingsamchen.github.io/2020/09/08/fileinput-print-and-line-ending/"/>
    <id>http://kingsamchen.github.io/2020/09/08/fileinput-print-and-line-ending/</id>
    <published>2020-09-08T03:54:27.000Z</published>
    <updated>2020-09-08T04:22:09.443Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;昨晚抽了个时间想修一下 anvil 的这个 &lt;a href=&quot;https://github.com/kingsamchen/anvil/issues/2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;根据之前的代码实现，我有 99.99% 的把握换行符被替换成 &lt;code&gt;CRLF&lt;/code&gt; 是使用了 &lt;code&gt;fileinput&lt;/code&gt; 原地修改了文件导致的。&lt;/p&gt;
&lt;p&gt;那段修改的代码的一个等价实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; shutil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; fileinput&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;poc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    orig_name = &lt;span class=&quot;string&quot;&gt;&#39;orig.txt&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    new_name = &lt;span class=&quot;string&quot;&gt;&#39;new.txt&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shutil.copy(orig_name, new_name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; fileinput.FileInput(new_name, inplace=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; f:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            line = &lt;span class=&quot;string&quot;&gt;&#39;-&amp;gt; &#39;&lt;/span&gt; + line&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(line, end=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;orig.txt&lt;/code&gt; 是一个模板文件，它会被拷贝到指定目录变成一个新文件 &lt;code&gt;new.txt&lt;/code&gt;，并修改文件内容。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="python" scheme="http://kingsamchen.github.io/tags/python/"/>
    
      <category term="line ending" scheme="http://kingsamchen.github.io/tags/line-ending/"/>
    
      <category term="fileinput" scheme="http://kingsamchen.github.io/tags/fileinput/"/>
    
  </entry>
  
  <entry>
    <title>Redigo 源码学习：阻塞等待连接可用</title>
    <link href="http://kingsamchen.github.io/2020/08/22/src-study-redigo-wait-on-avail-conn/"/>
    <id>http://kingsamchen.github.io/2020/08/22/src-study-redigo-wait-on-avail-conn/</id>
    <published>2020-08-22T03:24:10.000Z</published>
    <updated>2020-08-22T08:32:41.607Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;通过&lt;a href=&quot;/2020/08/21/src-study-redigo-redis-pool/&quot; title=&quot;连接池的设计&quot;&gt;连接池的设计&lt;/a&gt;了解如何回收连接到连接池以及从连接池复用连接后，可以回过头来研究一下 Redigo 支持的阻塞等待可用连接的设计与实现。&lt;/p&gt;
&lt;p&gt;通过设置 &lt;code&gt;Pool.Wait == true&lt;/code&gt; 之后如果当前连接池满了， &lt;code&gt;Pool.Get()&lt;/code&gt; 不会返回连接池耗尽错误，而是阻塞在调用上，直到超时或者存在可用连接才会返回。&lt;/p&gt;
&lt;p&gt;这个属于经典的 resource counting 问题，并且最大的 resource count 由 &lt;code&gt;Pool.MaxActive&lt;/code&gt; 决定。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="redigo" scheme="http://kingsamchen.github.io/tags/redigo/"/>
    
  </entry>
  
  <entry>
    <title>Redigo 源码学习：连接池的设计</title>
    <link href="http://kingsamchen.github.io/2020/08/21/src-study-redigo-redis-pool/"/>
    <id>http://kingsamchen.github.io/2020/08/21/src-study-redigo-redis-pool/</id>
    <published>2020-08-20T16:24:17.000Z</published>
    <updated>2020-08-22T08:30:35.359Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要数据结构&quot;&gt;&lt;a href=&quot;#主要数据结构&quot; class=&quot;headerlink&quot; title=&quot;主要数据结构&quot;&gt;&lt;/a&gt;主要数据结构&lt;/h2&gt;&lt;p&gt;暴露给外部用户的 &lt;code&gt;Pool&lt;/code&gt; 对象&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Pool &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Maximum number of idle connections in the pool.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	MaxIdle &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Maximum number of connections allocated by the pool at a given time.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// When zero, there is no limit on the number of connections in the pool.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	MaxActive &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Close connections after remaining idle for this duration. If the value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// is zero, then idle connections are not closed. Applications should set&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// the timeout to a value less than the server&#39;s timeout.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	IdleTimeout time.Duration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mu           sync.Mutex    &lt;span class=&quot;comment&quot;&gt;// mu protects the following fields&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	active       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;// the number of open connections in the pool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	idle         idleList      &lt;span class=&quot;comment&quot;&gt;// idle connections&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内部维护空闲/待复用的列表数据结构 &lt;code&gt;idleList&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="redigo" scheme="http://kingsamchen.github.io/tags/redigo/"/>
    
      <category term="pool" scheme="http://kingsamchen.github.io/tags/pool/"/>
    
  </entry>
  
  <entry>
    <title>Redigo 源码学习</title>
    <link href="http://kingsamchen.github.io/2020/08/21/src-study-redigo/"/>
    <id>http://kingsamchen.github.io/2020/08/21/src-study-redigo/</id>
    <published>2020-08-20T16:11:04.000Z</published>
    <updated>2020-09-20T13:05:01.312Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Redigo 是目前比较流行的一个 Redis Client。&lt;/p&gt;
&lt;p&gt;虽然我个人不太喜欢它的 API 设计，奈何这个库简单易用，连公司的 redis 基础库都是在 Redigo 上做的的一个魔改。&lt;/p&gt;
&lt;p&gt;注：原生的 Redigo 并不支持 Redis
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="redis" scheme="http://kingsamchen.github.io/tags/redis/"/>
    
      <category term="redigo" scheme="http://kingsamchen.github.io/tags/redigo/"/>
    
  </entry>
  
  <entry>
    <title>再谈 passkey idiom</title>
    <link href="http://kingsamchen.github.io/2020/08/16/passkey-idiom-part-2/"/>
    <id>http://kingsamchen.github.io/2020/08/16/passkey-idiom-part-2/</id>
    <published>2020-08-16T08:18:35.000Z</published>
    <updated>2020-08-16T08:39:01.043Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;我在 &lt;a href=&quot;/2020/07/02/passkey-idiom-for-make-functions/&quot; title=&quot;Passkey Idiom&quot;&gt;Passkey Idiom&lt;/a&gt; 这篇文章中介绍了如何使用 passkey idiom
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="passkey" scheme="http://kingsamchen.github.io/tags/passkey/"/>
    
      <category term="explicit" scheme="http://kingsamchen.github.io/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>The std::byte For Byte Addressing</title>
    <link href="http://kingsamchen.github.io/2020/07/14/the-std-byte/"/>
    <id>http://kingsamchen.github.io/2020/07/14/the-std-byte/</id>
    <published>2020-07-13T16:55:59.000Z</published>
    <updated>2020-08-16T08:16:19.270Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;时隔多年，C++ 17 终于迎来了专门用于 byte-oriented access 的数据类型 &lt;code&gt;std::byte&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;之所以引入一个新的类型是因为之前不管是 &lt;code&gt;char&lt;/code&gt; 还是 &lt;code&gt;unsigned
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Passkey Idiom</title>
    <link href="http://kingsamchen.github.io/2020/07/02/passkey-idiom-for-make-functions/"/>
    <id>http://kingsamchen.github.io/2020/07/02/passkey-idiom-for-make-functions/</id>
    <published>2020-07-01T16:28:19.000Z</published>
    <updated>2020-07-04T08:55:14.196Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;如果出于某些目的希望将某个类的构造函数设置为 private，并提供工厂函数 &lt;code&gt;Make()&lt;/code&gt; 创建最终对象；工厂函数中通常会使用 &lt;code&gt;std::make_unique()&lt;/code&gt; 或者
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="make_unique" scheme="http://kingsamchen.github.io/tags/make-unique/"/>
    
      <category term="make_shared" scheme="http://kingsamchen.github.io/tags/make-shared/"/>
    
      <category term="passkey" scheme="http://kingsamchen.github.io/tags/passkey/"/>
    
  </entry>
  
  <entry>
    <title>Golang&#39;s Options Pattern</title>
    <link href="http://kingsamchen.github.io/2020/06/30/golang-options-pattern/"/>
    <id>http://kingsamchen.github.io/2020/06/30/golang-options-pattern/</id>
    <published>2020-06-30T01:29:23.000Z</published>
    <updated>2020-07-04T08:55:14.196Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;可以将 Golang 的 &lt;em&gt;Options Pattern&lt;/em&gt; 视作（有副作用）函数式版的 &lt;em&gt;Builder Pattern&lt;/em&gt;，其核心是：特定的 option-function 调用会生成对应的类型为 Option 的闭包，执行闭包会修改内部的
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="options" scheme="http://kingsamchen.github.io/tags/options/"/>
    
      <category term="design patterns" scheme="http://kingsamchen.github.io/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>保持 ASIO io_context 无任务时运行</title>
    <link href="http://kingsamchen.github.io/2020/06/28/keep-asio-io-context-running/"/>
    <id>http://kingsamchen.github.io/2020/06/28/keep-asio-io-context-running/</id>
    <published>2020-06-28T15:03:22.000Z</published>
    <updated>2020-06-28T15:17:24.037Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;ASIO 的 &lt;code&gt;io_context::run()&lt;/code&gt; 如果发现没有 pending 的任务就会返回，对于 server 的监听线程来说这是符合常理的，因为无论如何至少有个 &lt;code&gt;acceptor::async_accept()&lt;/code&gt; 在
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="asio" scheme="http://kingsamchen.github.io/tags/asio/"/>
    
      <category term="io_context" scheme="http://kingsamchen.github.io/tags/io-context/"/>
    
      <category term="work_guard" scheme="http://kingsamchen.github.io/tags/work-guard/"/>
    
  </entry>
  
  <entry>
    <title>atoi With Overflow Handled</title>
    <link href="http://kingsamchen.github.io/2020/05/04/atoi-with-overflow-handled/"/>
    <id>http://kingsamchen.github.io/2020/05/04/atoi-with-overflow-handled/</id>
    <published>2020-05-04T07:03:26.000Z</published>
    <updated>2020-05-04T07:53:16.256Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;leetcode 上有一题是让你实现一个 &lt;code&gt;atoi()&lt;/code&gt;，但是因为函数类型是 32-bit int，所以可以直接内部转换到 64-bit int，避免需要直接处理溢出的情况。&lt;/p&gt;
&lt;p&gt;如果要针对 &lt;code&gt;int64&lt;/code&gt; 实现一个
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="atoi" scheme="http://kingsamchen.github.io/tags/atoi/"/>
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Allow Connections From LAN for Trojan-qt5</title>
    <link href="http://kingsamchen.github.io/2020/04/19/allow-connections-from-lan-for-trojan-qt5/"/>
    <id>http://kingsamchen.github.io/2020/04/19/allow-connections-from-lan-for-trojan-qt5/</id>
    <published>2020-04-19T04:33:18.000Z</published>
    <updated>2020-04-19T05:02:37.488Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;因为众所周知的原因，机场的服务商把协议从 SS 切换到了 Trojan。但是之前的 SS windows 客户端只支持 SS 协议，所以切换后只能换 Trojan-qt5 作为客户端。&lt;/p&gt;
&lt;p&gt;但是这个客户端做的实在不怎么样，作者似乎是在原来的 ss-qt5
        
      
    
    </summary>
    
      <category term="CODE-LIFE" scheme="http://kingsamchen.github.io/categories/CODE-LIFE/"/>
    
    
      <category term="梯子" scheme="http://kingsamchen.github.io/tags/%E6%A2%AF%E5%AD%90/"/>
    
      <category term="shadowsocks" scheme="http://kingsamchen.github.io/tags/shadowsocks/"/>
    
      <category term="trojan" scheme="http://kingsamchen.github.io/tags/trojan/"/>
    
      <category term="socat" scheme="http://kingsamchen.github.io/tags/socat/"/>
    
  </entry>
  
  <entry>
    <title>Randomly Generate Base62 for URL Shortening</title>
    <link href="http://kingsamchen.github.io/2020/04/11/randomly-generate-base62-for-url-shortening/"/>
    <id>http://kingsamchen.github.io/2020/04/11/randomly-generate-base62-for-url-shortening/</id>
    <published>2020-04-11T14:23:49.000Z</published>
    <updated>2020-04-11T15:54:08.829Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Last week I wrote a post about how to design an URL shortening service, like TinyURL, and came up with 2 strategies to encode an URL,
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="url shortening" scheme="http://kingsamchen.github.io/tags/url-shortening/"/>
    
      <category term="base62" scheme="http://kingsamchen.github.io/tags/base62/"/>
    
  </entry>
  
  <entry>
    <title>How To Design a URL Shortening Service</title>
    <link href="http://kingsamchen.github.io/2020/04/04/how-to-design-a-url-shortening-system/"/>
    <id>http://kingsamchen.github.io/2020/04/04/how-to-design-a-url-shortening-system/</id>
    <published>2020-04-04T09:32:38.000Z</published>
    <updated>2020-04-04T09:36:44.280Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Encoding-Actual-URL&quot;&gt;&lt;a href=&quot;#1-Encoding-Actual-URL&quot; class=&quot;headerlink&quot; title=&quot;1. Encoding Actual URL&quot;&gt;&lt;/a&gt;1. Encoding Actual URL&lt;/h2&gt;&lt;p&gt;The path part, which we would call it &lt;em&gt;key&lt;/em&gt;, of an encoded URL can consist of 6 ~ 8 digits in base62, up to desired uniqueness rate.&lt;/p&gt;
&lt;h3 id=&quot;Randomly-Generated&quot;&gt;&lt;a href=&quot;#Randomly-Generated&quot; class=&quot;headerlink&quot; title=&quot;Randomly Generated&quot;&gt;&lt;/a&gt;Randomly Generated&lt;/h3&gt;&lt;p&gt;We can randomly generate those digits each within the range [0, 61].&lt;/p&gt;
&lt;p&gt;Then we must check if the generated key is unique by consulting our key storage.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Aside: this checking process can be optimized with data structures like bloom-filter, provided we have to deal hundres of million records.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If we are unlucky, we may have a key collision; in this case, just re-generate another key until its unique.&lt;/p&gt;
&lt;p&gt;To make encoding more efficient, we can have a standalone &lt;em&gt;Key Generation Service(KGS)&lt;/em&gt; that generates those random key beforehand, and store them.&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="system design" scheme="http://kingsamchen.github.io/tags/system-design/"/>
    
      <category term="url shortening" scheme="http://kingsamchen.github.io/tags/url-shortening/"/>
    
      <category term="tinyurl" scheme="http://kingsamchen.github.io/tags/tinyurl/"/>
    
      <category term="bit.ly" scheme="http://kingsamchen.github.io/tags/bit-ly/"/>
    
  </entry>
  
  <entry>
    <title>CMake 入门指南</title>
    <link href="http://kingsamchen.github.io/2020/02/08/how-to-learn-cmake-as-the-beginner/"/>
    <id>http://kingsamchen.github.io/2020/02/08/how-to-learn-cmake-as-the-beginner/</id>
    <published>2020-02-08T13:11:51.000Z</published>
    <updated>2020-02-08T13:33:45.038Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章来自于我在知乎上的这个&lt;a href=&quot;https://www.zhihu.com/question/58949190/answer/999701073&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;回答&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;天知道为什么当初会花时间写一个这么严肃的答案，考虑到国内社区的审查力度保不准哪天我的帐号就GG了，这里特意做一个备份。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作为一个从2018年下半年开始到现在断断续续折腾了一年半 CMake 的人，刚好经历了 CMake 从懵逼到入门阶段。&lt;/p&gt;
&lt;p&gt;注：虽然问题是17年提的，但是考虑到 CMake 的频繁迭代和最佳实践的变化，希望以下内容仍有帮助。&lt;/p&gt;
&lt;h3 id=&quot;Why-CMake-？&quot;&gt;&lt;a href=&quot;#Why-CMake-？&quot; class=&quot;headerlink&quot; title=&quot;Why CMake ？&quot;&gt;&lt;/a&gt;Why CMake ？&lt;/h3&gt;&lt;p&gt;先回答括号中的问题：&lt;strong&gt;被逼的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这三个字是认真的。&lt;/p&gt;
&lt;p&gt;不管 CMake 是否是一个优秀的构建工具，不管你是否认同 CMake，都无法否认 CMake 目前是 C++ 的 de facto build system[^1]。&lt;/p&gt;
&lt;p&gt;所以在社区以及生态的影响下，使用 CMake 作为构建工具的项目会越来越多。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cmake" scheme="http://kingsamchen.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>SYN Queue and Accept Queue</title>
    <link href="http://kingsamchen.github.io/2019/12/21/syn-queue-and-accept-queue/"/>
    <id>http://kingsamchen.github.io/2019/12/21/syn-queue-and-accept-queue/</id>
    <published>2019-12-21T14:23:19.000Z</published>
    <updated>2019-12-21T14:33:35.910Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-A-Single-Queue-or-Two-Queues&quot;&gt;&lt;a href=&quot;#0x00-A-Single-Queue-or-Two-Queues&quot; class=&quot;headerlink&quot; title=&quot;0x00 A Single Queue or Two Queues&quot;&gt;&lt;/a&gt;0x00 A Single Queue or Two Queues&lt;/h2&gt;&lt;p&gt;TCP/IP stack has two options to implement the backlog queue for a socket in the &lt;code&gt;LISTEN&lt;/code&gt; state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Door #1: A Single Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A single queue can contain connections in two different states:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SYN RECEIVED&lt;/li&gt;
&lt;li&gt;ESTABLISHED&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And only connections in &lt;code&gt;ESTABLISHED&lt;/code&gt; state can be returned to the application by calling the &lt;code&gt;accept()&lt;/code&gt; syscall.&lt;/p&gt;
&lt;p&gt;Therefore, the length of this queue is determined by the &lt;code&gt;backlog&lt;/code&gt; argument of the &lt;code&gt;listen()&lt;/code&gt; syscall.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Door #2: A SYN Queue &amp;amp; An Accept Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this case, connections in state &lt;code&gt;SYN RECEIVED&lt;/code&gt; are added to the SYN queue, and later moved to the accept queue when their state changes to &lt;code&gt;ESTABLISHED&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="tcp" scheme="http://kingsamchen.github.io/tags/tcp/"/>
    
      <category term="listen" scheme="http://kingsamchen.github.io/tags/listen/"/>
    
      <category term="backlog" scheme="http://kingsamchen.github.io/tags/backlog/"/>
    
  </entry>
  
  <entry>
    <title>Toml to Golang Struct</title>
    <link href="http://kingsamchen.github.io/2019/12/08/toml-to-golang-struct/"/>
    <id>http://kingsamchen.github.io/2019/12/08/toml-to-golang-struct/</id>
    <published>2019-12-08T13:47:16.000Z</published>
    <updated>2019-12-08T13:54:48.686Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前写某个东西的副产品，本质上和 &lt;a href=&quot;https://xuri.me/toml-to-go/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xuri.me/toml-to-go/&lt;/a&gt; 一样。&lt;/p&gt;
&lt;p&gt;解析 Toml
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="toml" scheme="http://kingsamchen.github.io/tags/toml/"/>
    
  </entry>
  
  <entry>
    <title>auto-cfs-cores C++ 版 automaxprocs</title>
    <link href="http://kingsamchen.github.io/2019/11/24/auto-cfs-cores-cpp-version-of-automaxprocs/"/>
    <id>http://kingsamchen.github.io/2019/11/24/auto-cfs-cores-cpp-version-of-automaxprocs/</id>
    <published>2019-11-24T09:10:41.000Z</published>
    <updated>2019-11-24T09:20:54.150Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前写了一篇分析 uber 的 automaxprocs 的源码，后面抽个了时间写了一个 C++ 版本的。&lt;/p&gt;
&lt;p&gt;其一是为了加深对原库的理解；其二是避免太长时间没写 C++ 手生，以及顺带体验一下 C++ 17 的感觉。&lt;/p&gt;
&lt;p&gt;代码在：&lt;a
        
      
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="cpp" scheme="http://kingsamchen.github.io/tags/cpp/"/>
    
      <category term="docker" scheme="http://kingsamchen.github.io/tags/docker/"/>
    
      <category term="cfs" scheme="http://kingsamchen.github.io/tags/cfs/"/>
    
  </entry>
  
  <entry>
    <title>uber automaxprocs 源码分析</title>
    <link href="http://kingsamchen.github.io/2019/11/09/src-study-uber-automaxprocs/"/>
    <id>http://kingsamchen.github.io/2019/11/09/src-study-uber-automaxprocs/</id>
    <published>2019-11-08T16:43:11.000Z</published>
    <updated>2019-11-08T17:03:00.810Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近直播内部的 golang 服务都使用了 uber 出品的 automaxprocs 这个库。&lt;/p&gt;
&lt;p&gt;据伟大的 @ice 马总说，这个库解决了一个困扰B站整个golang（container）技术栈一年多的问题。&lt;/p&gt;
&lt;p&gt;出于好奇这个库到底做了什么 magic，能够解决这个持续了一年多的 pain in the ass，抽了一点时间，稍微翻了一下库的源代码，记录如下。&lt;/p&gt;
&lt;h1 id=&quot;automaxprocs-解决了什么问题&quot;&gt;&lt;a href=&quot;#automaxprocs-解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;automaxprocs 解决了什么问题&quot;&gt;&lt;/a&gt;automaxprocs 解决了什么问题&lt;/h1&gt;&lt;p&gt;线上容器里的服务通常都对 CPU 资源做了限制，例如默认的 4C。&lt;/p&gt;
&lt;p&gt;但是在容器里通过 &lt;code&gt;lscpu&lt;/code&gt; 仍然能看到宿主机的所有 CPU 核心：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rchitecture:          x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU op-mode(s):        32-bit, 64-bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Byte Order:            Little Endian&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU(s):                48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On-line CPU(s) list:   0-47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Thread(s) per core:    2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Core(s) per socket:    12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Socket(s):             2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NUMA node(s):          2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vendor ID:             GenuineIntel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU family:            6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Model:                 79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Model name:            Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stepping:              1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就导致 golang 服务默认会拿宿主机的 CPU 核心数来调用 &lt;code&gt;runtime.GOMAXPROCS()&lt;/code&gt;，导致 P 数量远远大于可用的 CPU 核心，引起频繁上下文切换，影响高负载情况下的服务性能。&lt;br&gt;
    
    </summary>
    
      <category term="PROGRAMMING" scheme="http://kingsamchen.github.io/categories/PROGRAMMING/"/>
    
    
      <category term="golang" scheme="http://kingsamchen.github.io/tags/golang/"/>
    
      <category term="automaxprocs" scheme="http://kingsamchen.github.io/tags/automaxprocs/"/>
    
  </entry>
  
</feed>
