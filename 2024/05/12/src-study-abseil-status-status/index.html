<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Gone with the ruins"><title>abseil status/status 源码分析 | KC的废墟堆</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">abseil status/status 源码分析</h1><a id="logo" href="/.">KC的废墟堆</a><p class="description">Will you serve in Heaven, or rule in Hell</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/source-code-reading/"><i class="fa fa-archive"> 源码分析</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">abseil status/status 源码分析</h1><div class="post-meta">2024-05-12<span> | </span><span class="category"><a href="/categories/PROGRAMMING/">PROGRAMMING</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/05/12/src-study-abseil-status-status/" href="/2024/05/12/src-study-abseil-status-status/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Status-%E6%88%90%E5%91%98%E7%BB%93%E6%9E%84"><span class="toc-text">Status 成员结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ok-Status"><span class="toc-text">Ok Status</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-absl-OkStatus"><span class="toc-text">1. absl::OkStatus()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-default-constructor"><span class="toc-text">2. default constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Status-absl-StatusCode-code-absl-string-view-msg"><span class="toc-text">3. Status(absl::StatusCode code, absl::string_view msg)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A8%E8%AE%BA%EF%BC%9A-Ok-status-%E7%9A%84-msg-%E6%98%AF%E4%BA%8B%E5%85%88%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84"><span class="toc-text">4. 推论： Ok status 的 msg 是事先硬编码的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-ok-Status"><span class="toc-text">Non-ok Status</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Check-if-ok"><span class="toc-text">1. Check if ok</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%98%AF%E6%9F%90%E7%A7%8D%E9%94%99%E8%AF%AF"><span class="toc-text">2. 检查是否是某种错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%BB%E5%8F%96-code"><span class="toc-text">3. 读取 code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96-message"><span class="toc-text">4. 获取 message</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Move-%E8%AF%AD%E4%B9%89%E5%A4%84%E7%90%86"><span class="toc-text">Move 语义处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-text">1. 移动构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-text">2. 移动赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ref-counted-StatusRep"><span class="toc-text">Ref-counted StatusRep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-%E8%AF%AD%E4%B9%89%E6%93%8D%E4%BD%9C"><span class="toc-text">Copy 语义操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84"><span class="toc-text">析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ToString"><span class="toc-text">1. ToString</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Payload"><span class="toc-text">Payload</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Set-payload"><span class="toc-text">1. Set payload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Get-payload"><span class="toc-text">2. Get payload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Erase-payload"><span class="toc-text">3. Erase payload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Visit-payloads"><span class="toc-text">4. Visit payloads</span></a></li></ol></li></ol></div></div><div class="post-content"><p>Revision：</p>
<ul>
<li>LTS_2024_01_16</li>
</ul>
<p>💡 LTS_2024_01_16 开始 rep_ 成员的解释开始发生变化，所以之前版本的需要找对应源码</p>
<h2 id="Status-成员结构"><a href="#Status-成员结构" class="headerlink" title="Status 成员结构"></a>Status 成员结构</h2><p><code>Status</code> 只有一个成员，即 <code>rep_</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Status supports two different representations.</span></span><br><span class="line"><span class="comment">//  - When the low bit is set it is an inlined representation.</span></span><br><span class="line"><span class="comment">//    It uses the canonical error space, no message or payload.</span></span><br><span class="line"><span class="comment">//    The error code is (rep_ &gt;&gt; 2).</span></span><br><span class="line"><span class="comment">//    The (rep_ &amp; 2) bit is the &quot;moved from&quot; indicator, used in IsMovedFrom().</span></span><br><span class="line"><span class="comment">//  - When the low bit is off it is an external representation.</span></span><br><span class="line"><span class="comment">//    In this case all the data comes from a heap allocated Rep object.</span></span><br><span class="line"><span class="comment">//    rep_ is a status_internal::StatusRep* pointer to that structure.</span></span><br><span class="line"><span class="type">uintptr_t</span> rep_;</span><br></pre></td></tr></table></figure>

<p>这个 64-bit 长的成员做了一些空间优化：</p>
<ul>
<li>可能是 error code (<code>rep_ &gt;&gt; 2</code>)，称之为 <em>inlined representation</em></li>
<li>也可能代表某个堆内存的地址，类型是 <code>status_internal::StatusRep*</code></li>
</ul>
<p>第一种情况出现于没有 message 或者 payload 的情况下，按照目前实际的使用情况看，对应的基本是返回 Ok status 的场景，因为这是大多数情况下的结果</p>
<p>💡 即使是 non-ok status，也可以没有具体 message，这个时候也是第一种情况</p>
<p>在这个设计下 Status 本体的大小只有 8-byte，在函数间传递非常轻量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8-byte</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> size = <span class="built_in">sizeof</span>(absl::Status);</span><br></pre></td></tr></table></figure>

<h2 id="Ok-Status"><a href="#Ok-Status" class="headerlink" title="Ok Status"></a>Ok Status</h2><h3 id="1-absl-OkStatus"><a href="#1-absl-OkStatus" class="headerlink" title="1. absl::OkStatus()"></a>1. absl::OkStatus()</h3><p>最推荐的方式，也是大多数时候创建 ok status 的方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Status <span class="title">OkStatus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Status</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>内部就是直接调用 default constructor</p>
<h3 id="2-default-constructor"><a href="#2-default-constructor" class="headerlink" title="2. default constructor"></a>2. default constructor</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kOk == int(0)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Status::Status</span><span class="params">()</span> : rep_(CodeToInlinedRep(absl::StatusCode::kOk)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">uintptr_t</span> <span class="title">Status::CodeToInlinedRep</span><span class="params">(absl::StatusCode code)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(code) &lt;&lt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> absl::StatusCode <span class="title">Status::InlinedRepToCode</span><span class="params">(<span class="type">uintptr_t</span> rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ABSL_ASSERT</span>(<span class="built_in">IsInlined</span>(rep));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;absl::StatusCode&gt;(rep &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Status::IsInlined</span><span class="params">(<span class="type">uintptr_t</span> rep)</span> </span>&#123; <span class="keyword">return</span> (rep &amp; <span class="number">1</span>) != <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>inline rep 模式下，low bit（最低位）一定是1，这也是 <code>Status::IsInlined()</code> 的检查思路</li>
<li>inline-rep-to-code 的时候不用 -1，因为右移的时候会自动覆盖最低位</li>
</ul>
<h3 id="3-Status-absl-StatusCode-code-absl-string-view-msg"><a href="#3-Status-absl-StatusCode-code-absl-string-view-msg" class="headerlink" title="3. Status(absl::StatusCode code, absl::string_view msg)"></a>3. Status(absl::StatusCode code, absl::string_view msg)</h3><p>这个函数内部专门针对 <code>absl::StatusCode::kOk</code> 做了优化，如果用户真的用这个构造函数并且传了 <code>kOk</code> ，那么 <code>msg</code> 会被忽略</p>
<p>注意：<code>StatusCode::kOk == 0</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status::<span class="built_in">Status</span>(absl::StatusCode code, absl::string_view msg)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="built_in">CodeToInlinedRep</span>(code)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (code != absl::StatusCode::kOk &amp;&amp; !msg.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    rep_ = <span class="built_in">PointerToRep</span>(<span class="keyword">new</span> status_internal::<span class="built_in">StatusRep</span>(code, msg, <span class="literal">nullptr</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-推论：-Ok-status-的-msg-是事先硬编码的"><a href="#4-推论：-Ok-status-的-msg-是事先硬编码的" class="headerlink" title="4. 推论： Ok status 的 msg 是事先硬编码的"></a>4. 推论： Ok status 的 msg 是事先硬编码的</h3><p>直接看一下 <code>Status::ToString()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">Status::ToString</span><span class="params">(StatusToStringMode mode)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ok</span>() ? <span class="string">&quot;OK&quot;</span> : <span class="built_in">ToStringSlow</span>(mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Non-ok-Status"><a href="#Non-ok-Status" class="headerlink" title="Non-ok Status"></a>Non-ok Status</h2><p>以 InternalError 为例，一般创建 non-ok status 的做法是用 help function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = absl::<span class="built_in">InternalError</span>(<span class="string">&quot;something went wrong&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InternalError</span><span class="params">(absl::string_view message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Status</span>(absl::StatusCode::kInternal, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status::<span class="built_in">Status</span>(absl::StatusCode code, absl::string_view msg)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="built_in">CodeToInlinedRep</span>(code)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (code != absl::StatusCode::kOk &amp;&amp; !msg.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    rep_ = <span class="built_in">PointerToRep</span>(<span class="keyword">new</span> status_internal::<span class="built_in">StatusRep</span>(code, msg, <span class="literal">nullptr</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这次 <code>msg</code> 不为空，所以需要创建额外的 Rep 对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">rep_ = <span class="built_in">PointerToRep</span>(<span class="keyword">new</span> status_internal::<span class="built_in">StatusRep</span>(code, msg, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">Status::PointerToRep</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::Nonnull&lt;status_internal::StatusRep*&gt; rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(rep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> absl::Nonnull&lt;<span class="type">const</span> status_internal::StatusRep*&gt; <span class="title">Status::RepToPointer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uintptr_t</span> rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">IsInlined</span>(rep));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> status_internal::StatusRep*&gt;(rep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatusRep</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StatusRep</span>(absl::StatusCode code_arg, absl::string_view message_arg,</span><br><span class="line">            std::unique_ptr&lt;status_internal::Payloads&gt; payloads_arg)</span><br><span class="line">      : <span class="built_in">ref_</span>(<span class="type">int32_t</span>&#123;<span class="number">1</span>&#125;),</span><br><span class="line">        <span class="built_in">code_</span>(code_arg),</span><br><span class="line">        <span class="built_in">message_</span>(message_arg),</span><br><span class="line">        <span class="built_in">payloads_</span>(std::<span class="built_in">move</span>(payloads_arg)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">absl::StatusCode <span class="title">code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">message</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message_; &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::atomic&lt;<span class="type">int32_t</span>&gt; ref_;</span><br><span class="line">  absl::StatusCode code_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// As an internal implementation detail, we guarantee that if status.message()</span></span><br><span class="line">  <span class="comment">// is non-empty, then the resulting string_view is null terminated.</span></span><br><span class="line">  <span class="comment">// This is required to implement &#x27;StatusMessageAsCStr(...)&#x27;</span></span><br><span class="line">  std::string message_;</span><br><span class="line">  std::unique_ptr&lt;status_internal::Payloads&gt; payloads_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当 Status 需要表示 non-trivial case 时就需要动态创建 <code>StatusRep</code> 对象，这个对象保存：</p>
<ul>
<li>status code</li>
<li>message</li>
<li>payload</li>
<li>ref count，因为是新构造实例，所以计数自动设置为1</li>
</ul>
<p>并且当前实现版本，<code>rep_</code> 保存的就是这个堆上对象的指针</p>
<h3 id="1-Check-if-ok"><a href="#1-Check-if-ok" class="headerlink" title="1. Check if ok"></a>1. Check if ok</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ok = s.<span class="built_in">ok</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Status::ok</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rep_ == <span class="built_in">CodeToInlinedRep</span>(absl::StatusCode::kOk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有先获取 status code 再比较是否是 kOk，应该是为了性能考虑，毕竟这个调用是及其高频的</p>
<p>注意，为了保证 OK status 具有唯一的 rep 值，对于 OK status 的情况一定不能使用动态分配的 StatusRep 保存</p>
<p>这也是前面对于 OK status 会自动丢弃 message 的原因</p>
<h3 id="2-检查是否是某种错误"><a href="#2-检查是否是某种错误" class="headerlink" title="2. 检查是否是某种错误"></a>2. 检查是否是某种错误</h3><p>其实就是常用的 <code>absl::IsXXXX()</code></p>
<p>这类依然以 InternalError 为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInternal</span><span class="params">(<span class="type">const</span> Status&amp; status)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> status.<span class="built_in">code</span>() == absl::StatusCode::kInternal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然不是高频调用，就走传统一点的做法，获取 status code 进行比较</p>
<p>其他类别的也是类似的处理</p>
<h3 id="3-读取-code"><a href="#3-读取-code" class="headerlink" title="3. 读取 code"></a>3. 读取 code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> absl::StatusCode <span class="title">Status::code</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> status_internal::<span class="built_in">MapToLocalCode</span>(<span class="built_in">raw_code</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Status::raw_code</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsInlined</span>(rep_)) <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">InlinedRepToCode</span>(rep_));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">RepToPointer</span>(rep_)-&gt;<span class="built_in">code</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">absl::StatusCode <span class="title">StatusRep::code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert canonical code to a value known to this binary.</span></span><br><span class="line"><span class="function">absl::StatusCode <span class="title">MapToLocalCode</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  absl::StatusCode code = <span class="built_in">static_cast</span>&lt;absl::StatusCode&gt;(value);</span><br><span class="line">  <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kOk:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kCancelled:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kUnknown:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kInvalidArgument:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kDeadlineExceeded:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kNotFound:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kAlreadyExists:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kPermissionDenied:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kResourceExhausted:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kFailedPrecondition:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kAborted:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kOutOfRange:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kUnimplemented:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kInternal:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kUnavailable:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kDataLoss:</span><br><span class="line">    <span class="keyword">case</span> absl::StatusCode::kUnauthenticated:</span><br><span class="line">      <span class="keyword">return</span> code;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> absl::StatusCode::kUnknown;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 raw code 时需要考虑当前内部的 rep，分别获取</li>
<li>最后返回前还需要做一个是否当前实现可识别的 status code 检查；不认识的一律当作 unknown 返回</li>
</ul>
<p>这样一套下来确实不太适合作为 <code>ok()</code> 这样的高频调用的实现</p>
<h3 id="4-获取-message"><a href="#4-获取-message" class="headerlink" title="4. 获取 message"></a>4. 获取 message</h3><p>前面提到了 non-ok status 要存储 error message 的话就要额外在堆上创建一个 StatusRep 对象来存放 error message，所以这部分读取类似前面的 raw code，要从 StatusRep 上取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> absl::string_view <span class="title">Status::message</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">IsInlined</span>(rep_)</span><br><span class="line">             ? <span class="built_in">RepToPointer</span>(rep_)-&gt;<span class="built_in">message</span>()</span><br><span class="line">             : (<span class="built_in">IsMovedFrom</span>(rep_) ? absl::<span class="built_in">string_view</span>(kMovedFromString)</span><br><span class="line">                                  : absl::<span class="built_in">string_view</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MSVC 14.0 limitation requires the const.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> kMovedFromString[] =</span><br><span class="line">    <span class="string">&quot;Status accessed after move.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 = 0b10</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Status::IsMovedFrom</span><span class="params">(<span class="type">uintptr_t</span> rep)</span> </span>&#123; <span class="keyword">return</span> (rep &amp; <span class="number">2</span>) != <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>特地针对 moved status 做了处理，猜测是为了发现潜在 use-after-move 特意做的</p>
<p>💡 OkStatus 的 <code>message()</code> 也返回空字符串，这里需要注意和 <code>ToString()</code> 是不同的</p>
<h2 id="Move-语义处理"><a href="#Move-语义处理" class="headerlink" title="Move 语义处理"></a>Move 语义处理</h2><p>上面提到 Status 特意针对 move 做了一些处理，所以这里直接继续看它的 move ctor 和 move assignment</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The moved-from state is valid but unspecified.</span></span><br><span class="line"><span class="built_in">Status</span>(Status&amp;&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">Status&amp; <span class="keyword">operator</span>=(Status&amp;&amp;);</span><br></pre></td></tr></table></figure>

<ul>
<li>move ctor 是 noexcept 但是 move assignment 并不是</li>
</ul>
<h3 id="1-移动构造"><a href="#1-移动构造" class="headerlink" title="1. 移动构造"></a>1. 移动构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Status::Status</span><span class="params">(Status&amp;&amp; x)</span> <span class="keyword">noexcept</span> : Status(x.rep_) &#123;</span></span><br><span class="line">  x.rep_ = <span class="built_in">MovedFromRep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s in private access leve.</span></span><br><span class="line"><span class="comment">// Underlying constructor for status from a rep_.</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Status</span><span class="params">(<span class="type">uintptr_t</span> rep)</span> : rep_(rep) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status code is set to (kInternal | mark)</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">uintptr_t</span> <span class="title">Status::MovedFromRep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CodeToInlinedRep</span>(absl::StatusCode::kInternal) | <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用私有的构造直接让新对象使用 moved-from 对象的 rep</p>
<p>然后将 moved-from 对象的 rep 专门设置为一个带 bit-mark 的值</p>
<p>注意，这个 rep 仍然是满足 <code>IsInlined()</code> 的，因为它的最低位是 1；所以这里的 moved-from bit mark 是次低位</p>
<p>对 Status 对象来说，只要是 inlined rep，就说明没有关联堆上分配的 StatusRep，自身析构的时候不需要做任何额外的操作</p>
<h3 id="2-移动赋值"><a href="#2-移动赋值" class="headerlink" title="2. 移动赋值"></a>2. 移动赋值</h3><p>移动赋值需要处理原对象，所以会麻烦一些</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Status&amp; Status::<span class="keyword">operator</span>=(Status&amp;&amp; x) &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> old_rep = rep_;</span><br><span class="line">  <span class="keyword">if</span> (x.rep_ != old_rep) &#123;</span><br><span class="line">    rep_ = x.rep_;</span><br><span class="line">    x.rep_ = <span class="built_in">MovedFromRep</span>();</span><br><span class="line">    <span class="built_in">Unref</span>(old_rep);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Status::Unref</span><span class="params">(<span class="type">uintptr_t</span> rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsInlined</span>(rep)) <span class="built_in">RepToPointer</span>(rep)-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x.rep_ != old_rep</code> 成立有两种情况</p>
<ol>
<li>两个 status 都是 inlined rep，这种是 trivial case，不需要做任何事</li>
<li>两个 status 都是 non-inlined rep，并且内部都指向同一个堆上的 StatusRep；这种情况也不需要做任何操作</li>
</ol>
<p>因为堆上的 StatusRep 是自带引用计数的，所以移动后，原来的 StatusRep 的计数需要自减</p>
<p>💡 其实严格来说移动赋值这里也是可以实现成 noexcept 的，<code>Unref()</code> 并未涉及可能抛出异常的操作，并且后文可以发现析构函数直接就调用这个</p>
<h2 id="Ref-counted-StatusRep"><a href="#Ref-counted-StatusRep" class="headerlink" title="Ref-counted StatusRep"></a>Ref-counted StatusRep</h2><p>为了 non-inlined rep 情况下 Status 对象也能够<strong>轻量高效的传递</strong>，<code>StatusRep</code> 设计上是 ref-counted，并且考虑到了不同的 Status 对象内部引用同一个 <code>StatusRep</code> 的情况，这个 ref-counted 是可以做到 thread-safe 的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Status::Ref</span><span class="params">(<span class="type">uintptr_t</span> rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsInlined</span>(rep)) <span class="built_in">RepToPointer</span>(rep)-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Status::Unref</span><span class="params">(<span class="type">uintptr_t</span> rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsInlined</span>(rep)) <span class="built_in">RepToPointer</span>(rep)-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Internal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatusRep</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">mutable</span> std::atomic&lt;<span class="type">int32_t</span>&gt; ref_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ref and unref are const to allow access through a const pointer, and are</span></span><br><span class="line"><span class="comment">// used during copying operations.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StatusRep::Ref</span><span class="params">()</span> <span class="type">const</span> </span>&#123; ref_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StatusRep::Unref</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Fast path: if ref==1, there is no need for a RefCountDec (since</span></span><br><span class="line">  <span class="comment">// this is the only reference and therefore no other thread is</span></span><br><span class="line">  <span class="comment">// allowed to be mucking with r).</span></span><br><span class="line">  <span class="keyword">if</span> (ref_.<span class="built_in">load</span>(std::memory_order_acquire) == <span class="number">1</span> ||</span><br><span class="line">      ref_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acq_rel) - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Status</code> 的 <code>Ref()</code>&#x2F;<code>Unref()</code> 是 static 函数</p>
<p><code>StatusRep::Unref()</code> 的 fast path 优化的原因是：</p>
<ul>
<li>虽然引用计数是 thread-safe 的，但是 Status 对象本身不是 thread-safe</li>
<li>所以在遵循 thread-safe access 前提下，如果当前 Status 的 rep reference count 是1，则说明当前的 Status 是唯一一个 refer 这个 StatusRep 的对象，因为多个线程同时访问同一个 Status 本身就是 non-thread-safe 的</li>
</ul>
<p>计数减到0之后的 delete this 是侵入式引用计数的老操作了</p>
<h2 id="Copy-语义操作"><a href="#Copy-语义操作" class="headerlink" title="Copy 语义操作"></a>Copy 语义操作</h2><p>Status 语义上呈现值语义，所以肯定是要支持 copy semantics 的</p>
<p>Copy 的处理和 Move 非常像，最大的区别在于源对象需要继续保持，同时如果是 non-inlined rep，计数需要自增：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Status::Status</span><span class="params">(<span class="type">const</span> Status&amp; x)</span> : Status(x.rep_) &#123;</span> <span class="built_in">Ref</span>(rep_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Status&amp; Status::<span class="keyword">operator</span>=(<span class="type">const</span> Status&amp; x) &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> old_rep = rep_;</span><br><span class="line">  <span class="keyword">if</span> (x.rep_ != old_rep) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(x.rep_);</span><br><span class="line">    rep_ = x.rep_;</span><br><span class="line">    <span class="built_in">Unref</span>(old_rep);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>Status::Ref()</code> 和 <code>Status::Unref()</code> 内部会透明地处理 inlined rep 的情况，所以拷贝和移动的实现上非常干净</p>
<h2 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h2><p>分析完 ref counting 部分之后这里就比较简单</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Status::~<span class="built_in">Status</span>() &#123; <span class="built_in">Unref</span>(rep_); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>Status 重载了 <code>operator&lt;&lt;()</code> 所以可以直接往 stream 输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Status&amp; x) &#123;</span><br><span class="line">  os &lt;&lt; x.<span class="built_in">ToString</span>(StatusToStringMode::kWithEverything);</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-ToString"><a href="#1-ToString" class="headerlink" title="1. ToString"></a>1. ToString</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">Status::ToString</span><span class="params">(StatusToStringMode mode)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ok</span>() ? <span class="string">&quot;OK&quot;</span> : <span class="built_in">ToStringSlow</span>(rep_, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Status::ToStringSlow</span><span class="params">(<span class="type">uintptr_t</span> rep, StatusToStringMode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsInlined</span>(rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="built_in">StrCat</span>(absl::<span class="built_in">StatusCodeToString</span>(<span class="built_in">InlinedRepToCode</span>(rep)), <span class="string">&quot;: &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RepToPointer</span>(rep)-&gt;<span class="built_in">ToString</span>(mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">StatusCodeToString</span><span class="params">(StatusCode code)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kOk:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kCancelled:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CANCELLED&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kUnknown:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kInvalidArgument:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;INVALID_ARGUMENT&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kDeadlineExceeded:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;DEADLINE_EXCEEDED&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kNotFound:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;NOT_FOUND&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kAlreadyExists:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ALREADY_EXISTS&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kPermissionDenied:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;PERMISSION_DENIED&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kUnauthenticated:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;UNAUTHENTICATED&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kResourceExhausted:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;RESOURCE_EXHAUSTED&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kFailedPrecondition:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;FAILED_PRECONDITION&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kAborted:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ABORTED&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kOutOfRange:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;OUT_OF_RANGE&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kUnimplemented:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;UNIMPLEMENTED&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kInternal:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;INTERNAL&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kUnavailable:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;UNAVAILABLE&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> StatusCode::kDataLoss:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;DATA_LOSS&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">StatusRep::ToString</span><span class="params">(StatusToStringMode mode)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  std::string text;</span><br><span class="line">  absl::<span class="built_in">StrAppend</span>(&amp;text, absl::<span class="built_in">StatusCodeToString</span>(<span class="built_in">code</span>()), <span class="string">&quot;: &quot;</span>, <span class="built_in">message</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> with_payload = (mode &amp; StatusToStringMode::kWithPayload) ==</span><br><span class="line">                            StatusToStringMode::kWithPayload;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (with_payload) &#123;</span><br><span class="line">    status_internal::StatusPayloadPrinter printer =</span><br><span class="line">        status_internal::<span class="built_in">GetStatusPayloadPrinter</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ForEachPayload</span>([&amp;](absl::string_view type_url,</span><br><span class="line">                             <span class="type">const</span> absl::Cord&amp; payload) &#123;</span><br><span class="line">      absl::optional&lt;std::string&gt; result;</span><br><span class="line">      <span class="keyword">if</span> (printer) result = <span class="built_in">printer</span>(type_url, payload);</span><br><span class="line">      absl::<span class="built_in">StrAppend</span>(</span><br><span class="line">          &amp;text, <span class="string">&quot; [&quot;</span>, type_url, <span class="string">&quot;=&#x27;&quot;</span>,</span><br><span class="line">          result.<span class="built_in">has_value</span>() ? *result : absl::<span class="built_in">CHexEscape</span>(std::<span class="built_in">string</span>(payload)),</span><br><span class="line">          <span class="string">&quot;&#x27;]&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>OK Status 会有 short cut, 这个前面也分析过了</li>
<li>如果是 Inlined rep 则不管是不是 ok status，都没有 message，所以只需要返回 status code 对应的文字描述即可，这里 <code>StatusCodeToString()</code> 没有用额外的数据结构，而是直接用 switch..case 打表</li>
<li>有 message 则一定是 non-inlined rep，那就要把 status code 拼上 message</li>
<li>如果有额外的 payload（存储在 StatusRep 上，具体后文分析）则如果 mode 需要 stringify payload 则要一并处理</li>
</ol>
<h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>这个功能应该是 Google 内部的需求吧，起码我自己在日常中几乎没用过…</p>
<p>Abseil-cpp 要求 payload 需要以 <code>[key, value]</code> pair 的方式管理，并且</p>
<ul>
<li>key 要符合 URL 的格式规范</li>
<li>value 的类型是 <code>absl::Cord</code>，一个转为 large string data 优化的 string-like type</li>
</ul>
<h3 id="1-Set-payload"><a href="#1-Set-payload" class="headerlink" title="1. Set payload"></a>1. Set payload</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Status::SetPayload</span><span class="params">(absl::string_view type_url, absl::Cord payload)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  status_internal::StatusRep* rep = <span class="built_in">PrepareToModify</span>(rep_);</span><br><span class="line">  rep-&gt;<span class="built_in">SetPayload</span>(type_url, std::<span class="built_in">move</span>(payload));</span><br><span class="line">  rep_ = <span class="built_in">PointerToRep</span>(rep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function">absl::Nonnull&lt;status_internal::StatusRep*&gt; <span class="title">Status::PrepareToModify</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uintptr_t</span> rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsInlined</span>(rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> status_internal::<span class="built_in">StatusRep</span>(<span class="built_in">InlinedRepToCode</span>(rep),</span><br><span class="line">                                          absl::<span class="built_in">string_view</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RepToPointer</span>(rep)-&gt;<span class="built_in">CloneAndUnref</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">absl::Nonnull&lt;StatusRep*&gt; <span class="title">StatusRep::CloneAndUnref</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Optimization: no need to create a clone if we already have a refcount of 1.</span></span><br><span class="line">  <span class="keyword">if</span> (ref_.<span class="built_in">load</span>(std::memory_order_acquire) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// All StatusRep instances are heap allocated and mutable, therefore this</span></span><br><span class="line">    <span class="comment">// const_cast will never cast away const from a stack instance.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// CloneAndUnref is the only method that doesn&#x27;t involve an external cast to</span></span><br><span class="line">    <span class="comment">// get a mutable StatusRep* from the uintptr_t rep stored in Status.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;StatusRep*&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;status_internal::Payloads&gt; payloads;</span><br><span class="line">  <span class="keyword">if</span> (payloads_) &#123;</span><br><span class="line">    payloads = absl::<span class="built_in">make_unique</span>&lt;status_internal::Payloads&gt;(*payloads_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span>* new_rep = <span class="keyword">new</span> <span class="built_in">StatusRep</span>(code_, message_, std::<span class="built_in">move</span>(payloads));</span><br><span class="line">  <span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">return</span> new_rep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;status_internal::Payloads&gt; StatusRep::payloads_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StatusRep::SetPayload</span><span class="params">(absl::string_view type_url, absl::Cord payload)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (payloads_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    payloads_ = absl::<span class="built_in">make_unique</span>&lt;status_internal::Payloads&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  absl::optional&lt;<span class="type">size_t</span>&gt; index =</span><br><span class="line">      status_internal::<span class="built_in">FindPayloadIndexByUrl</span>(payloads_.<span class="built_in">get</span>(), type_url);</span><br><span class="line">  <span class="keyword">if</span> (index.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    (*payloads_)[index.<span class="built_in">value</span>()].payload = std::<span class="built_in">move</span>(payload);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  payloads_-&gt;<span class="built_in">push_back</span>(&#123;std::<span class="built_in">string</span>(type_url), std::<span class="built_in">move</span>(payload)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Container for status payloads.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">  std::string type_url;</span><br><span class="line">  absl::Cord payload;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Payloads = absl::InlinedVector&lt;Payload, <span class="number">1</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>OkStatus 是不应该携带 payload 的，所以 set 直接返回</p>
<p>Non-ok status 需要区分是不是 inlined rep，这里的核心点是这样：</p>
<ul>
<li>StatusRep 可能被多个 Non-ok Status 共享，而 set payload 会需要修改到 StatusRep 内部状态，所以这本只是一个 copy-on-write 的操作</li>
<li>如果是 inlined，则没有共享的 StatusRep，所以只需要创建一个全新的 StatusRep 就行</li>
<li>小优化的目的也是如此：考虑到大多数时候一个 StatusRep 不会被多个 Status 共享，所以单独判断计数来做 short cut 还是有优势的</li>
</ul>
<p><code>absl::InlinedVector</code> 是 absl 的类 SSO 的 vector 优化版本，这里 unique_ptr 来保存 inlined vector 也算一个优化：因为大多数时候 status 是没有 payload 的，所以不希望白白浪费内存，所以这部分利用 unique_ptr 仅在需要的时候存储。</p>
<p>而如果需要 payload 了，大多数时候都只有一个（考虑一下 <code>absl::Cord</code> 能存大字符串），所以用 inlined vector 还能避免无谓的动态内存分配</p>
<h3 id="2-Get-payload"><a href="#2-Get-payload" class="headerlink" title="2. Get payload"></a>2. Get payload</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> absl::optional&lt;absl::Cord&gt; <span class="title">Status::GetPayload</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::string_view type_url)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsInlined</span>(rep_)) <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RepToPointer</span>(rep_)-&gt;<span class="built_in">GetPayload</span>(type_url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">absl::optional&lt;absl::Cord&gt; <span class="title">StatusRep::GetPayload</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::string_view type_url)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  absl::optional&lt;<span class="type">size_t</span>&gt; index =</span><br><span class="line">      status_internal::<span class="built_in">FindPayloadIndexByUrl</span>(payloads_.<span class="built_in">get</span>(), type_url);</span><br><span class="line">  <span class="keyword">if</span> (index.<span class="built_in">has_value</span>()) <span class="keyword">return</span> (*payloads_)[index.<span class="built_in">value</span>()].payload;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Get payload 不涉及修改，所以很直接的实现，没啥好说的</p>
<h3 id="3-Erase-payload"><a href="#3-Erase-payload" class="headerlink" title="3. Erase payload"></a>3. Erase payload</h3><p>erase 也是一个写操作，所以也需要处理 copy-on-write</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Status::ErasePayload</span><span class="params">(absl::string_view type_url)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsInlined</span>(rep_)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  status_internal::StatusRep* rep = <span class="built_in">PrepareToModify</span>(rep_);</span><br><span class="line">  <span class="keyword">auto</span> res = rep-&gt;<span class="built_in">ErasePayload</span>(type_url);</span><br><span class="line">  rep_ = res.new_rep;</span><br><span class="line">  <span class="keyword">return</span> res.erased;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function">StatusRep::EraseResult <span class="title">StatusRep::ErasePayload</span><span class="params">(absl::string_view type_url)</span> </span>&#123;</span><br><span class="line">  absl::optional&lt;<span class="type">size_t</span>&gt; index =</span><br><span class="line">      status_internal::<span class="built_in">FindPayloadIndexByUrl</span>(payloads_.<span class="built_in">get</span>(), type_url);</span><br><span class="line">  <span class="keyword">if</span> (!index.<span class="built_in">has_value</span>()) <span class="keyword">return</span> &#123;<span class="literal">false</span>, Status::<span class="built_in">PointerToRep</span>(<span class="keyword">this</span>)&#125;;</span><br><span class="line">  payloads_-&gt;<span class="built_in">erase</span>(payloads_-&gt;<span class="built_in">begin</span>() + index.<span class="built_in">value</span>());</span><br><span class="line">  <span class="keyword">if</span> (payloads_-&gt;<span class="built_in">empty</span>() &amp;&amp; message_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// Special case: If this can be represented inlined, it MUST be inlined</span></span><br><span class="line">    <span class="comment">// (== depends on this behavior).</span></span><br><span class="line">    EraseResult result = &#123;<span class="literal">true</span>, Status::<span class="built_in">CodeToInlinedRep</span>(code_)&#125;;</span><br><span class="line">    <span class="built_in">Unref</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="literal">true</span>, Status::<span class="built_in">PointerToRep</span>(<span class="keyword">this</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Erase 部分有个trick：如果 erase payload 之后这个 StatusRep 全空了，即 status 可以被 inlined rep，那么就把他 inlined rep；否则前面的 inlined&#x2F;non-inlined 的前提就不一致了。</p>
<h3 id="4-Visit-payloads"><a href="#4-Visit-payloads" class="headerlink" title="4. Visit payloads"></a>4. Visit payloads</h3><p>这部分比较有意思</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Status::ForEachPayload()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Iterates over the stored payloads and calls the</span></span><br><span class="line"><span class="comment">// `visitor(type_key, payload)` callable for each one.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The order of calls to `visitor()` is not specified and may change at</span></span><br><span class="line"><span class="comment">// any time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Any mutation on the same &#x27;absl::Status&#x27; object during visitation is</span></span><br><span class="line"><span class="comment">// forbidden and could result in undefined behavior.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Status::ForEachPayload</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::FunctionRef&lt;<span class="type">void</span>(absl::string_view, <span class="type">const</span> absl::Cord&amp;)&gt; visitor)</span></span></span><br><span class="line"><span class="function">    <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsInlined</span>(rep_)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">RepToPointer</span>(rep_)-&gt;<span class="built_in">ForEachPayload</span>(visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StatusRep::ForEachPayload</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::FunctionRef&lt;<span class="type">void</span>(absl::string_view, <span class="type">const</span> absl::Cord&amp;)&gt; visitor)</span></span></span><br><span class="line"><span class="function">    <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span>* payloads = payloads_.<span class="built_in">get</span>()) &#123;</span><br><span class="line">    <span class="type">bool</span> in_reverse =</span><br><span class="line">        payloads-&gt;<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(payloads) % <span class="number">13</span> &gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; payloads-&gt;<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; elem =</span><br><span class="line">          (*payloads)[in_reverse ? payloads-&gt;<span class="built_in">size</span>() - <span class="number">1</span> - index : index];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">      <span class="built_in">visitor</span>(elem.type_url, elem.payload);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="comment">// In debug mode invalidate the type url to prevent users from relying on</span></span><br><span class="line">      <span class="comment">// this string lifetime.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// NOLINTNEXTLINE intentional extra conversion to force temporary.</span></span><br><span class="line">      <span class="built_in">visitor</span>(std::<span class="built_in">string</span>(elem.type_url), elem.payload);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// NDEBUG</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以把 <code>absl::FunctionRef&lt;&gt;</code> 当作 <code>const std::function&lt;&gt;&amp;</code> 等价物，这是 absl 自己做的一个优化</p>
<p>其次函数 contract 中说如果有多个 payloads，那么他们的遍历顺序是不确定的，并且为了贯彻这个行为，遍历的时候做了一个很有意思的概率处理：有一定概率是反向遍历的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(payloads) % <span class="number">13</span> &gt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>这个 trick 感觉可以借鉴一下，开销比用 rand 会低很多</p>
</div><div class="tags"><a href="/tags/cpp/"><i class="fa fa-tag"></i>cpp</a><a href="/tags/abseil/"><i class="fa fa-tag"></i>abseil</a><a href="/tags/absl-Status/"><i class="fa fa-tag"></i>absl::Status</a></div><div class="post-nav"><a class="pre" href="/2024/05/13/weekly-2024-may-2/">一周杂记 in Week 2 May 2024</a><a class="next" href="/2024/05/06/weekly-2024-may-1/">一周杂记 in Week 1 May 2024</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://kingsamchen.github.io/2024/05/12/src-study-abseil-status-status/';
    this.page.identifier = '2024/05/12/src-study-abseil-status-status/';
    this.page.title = 'abseil status/status 源码分析';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//kingsamchen-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//kingsamchen-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://kingsamchen-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://kingsamchen.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CODE-LIFE/">CODE-LIFE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PROGRAMMING/">PROGRAMMING</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/14/weekly-2025-july-2/">一周杂记 in Week 2 July 2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/07/07/weekly-2025-july-1/">一周杂记 in Week 1 July 2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/30/weekly-2025-june-4/">一周杂记 in Week 4 June 2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/23/weekly-2025-june-3/">一周杂记 in Week 3 June 2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/16/weekly-2025-june-2/">一周杂记 in Week 2 June 2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/10/display-proxy-status-on-shell-prompt/">Display Proxy Status on Shell Prompt</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/09/weekly-2025-june-1/">一周杂记 in Week 1 June 2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/03/weekly-2025-may-5/">一周杂记 in Week 5 May 2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/31/cxx-20-date-time-samples/">C++20 Calendar Datetime Quick Intro</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/25/weekly-2025-may-4/">一周杂记 in Week 4 May 2025</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/rant/" style="font-size: 15px;">rant</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/cpp/" style="font-size: 15px;">cpp</a> <a href="/tags/memory-fence/" style="font-size: 15px;">memory fence</a> <a href="/tags/memory-ordering/" style="font-size: 15px;">memory ordering</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/multiple-instance/" style="font-size: 15px;">multiple instance</a> <a href="/tags/crash/" style="font-size: 15px;">crash</a> <a href="/tags/breakpad/" style="font-size: 15px;">breakpad</a> <a href="/tags/exception/" style="font-size: 15px;">exception</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/enum/" style="font-size: 15px;">enum</a> <a href="/tags/flag/" style="font-size: 15px;">flag</a> <a href="/tags/bitwise%EF%BC%8C-SFINAE/" style="font-size: 15px;">bitwise， SFINAE</a> <a href="/tags/KBase/" style="font-size: 15px;">KBase</a> <a href="/tags/command-line/" style="font-size: 15px;">command-line</a> <a href="/tags/abstraction/" style="font-size: 15px;">abstraction</a> <a href="/tags/windows/" style="font-size: 15px;">windows</a> <a href="/tags/design/" style="font-size: 15px;">design</a> <a href="/tags/environment/" style="font-size: 15px;">environment</a> <a href="/tags/anvil/" style="font-size: 15px;">anvil</a> <a href="/tags/cmake/" style="font-size: 15px;">cmake</a> <a href="/tags/project-management/" style="font-size: 15px;">project management</a> <a href="/tags/C-17/" style="font-size: 15px;">C++ 17</a> <a href="/tags/string-view/" style="font-size: 15px;">string_view</a> <a href="/tags/tokenizer/" style="font-size: 15px;">tokenizer</a> <a href="/tags/atoi/" style="font-size: 15px;">atoi</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/asio/" style="font-size: 15px;">asio</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/cfs/" style="font-size: 15px;">cfs</a> <a href="/tags/non-capturing-lambda/" style="font-size: 15px;">non-capturing lambda</a> <a href="/tags/function-pointer/" style="font-size: 15px;">function pointer</a> <a href="/tags/obs-studio/" style="font-size: 15px;">obs-studio</a> <a href="/tags/inno-setup/" style="font-size: 15px;">inno setup</a> <a href="/tags/installer/" style="font-size: 15px;">installer</a> <a href="/tags/%E6%A2%AF%E5%AD%90/" style="font-size: 15px;">梯子</a> <a href="/tags/shadowsocks/" style="font-size: 15px;">shadowsocks</a> <a href="/tags/trojan/" style="font-size: 15px;">trojan</a> <a href="/tags/socat/" style="font-size: 15px;">socat</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Unix/" style="font-size: 15px;">Unix</a> <a href="/tags/signal/" style="font-size: 15px;">signal</a> <a href="/tags/signalfd/" style="font-size: 15px;">signalfd</a> <a href="/tags/self-pipe-trick/" style="font-size: 15px;">self-pipe trick</a> <a href="/tags/cant/" style="font-size: 15px;">cant</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/HandlerThread/" style="font-size: 15px;">HandlerThread</a> <a href="/tags/Looper/" style="font-size: 15px;">Looper</a> <a href="/tags/Handler/" style="font-size: 15px;">Handler</a> <a href="/tags/MessageLoop/" style="font-size: 15px;">MessageLoop</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/proxy/" style="font-size: 15px;">proxy</a> <a href="/tags/thread-pool/" style="font-size: 15px;">thread-pool</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/urlfetcher/" style="font-size: 15px;">urlfetcher</a> <a href="/tags/wireshark/" style="font-size: 15px;">wireshark</a> <a href="/tags/localhost/" style="font-size: 15px;">localhost</a> <a href="/tags/SFINAE/" style="font-size: 15px;">SFINAE</a> <a href="/tags/template/" style="font-size: 15px;">template</a> <a href="/tags/source-internals/" style="font-size: 15px;">source internals</a> <a href="/tags/message-loop/" style="font-size: 15px;">message-loop</a> <a href="/tags/shared-ptr/" style="font-size: 15px;">shared_ptr</a> <a href="/tags/type-injection/" style="font-size: 15px;">type injection</a> <a href="/tags/visual-studio/" style="font-size: 15px;">visual studio</a> <a href="/tags/libx264/" style="font-size: 15px;">libx264</a> <a href="/tags/vcpkg/" style="font-size: 15px;">vcpkg</a> <a href="/tags/tag-dispatching/" style="font-size: 15px;">tag dispatching</a> <a href="/tags/shared-ptr-internals/" style="font-size: 15px;">shared_ptr-internals</a> <a href="/tags/source-code-study/" style="font-size: 15px;">source-code-study</a> <a href="/tags/weak-ptr/" style="font-size: 15px;">weak_ptr</a> <a href="/tags/base-lib/" style="font-size: 15px;">base lib</a> <a href="/tags/boost/" style="font-size: 15px;">boost</a> <a href="/tags/datetime/" style="font-size: 15px;">datetime</a> <a href="/tags/chrono/" style="font-size: 15px;">chrono</a> <a href="/tags/libstdc/" style="font-size: 15px;">libstdc++</a> <a href="/tags/gcc/" style="font-size: 15px;">gcc</a> <a href="/tags/clang/" style="font-size: 15px;">clang</a> <a href="/tags/sfinae/" style="font-size: 15px;">sfinae</a> <a href="/tags/buddy-allocator/" style="font-size: 15px;">buddy-allocator</a> <a href="/tags/algorithms/" style="font-size: 15px;">algorithms</a> <a href="/tags/google-breakpad/" style="font-size: 15px;">google-breakpad</a> <a href="/tags/invalid-paramter/" style="font-size: 15px;">invalid paramter</a> <a href="/tags/operator/" style="font-size: 15px;">operator[]</a> <a href="/tags/owner-semantics/" style="font-size: 15px;">owner semantics</a> <a href="/tags/view-semantics/" style="font-size: 15px;">view semantics</a> <a href="/tags/error-handling/" style="font-size: 15px;">error handling</a> <a href="/tags/msvc/" style="font-size: 15px;">msvc</a> <a href="/tags/ebo/" style="font-size: 15px;">ebo</a> <a href="/tags/multiple-inheritance/" style="font-size: 15px;">multiple inheritance</a> <a href="/tags/haskell/" style="font-size: 15px;">haskell</a> <a href="/tags/infix-operator/" style="font-size: 15px;">infix operator</a> <a href="/tags/Visual-Studio/" style="font-size: 15px;">Visual Studio</a> <a href="/tags/debugger/" style="font-size: 15px;">debugger</a> <a href="/tags/UTF-8/" style="font-size: 15px;">UTF-8</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mint/" style="font-size: 15px;">mint</a> <a href="/tags/%E7%A3%81%E7%9B%98/" style="font-size: 15px;">磁盘</a> <a href="/tags/%E6%89%A9%E5%AE%B9/" style="font-size: 15px;">扩容</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.daozhihun.com/" title="刀之魂 | 大木老师成长日记" target="_blank">刀之魂 | 大木老师成长日记</a><ul></ul><a href="https://runzhen.github.io/" title="管理员 | 硅谷谈撸管" target="_blank">管理员 | 硅谷谈撸管</a><ul></ul><a href="https://blog.chichou.me/" title="ChiChou | 首席安全地球仪切图总奸" target="_blank">ChiChou | 首席安全地球仪切图总奸</a><ul></ul><a href="https://fleurer.github.io/" title="Fleurer-lee | F叔的读书笔记（大量干货）" target="_blank">Fleurer-lee | F叔的读书笔记（大量干货）</a><ul></ul><a href="https://vizee.org/" title="Vizee | 即将走上人生巅峰推萝莉的章总" target="_blank">Vizee | 即将走上人生巅峰推萝莉的章总</a><ul></ul><a href="https://blog.thecjw.me/" title="TheCJW | 爱弹棉花的小伟" target="_blank">TheCJW | 爱弹棉花的小伟</a><ul></ul><a href="https://newbiecoder.0ginr.com/blog/" title="Newbie Coder | 萌萌哒的炉子" target="_blank">Newbie Coder | 萌萌哒的炉子</a><ul></ul><a href="https://frankpie.github.io/" title="裴草莓 | 愤怒的老司机" target="_blank">裴草莓 | 愤怒的老司机</a><ul></ul><a href="https://beanbee.me/" title="陈老师 | Beanbee.Max" target="_blank">陈老师 | Beanbee.Max</a><ul></ul><a href="https://sunus.me/" title="Sunus | 李师傅食品厂CEO" target="_blank">Sunus | 李师傅食品厂CEO</a><ul></ul><a href="http://www.tolower.net/" title="Lower | 喊大木大哥的小弟" target="_blank">Lower | 喊大木大哥的小弟</a><ul></ul><a href="http://mrljdx.com/" title="Mrljdx | 大保健老司机" target="_blank">Mrljdx | 大保健老司机</a><ul></ul><a href="https://www.mydavelv.net/" title="Davelv | 江湖人称大尾驴" target="_blank">Davelv | 江湖人称大尾驴</a></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//kingsamchen-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">KC的废墟堆.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>