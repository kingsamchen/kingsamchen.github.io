<!DOCTYPE html>
<html lang="default">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gone with the ruins"/>













  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://kingsamchen.github.io/page/7/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  









    <title> KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/03/compile-libx264-with-asm-optimization-with-vcpkg/">利用 vcpkg 编译带汇编优化的 libx264</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-03
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>使用 vcpkg 编译 libx264 有一个很重要的原因：可以获得 PDB，而且构建流程被大大精简了。</p>
<p>但是这里有一个坑：vcpkg 上的 libx264 模块编译默认是开启了 <code>--disable-asm</code>，意味着构建之后的二进制不会使用 SIMD 指令集，所以性能上会有很大的问题。</p>
<p>研究了一番之后找到了开启汇编优化的方案。</p>
<ol>
<li><p>从官网下载并安装 nasm-2.13</p>
<p> vcpkg 上通过 acquire-program 提供的 nasm 只有 2.12；而编译 vcpkg 上提供的 libx264-152 需要 nasm-2.13</p>
</li>
<li><p>编辑 libx264 的 portfile.cmake 文件</p>
<p> 在 set bash 的后面加一行</p>
 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;PATH&#125; <span class="string">"c:/Programs/NASM/;$ENV&#123;PATH&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p> 这里注意替换你的真实安装目录</p>
<p> 然后去掉构建参数中的 <code>--disable-asm</code></p>
</li>
</ol>
<p>如果还有地方出错，记得根据提示查日志！</p>
<p>开启汇编优化后生成的二进制会略大，大概 900 多 KB</p>
<p>最后赞扬一下微软出品的 vcpkg，真是解决了 Windows 下编译一众开源软件的痛点。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/01/monthly-read-posts-in-mar-2018/">Monthly Read Posts in Mar 2018</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-01
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><a href="http://akumuli.org/akumuli/2015/03/19/sequencer/" target="_blank" rel="noopener">Sorting, caching and concurrency</a></p>
<p>通过引入基于时间的 sliding window 来标记并剔除（大概率）由错误产生的数据；并且可以利用 SW 来 schedule 数据什么时候从内存持久化到磁盘。</p>
<p>Patience sort 是 merge-sort 的一种变体，适合对 slightly unordered data 进行排序，最坏情况下退化为 merge-sort。</p>
<p>实现 optimistic locking 来避免使用 reader-writer locks，进而防止写饥饿。</p>
<blockquote>
<p>引入一个原子的 sequence-number，初始状态为0；并且</p>
<ul>
<li>merge 操作开始时，sequence-number 自增</li>
<li>merge 操作结束时，sequence-number 同样自增<br>于是利用 sequence-number 的奇偶性来区分某个操作是否结束</li>
</ul>
<p>如果写操作开始但是未完成，则读操作进行退避&amp;重试。</p>
</blockquote>
<p>感觉作者这么做应该是结合了业务的上下文；这个 optimistic locking 的策略至少有这么几个前提：</p>
<ol>
<li>写操作很重要，不能有明显的延迟</li>
<li>写操作不会太慢，至少不会导致读操作的延迟超过无法承受的范围</li>
<li>平台提供的 reader-writer locks 对 writer starvation 的防治策略做的不够好</li>
</ol>
<hr>
<p><a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/" target="_blank" rel="noopener">An Introduction to Lock-Free Programming</a></p>
<p>非常赞的 Lock-free 入门文章。</p>
<p>覆盖了 concepts, CAS operations, memory ordering &amp; memory models</p>
<p>注：作者 preshing 是个 concurrency programming 领域的大触</p>
<hr>
<p><a href="https://getpocket.com/a/read/994738352" target="_blank" rel="noopener">Gentle Introduction to Lockless Concurrency</a></p>
<p>同样也是一篇 lock-free 的入门文章，但是这这篇文章比起上一篇就差太多了，明显不是一个层次的。</p>
<p>这篇是基于 Java 来谈 lockless，涉及的点明显局限在了语言自身，没有 preshing 那种站在 bare-metal 角度的犀利。</p>
<p>注：原文找不到了，大概率被作者自己删了，因此只有 pocket 的备份</p>
<hr>
<p><a href="https://www.brianstorti.com/the-actor-model/" target="_blank" rel="noopener">The actor model in 10 minutes</a></p>
<p>一篇非常赞的 actor model 的介绍文章。</p>
<p>直接开篇就把模型的本质是 actor，以及 actor 的核心（primitive unit for computation &amp; message passing）讲明了。</p>
<p>然后延伸到 fault tolerance 和 distribution 上的优势。</p>
<p>内容比 <em>7 Concurrency Models in 7 Weeks</em> 要好多了，讽刺的是这本书还是这篇文章的 reference 之一。</p>
<hr>
<p><a href="https://www.youtube.com/watch?v=_fu0gx-xseY" target="_blank" rel="noopener">CppCon 2015: Gor Nishanov “C++ Coroutines - a negative overhead abstraction”</a></p>
<p>总结起来就是：</p>
<ul>
<li>我们其实很早就开始应用 coroutines 了</li>
<li>Concurrency TS 里提供的 CPS 也不是万能药</li>
<li>Coroutine is good, and We want coroutines!</li>
</ul>
<hr>
<p><a href="https://www.youtube.com/watch?v=mPxIegd9J3w" target="_blank" rel="noopener">CppCon 2015: Artur Laksberg “Concurrency TS Editor’s Report”</a></p>
<p>Brief introduction to concurrency ts.</p>
<p>涵盖了三点：</p>
<ul>
<li>better std::future (with continutation &amp; async/await)</li>
<li>latch &amp; barrier</li>
<li>atomic shared_ptr</li>
</ul>
<hr>
<p><a href="https://www.youtube.com/watch?v=fZjYCQ8dzTc" target="_blank" rel="noopener">CppCon 2015: Scott Schurr “constexpr: Introduction”</a><br><a href="https://www.youtube.com/watch?v=qO-9yiAOQqc" target="_blank" rel="noopener">CppCon 2015: Scott Schurr “constexpr: Applications”</a></p>
<p>第一篇是 <code>constexpr</code> 入门介绍。</p>
<p>演讲者挺有意思。另外最后面利用 unresolved symbol 来 force as compile time error 有点意思</p>
<p>第二篇，重点来了，干货十足，compile-time containers 可以研究好一会儿。</p>
<p>这下基本能明白为什么这哥们要开两个 talk 了，因为一个 talk 这么多内容说不玩啊。</p>
<hr>
<p><a href="http://www.thinkingparallel.com/2007/02/19/please-dont-rely-on-memory-barriers-for-synchronization/" target="_blank" rel="noopener">Please Don’t Rely on Memory Barriers for Synchronization!</a></p>
<p>文章实际上是一片批判文，但是被批判的文章被作者删除了（估计是被喷得太惨了），所以不能拿来做交叉对比。。</p>
<p>文章核心是在强调原则性的做法，但是因为主要是为了批评，所以没有太多的干活，总结一下就是：</p>
<ul>
<li>多看书，不要当民科，自己<strong>发明</strong>轮子</li>
<li>如无必要，不要使用 memory barrier 这种过于底层且没有移植性的东西</li>
<li>锁不慢，这篇文章很容易给人错的观念</li>
<li>先写对，再写快（老生常谈）</li>
</ul>
<hr>
<p><a href="https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html" target="_blank" rel="noopener">Overview of syslog</a></p>
<p>（Unix/Linux）系统提供的日志存储仓，对应的 daemon 叫 syslogd，使用的 Unix Domain Socket 名是 <code>/dev/log</code>。</p>
<p>程序可以使用 syslog.h 文件中的 <code>syslog()</code> 或 <code>vsyslog()</code> 函数往 syslog 写消息，一条消息最重要的有两部分：</p>
<ul>
<li>facility，表明谁发的消息</li>
<li>priority，消息的重要程度</li>
</ul>
<hr>
<p><a href="https://www.youtube.com/watch?v=CZi6QqZSbFg" target="_blank" rel="noopener">C++ Metaprogramming - Fedor Pikus - CppCon 2015</a></p>
<p><a href="https://www.youtube.com/watch?v=cg1wOINjV9U" target="_blank" rel="noopener">C++ metaprogramming- a paradigm shift - Louis Dionne - CppCon 2015</a></p>
<p>两个和 C++ TMP 有关的 talk。</p>
<p>前者是 introduction 性质的，后者嘛。。。其实就是 Boost.Hana 的宣传广告</p>
<hr>
<p><a href="http://blog.csdn.net/myan/article/details/1482614" target="_blank" rel="noopener">Java替代C语言的可能性</a></p>
<p>作者（当时）认为这不存在可能性，总结了三个原因</p>
<ol>
<li>Java 程序员的平局水平比起 C 程序员的平均水平还有明显差距，尤其对底层、结构体系的理解</li>
<li>内存占用过高，带来一系列的性能问题，导致目前（当时）且一段时间内只能做上层应用</li>
<li>思维方式的问题，Java 程序员被厚重的框架束缚思维</li>
</ol>
<p>虽然这是一篇10年前的文章，但是不得不说作者眼光独到。</p>
<p>现在这三个问题依旧，而且目前 Java 在互联网公司的主战场主要是 Android 开发（受到 Kotlin 挑战）和服务端（中间件，上层 web 服务，受到 Go 冲击），确实还未侵入 C 的核心领域。</p>
<p>不过个人感觉，未来编程面对的抽象层次会越来越高。</p>
<hr>
<p><a href="https://blog.csdn.net/myan/article/details/1906" target="_blank" rel="noopener">垃圾收集机制(Garbage Collection)批判</a></p>
<p>作者（当时）吐槽主要来自于：繁忙时刻且内存没有明显压力时不会触发 GC，而当内存有明显压力感知的时候，一次 GC 会导致极大的开销。</p>
<hr>
<p><a href="https://coelhorjc.wordpress.com/2014/12/18/using-non-blocking-and-asynchronous-io-ck10-problem-in-linux-and-windows-with-epool-iocp-aiolibaio-libeventlibevlibuv-boost-asio/" target="_blank" rel="noopener">USING NON-BLOCKING AND ASYNCHRONOUS I/O (CK10 PROBLEM) IN LINUX AND WINDOWS (WITH EPOOL, IOCP, LIBEVENT/LIBEV/LIBUV/BOOST.ASIO AND LIBRT/LIBAIO)</a></p>
<p>C10K 问题下的各种解决方案。</p>
<p>从基础的 reactor（epoll / kqueue）到 proactor （IOCP）</p>
<p>同时涉及当前流行的网络框架：libev, libeio .etc</p>
<p>适合技术选型或者了解各平台下实现高性能并发处理的方式</p>
<hr>
<p><a href="http://www.sean-bollin.com/2017/05/01/reactor-vs-proactor-part-1-the-reactor/" target="_blank" rel="noopener">Reactor vs. Proactor: Part 1 – The Reactor</a></p>
<p>PART 1 简单给予 epoll 做了几个例子。</p>
<p>例子代码写得不好，甚至还出现了利用异常做控制流…</p>
<p>还好作者太监了没有后续。</p>
<hr>
<p><a href="http://insanecoding.blogspot.co.uk/2013/04/designing-c-functions-to-writesave-to.html" target="_blank" rel="noopener">Designing C++ functions to write/save to any storage mechanism</a></p>
<p>这篇文章写于 2011 年，这个背景很重要。</p>
<p>在进入 C++ 11 的时代前，相当一部分 C++ 程序员还是<strong>只适应</strong>通过 OO 去构造抽象；而本身就是设计反面教科书的 ostream 体系让相当一部分人在错误的道路上越走越远。</p>
<p>作者吐槽的就是这点。</p>
<p>后文给出的 solution 说穿了其实就是，利用 template 进行依赖注入。</p>
<p>所有写操作，无论是写文件还是写 DB 还是写网络，核心都基于一个具体的 function object，而这个 function object 可以通过 template parameter 进行依赖解耦。</p>
<p>C++ 11 引入的 <code>std::bind()</code>、 lambda、甚至 <code>std::function</code> 都更加明确了条路子。</p>
<p>这篇文章有点类似孟岩曾经写的利用 bind + function 去避免继承（运行时多态）的滥用。</p>
<hr>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/" target="_blank" rel="noopener">POSIX Threads Programming</a></p>
<p>Pthreads 简明教程。</p>
<p>覆盖</p>
<ul>
<li>threads VS process (Why using threads)</li>
<li>pthreads 介绍</li>
<li>pthreads 创建/销毁</li>
<li>mutex</li>
<li>condition variable</li>
</ul>
<p>可以作为入门级读物。</p>
<hr>
<p><a href="http://insanecoding.blogspot.co.uk/2014/05/copying-code-copying-implementation.html" target="_blank" rel="noopener">Copying code != Copying implementation</a></p>
<p>一开始我还以为是作者专门写文章解释他为什么会 copy code，看完才发现不是这样。</p>
<p>作者的观点是：（遵守 license）从开源项目里抄代码直接用是不靠谱的，一定要注意，代码所处的上下文，搞清楚是不是有什么 prerequisites 或者 hidden requirements。</p>
<p>中间还专门举了几个例子。</p>
<hr>
<p><a href="https://medium.com/@AikoPath/visualising-and-prioritizing-technical-debt-afc82e542681" target="_blank" rel="noopener">Visualising and Prioritizing Technical Debt</a></p>
<p>核心：将技术债具象化，无论是采用四象限法还是技术债树。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/">浅析 shared_ptr：Libstdc++ 篇</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-30
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>序言请移步<a href="https://kingsamchen.github.io/2018/03/13/shared-ptr-internals-introduction/">此处</a></p>
<p>MSVC STL 的分析版本请移步<a href="https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">此处</a></p>
<p>注：因为这不是第一篇分析，所以会直入主题，跳过文学写作常用的累赘的过渡。</p>
<h2 id="版本选择与源码位置"><a href="#版本选择与源码位置" class="headerlink" title="版本选择与源码位置"></a>版本选择与源码位置</h2><p>目前的工作机是 Linux Mint 18，对应的是 Ubuntu 16.04 LTS。</p>
<p>这个版本的系统上源包默认提供的是 GCC 5.4 和 clang 3.8，跟随的 libstdc++ 的大版本是 6。</p>
<p>考虑到 Linux 上 clang 也是默认使用 libstdc++，且 GCC 6/7/8 使用的 libstdc++ 的大版本都是 6，因此直接选用目录 <code>/usr/include/c++/5</code> 下的源码作为研究对象。<br>
          <div class="read-more">
            <a href="/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">浅析 shared_ptr：MSVC STL 篇</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>序言请移步<a href="https://kingsamchen.github.io/2018/03/13/shared-ptr-internals-introduction/">此处</a></p>
<p>因为这是系列第一篇，所以会带一些功能的 demo，以方便叙述。</p>
<h2 id="How-shared-ptr-new-T-differs-from-make-shared"><a href="#How-shared-ptr-new-T-differs-from-make-shared" class="headerlink" title="How shared_ptr(new T()) differs from make_shared()"></a>How shared_ptr<t>(new T()) differs from make_shared<t>()</t></t></h2><p>首先考虑 <code>shared_ptr</code> 对象的创建，对于给定类型 <code>T</code>，假设通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_shared&lt;T&gt;(...);</span><br></pre></td></tr></table></figure>
<p>创建一个实例。</p>
<p>看一下函数代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> <span class="title">shared_ptr</span>&lt;_Ty&gt; <span class="title">make_shared</span>(_<span class="title">Types</span>&amp;&amp;... _<span class="title">Args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// make a shared_ptr</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> _Rx = <span class="keyword">new</span> _Ref_count_obj&lt;_Ty&gt;(_STD forward&lt;_Types&gt;(_Args)...);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;_Ty&gt; _Ret;</span><br><span class="line">    _Ret._Set_ptr_rep_and_enable_shared(_Rx-&gt;_Getptr(), _Rx);</span><br><span class="line">    <span class="keyword">return</span> (_Ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先在 heap 上创建了一个 <code>_Ref_count_obj&lt;_Ty&gt;</code> 对象，通过 <code>std::forward()</code> 将 <code>make_shared()</code> 的参数转发作为构造函数；接着通过 default contructor 创建了一个 <code>shared_ptr&lt;_Ty&gt;</code>，并调用 <code>_Set_ptr_rep_and_enable_shared()</code> 设置相关数据。</p>
<p>因为创建 <code>_Ty</code> 实例需要的参数 <code>_Args</code> 被转发到了 <code>_Ref_count_obj</code> 的构造函数中，且 <code>shared_ptr</code> 的 default constructor 实质上是一个 <em>constexpr function</em>，因此猜测 <code>shared_ptr</code> 自身并不负责创建其管理的 object instance，而是将这部分操作“委托”给 <code>_Ref_count_obj</code>。<br>
          <div class="read-more">
            <a href="/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/13/shared-ptr-internals-introduction/">浅析 shared_ptr：序论</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>单看标准库而言，<code>shared_ptr</code>/<code>weak_ptr</code>（后文除特指外，不再同时带上 <code>weak_ptr</code>） 一开始作为 TR1 的一员引入，低调行事多年后自 C++ 11 开始成为标准库正式成员。</p>
<p>在历史意义上，引入 <code>shared_ptr</code> 不光规范化了 resource ownership 作为 abstraction conception，同时解决了困扰广大 C++ programmers 多年的难题：<em>如何知道一个对象已经被析构了</em>。</p>
<p>此外，<code>shared_ptr</code> 的某些独特实现技巧，也提供了一些神奇的 idioms，例如</p>
<ul>
<li>deleter 不作为自身类型的一部分</li>
<li>可以正确的析构 cast 到基类的子类对象，即使基类没有提供 virtual destructor</li>
<li>.etc</li>
</ul>
<p>前几天偶然有个想法，既然自己用了这么久的 <code>shared_ptr</code>，那为什么不去看看它内部是如何实现的呢？能涨涨姿势也是好的嘛。</p>
<p>为了让目标更明确，不至于迷失在浩瀚细节中，我整理了一下当前几个比较重要且有意思的点，作为代码阅读的 targets：</p>
<ol>
<li>How <code>shared_ptr&lt;T&gt;(new T())</code> differs from <code>make_shared&lt;T&gt;()</code></li>
<li>Why virtual dtor is not necessary to correctly destruct a casted derived object instance</li>
<li>How custom deleter works and why it is not part of the pointer type</li>
<li>How <code>enable_shared_from_this</code> works</li>
<li>How reference counting works</li>
<li>How <code>weak_ptr</code> relates with <code>shared_ptr</code> (promotes <code>weak_ptr</code> to <code>shared_ptr</code>)</li>
<li>Thread-safety of <code>shared_ptr</code> instances</li>
</ol>
<p>考虑到存在多方的实现和平台的常见程度，目前选择了 4 个实现版本：</p>
<ul>
<li>MSVC STL：Windows 上使用 Visual Studio 的版本</li>
<li>Libstdc++：Linux 上的标配</li>
<li>Boost：先驱者</li>
<li>Chromium Base：严格来说 Chromium Base 的实现和标准库的完全不同，放在这里只是因为我对 chromium 这个项目有一种特殊的情感/好感。这个团队是真的知道工程化团队的重要性以及能够推进团队工程化，代码一致性极高，很少出现炫技的情况（望向 Facebook 和 Microsoft）。即使部分代码的架构和实现不能算是 C++ Best Practices，也不能掩盖他们整体的工程能力。</li>
</ul>
<p>后面会为每个实现版本写一篇单独的 post，至于最后有没有一篇 summing up，就看后面有没有时间，或者这个必要了 :-)</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/08/tiny-concurrent-http-server-on-windows-and-linux/">Tiny Concurrent Http Server on Windows and Linux</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-08
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>前段时间趁着春节，分别基于 IOCP 和 epoll 实现了 demo 级别的 http server（在遵守 http 1.1 socket 复用基础上只提供了某个指定目录下文件的 GET），算是简单的过了一下 proactor 和 reactor 模型下的 TCP 并发服务。</p>
<p>功能做的很粗糙，并且没有封装类似 event-loop 的东西，连接管理也基本算是纸糊的，原因还是前面说过的，只是想过一下两种模型，并且，在不研究当前流行的 paradigm 的前提下，凭借自己的 first understanding / hunch 去实现；等对这块有一段时间的研究后，作为参照，来回对比以加深理解。</p>
<p>我觉得这是一种不错的学习方式。</p>
<p>代码可以看 <a href="https://github.com/kingsamchen/Eureka/tree/master/ConcurrentHttpServer" target="_blank" rel="noopener">这里</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/07/ffmpeg-logging-utils-use-erroneous-format-specifiers/">被 FFmpeg 的日志模块撞了一下腰</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>周末的时候客服同学反馈有个用户出现了崩溃，并且要来了崩溃 dmp 文件。</p>
<p>挂上 windbg 后发现崩溃原因是 CRT 的 <code>invalid-parameter</code> 异常，第一现场是输出 ffmpeg 的 avcodec 模块的日志。</p>
<p>省略中间若干分析过程，直击结论：FFmpeg 的 Windows 构建并不是用 MSVC 编译的，因此在类似 <code>printf()</code> 函数的 format specifier 使用上出现了偏差。</p>
<p>代码使用 <code>%td</code> 输出 <code>ptrdiff_t</code> 类型，而 VS2017 之前的版本并不支持这个 format specifier，因此函数调用 <code>_vsnprintf_p()</code> 出现了参数异常，导致程序挂掉。</p>
<p>虽然 VS 2017 很厚道的支持了这个格式，但是某直播姬的工具链是 VS 2013，且短时间不可能调整，因此最后的解决方案是，上层安装的 logging hook 在输出日志时，首先修正一遍 format 里的 specifier，替换为 VS 2013 支持的 <code>%Id</code>。</p>
<p>注意，类似的还有 <code>size_t</code> 的 format specifier。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/6/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/8/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
