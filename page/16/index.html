<!DOCTYPE html>
<html lang="default">
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gone with the ruins">













  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0">



<link rel="canonical" href="http://kingsamchen.github.io/page/16/">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0">






  



  









    <title> KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/12/use-ffmpeg-to-reencode-videos/">使用 ffmpeg 压制视频</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>帮主站重写完投稿工具的上传模块后，Neo 和我说，我们这期版本还是得带上视频压制功能…</p>
<p>这是我第一次知道原来 ffmpeg 还可以压制视频。因为重构的缘故，老版本的代码完全不能用（就算不考虑换上层 UI 框架的事儿，老版本那个代码质量…），所以只能抄一下他们的压制相关的驱动参数，自己从头把功能实现一遍。</p>
<p>花了差不多刚好一周的时间提供了一个底层压制模块后，我发现，因为产品需求的因素，实现这部分功能居然可以很好的做为熟悉一个语言涉及操作层面的 roadmap，整理一下 feature list，算算差不多至少要能够提供：</p>
<ul>
<li>运行子进程，并且能够通过 IPC 读取并解析子进程的 stdout 和 stderr 数据；通常情况下，这意味着需要熟悉 Windows 的 Pipe</li>
<li>压制首先涉及到利用 <code>ffprobe.exe</code> 检测视频的 meta-info，符合压制条件并且用户确认后利用 meta-info 作为压制的部分输入信息；中间涉及到几个线程间的交互</li>
<li>因为压制功能和视频上传在逻辑上具有先后顺序，并且都需要有专门的 worker thread，因此他们可以共用一个线程池；而支持多任务并行操作，又要求线程池的调度策略要足够“及时”（事实上，这个要求有一部分锅来自 chromium net 的 <code>URLFetcher</code>，which requires 网络操作运行的线程在 URLFetcher context 生命周期内是唯一且固定的，因此会出现一个上传任务只要不结束，就会一直霸占一个线程的情况；另有一部分锅来自 chromium base 的 <code>scoped_reptr</code>，居然没有考虑对外暴露自己 ref-count 信息，无形中加大了实现线程池的困难）</li>
</ul>
<p>因此在项目提测结束，基本验收通过之后，我想籍由这个功能，重新回忆一下 C# 和 WPF （噫，怎么老是再回忆这个…），所以花了一个周末，就有了 <a href="https://github.com/kingsamchen/Eureka/tree/master/SimpleVideoEncoder" target="_blank" rel="noopener">SimpleVideoEncoder</a></p>
<p>但是在实现过程中我发现，纵使有 async/await，它也不是银弹，也有他覆盖不了的 case；而我对 C#/.NET 的多线程模型实在是完全不懂，导致某些细节完全没法下手（只能说某些case 下，CSP 真是好用到想哭，还好 WPF 的 UI-thread 提供了一个 <code>Dispatcher</code> 支持了对 UI 线程的 CSP；再将需求简化到 Demo 程度后，勉强实现了出来。</p>
<p><img src="/img/ffmpeg-encode.png" alt></p>
<p>上层界面基于 WPF，但是没有走 MVVM。</p>
<p>实话说，经过一年半（距离上次写 EasyKeeper），自己主导过两个不大不小的项目后，对于为什么需要有 MVC/MVP/MVVM 有了一些更实际的想法，并且也能理解有时候过分追求这些反而是一种坑。</p>
<p>考虑到目前应该是没法公开为投稿工具写的那部分代码（压制模块算起来大概有 1K+ lines of code），所以这个 <em>SimpleVideoEncoder</em> 的意义也大大折扣，基本只能作为一个 ffmpeg 压制功能的简单展示…</p>
<p>不过最后还是要赞一下 C# 对 Pipe IPC 的封装，几行代码做了需要几十行 C++ 代码的事情；并且基于 event 的通知机制比起传统的 observer，更能准确的体现 OOP 中<strong>对象级别消息通信</strong>的内涵。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/02/monthly-read-posts-in-mar-2017/">Monthly Read Posts in Mar 2017</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-02
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><a href="http://playfulprogramming.blogspot.hk/2017/01/generate-lambdas-for-clarity-and.html" target="_blank" rel="noopener">Generate lambdas for clarity and performance</a></p>
<p>Generate a class of lambdas with auto-return-type deduction.</p>
<p>唯一比较遗憾的是特性需要 C++ 14 的支持，C++ 11 里估计需要用 <code>std::function&lt;&gt;</code> 来做 workaround</p>
<hr>
<p><a href="http://nullprogram.com/blog/2016/08/03/" target="_blank" rel="noopener">Appending to a File from Multiple Processes</a></p>
<p>经验问题，写客户端的 logger 轮子时应该会经常需要考虑到这个问题。</p>
<p>文章针对的是 POSIX 系统，不过不同系统在一些具体策略/细节上也有区别。</p>
<p>另，Windows 上这个场景有直接的 API 调用保证。</p>
<p>不过有点比较奇怪，chromium 的 base::logging 只提供了 Windows 下的多进程无锁 appending，POSIX/Mach 下依然用的是线程同步锁和全局锁，可能考虑的原因是实现起来坑比较大？</p>
<hr>
<p>OAuth 2.0 Protocol</p>
<ol>
<li><a href="http://tutorials.jenkov.com/oauth2/authorization.html" target="_blank" rel="noopener">oauth2 authorization</a></li>
<li><a href="https://taozj.org/201605/principle-of-oauth2.html" target="_blank" rel="noopener">principle-of-oauth2</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">oauth_2_0</a></li>
</ol>
<p>第二篇文章基本可以看作第一篇的翻译，但是很多地方都没有翻译出来，所以推荐主要看第一篇文章，把第二、三篇作为补充材料</p>
<hr>
<p><a href="https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil" target="_blank" rel="noopener">Inheritance Is The Base Class of Evil</a></p>
<p>C9 上的一个 Tech Talk，speaker 是 Adobe 的技术大佬，但是我觉得有标题党之嫌。</p>
<p>Talk 中展现出来的哲学观挺有意思的，比如那句 <em>There is no polymorphic type, just polymorphic use of types</em>。</p>
<hr>
<p><a href="https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-53-Learning-STL-Multithreading" target="_blank" rel="noopener">Learning STL Multithreading</a></p>
<p>虽然标题是 STL Multithreading，但是里面的核心内容基本都是原理性的，通用的。</p>
<p>对于 mutex/condition-variable 这类比较高级的 synchronization primitives 和低级的 atomic variables 均有涉及，并且也给了实践建议。</p>
<p>话说右边那个胖胖的小哥的口音听起来真的是容易懂…</p>
<p>另外有个挺有意思的细节，快到最后的时候胖小哥提到了 <code>async</code> 和 <code>future</code>，他说希望大家能优先考虑这俩玩意儿，但是说了几句话又欲言又止，最后无奈地说 <em>we will discuss these later</em>。。。估计他想了想，就目前标准给的设施和实现情况，要做到 task-based paralleilism，那坑大的都可以把自己埋进去了。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/04/implement-apply-in-cpp-11/">在 C++ 11 中实现 apply</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-04
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Why-apply-matters"><a href="#Why-apply-matters" class="headerlink" title="Why apply matters"></a>Why apply matters</h2><p>假设我们要实现一个和具体业务无关的 HTTP(S) 网络 (Restful)API 请求设施 <code>RequestConnection</code>，我们至少要提供两个实现：</p>
<ul>
<li>客户代码的请求结束时的回调 callback/handler</li>
<li>针对具体业务的 response parser；因为 HTTP 是文本协议，无论 response data 基于何种格式（例如 JSON），我们都要针对具体的业务逻辑场景进行解析</li>
</ul>
<p>假设我们希望请求的 callback 足够友好，直接将 client 需要的数据通过函数原型暴露出来，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCheckUpdateComplete</span><span class="params">(<span class="keyword">bool</span> succeeded, <span class="keyword">int</span> last_build_no)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那么我们的 reponse parser 也要相应的能够返回符合 callback signature 的数据，在 C++ 中，我们可以用 <code>std::tuple</code> 来保存 parsed result：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>&gt; ParseCheckUpdateResponse(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data);</span><br></pre></td></tr></table></figure>
<p>但是很不巧的，<code>RequestConnection</code> 是业务无关的，而业务相关的 callback/response-parser 则是通过依赖注入的方式（例如通过模板参数）进入 <code>RequestConnection</code>；这意味着我们需要一个通用的方法能够在编译期完成如下事情：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Presume magic function Apply</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> response_data;</span><br><span class="line">Apply(ResponseHandler, ResponseParser(response_data));</span><br></pre></td></tr></table></figure>
<p>神奇函数 <code>Apply()</code> 能够调用一个函数，并且将一个 <code>std::tuple</code> 里的元素按照顺序转换为对应的实参。</p>
<p>简言之，这就是 C++ 17 要引入的 <a href="http://en.cppreference.com/w/cpp/utility/apply" target="_blank" rel="noopener">std::apply</a> 所做的事情。</p>
<p>但是如果我们的 codebase 是 C++ 11的，那又如何呢？</p>
<h2 id="How-to-implement-apply-in-C-11"><a href="#How-to-implement-apply-in-C-11" class="headerlink" title="How to implement apply in C++ 11"></a>How to implement apply in C++ 11</h2><p>在 C++ 11 里实现 <code>apply()</code>，我们要做两步：</p>
<ol>
<li>实现 index-sequence （C++ 14 开始标准库附带了这个实现）</li>
<li>实现 apply</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span>... Ints&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index_sequence</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = index_sequence;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>...(Ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Sequence1</span>, <span class="title">class</span> <span class="title">Sequence2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">merge_and_renumber</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span>... I1, <span class="keyword">size_t</span>... I2&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">merge_and_renumber</span>&lt;index_sequence&lt;I1...&gt;, index_sequence&lt;I2...&gt;&gt;</span></span><br><span class="line"><span class="class">    :</span> index_sequence&lt;I1..., (<span class="keyword">sizeof</span>...(I1) + I2)...&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">make_index_sequence</span></span></span><br><span class="line"><span class="class">    :</span> merge_and_renumber&lt;<span class="keyword">typename</span> make_index_sequence&lt;N / <span class="number">2</span>&gt;::type,</span><br><span class="line">                         <span class="keyword">typename</span> make_index_sequence&lt;N - N / <span class="number">2</span>&gt;::type&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">make_index_sequence</span>&lt;0&gt; :</span> index_sequence&lt;&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">make_index_sequence</span>&lt;1&gt; :</span> index_sequence&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Tuple, <span class="built_in">std</span>::<span class="keyword">size_t</span>... index&gt;</span><br><span class="line">auto apply_helper(Func&amp;&amp; func, Tuple&amp;&amp; tuple, index_sequence&lt;index...&gt;) -&gt;</span><br><span class="line">    <span class="keyword">decltype</span>(func(<span class="built_in">std</span>::get&lt;index&gt;(<span class="built_in">std</span>::forward&lt;Tuple&gt;(tuple))...))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> func(<span class="built_in">std</span>::get&lt;index&gt;(<span class="built_in">std</span>::forward&lt;Tuple&gt;(tuple))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Tuple&gt;</span><br><span class="line">auto apply(Func&amp;&amp; func, Tuple&amp;&amp; tuple) -&gt;</span><br><span class="line">    <span class="keyword">decltype</span>(apply_helper(<span class="built_in">std</span>::forward&lt;Func&gt;(func),</span><br><span class="line">                          <span class="built_in">std</span>::forward&lt;Tuple&gt;(tuple),</span><br><span class="line">                          make_index_sequence&lt;<span class="built_in">std</span>::tuple_size&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;Tuple&gt;::type&gt;::value&gt;&#123;&#125;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> apply_helper(<span class="built_in">std</span>::forward&lt;Func&gt;(func),</span><br><span class="line">                        <span class="built_in">std</span>::forward&lt;Tuple&gt;(tuple),</span><br><span class="line">                        make_index_sequence&lt;<span class="built_in">std</span>::tuple_size&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;Tuple&gt;::type&gt;::value&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就是我在某直播姬的网络框架里所用的实现；根据实际是用来看，quite awesome</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/02/monthly-read-posts-in-feb-2017/">Monthly Read Posts in Feb 2017</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-02
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><a href="http://insights.thoughtworkers.org/security-issues-in-restful/" target="_blank" rel="noopener">RESTful架构风格下的4大常见安全问题</a></p>
<ul>
<li>Don’t forget to check correlations between resources in request URL</li>
<li>Some rare used HTTP headers might be helpful</li>
<li>Restrict API request frequency</li>
</ul>
<p>这篇略水，某些常见的问题反而都没有提到，例如大木老师遇到的<a href="http://www.daozhihun.com/p/2119" target="_blank" rel="noopener">这个问题</a></p>
<hr>
<p><a href="http://preshing.com/20150324/safe-bitfields-in-cpp/" target="_blank" rel="noopener">Safe Bitfields in C++</a></p>
<p>Main observation: Use union to implement/simulate bitfields.</p>
<p>Each bitfield is implemented by using a single union member with mask and bit-length being set up initially.</p>
<p>非常 stunning 的一个实现，但是很可惜，根据 comments 这个实现仍然是 undefined behavior，because <em>it call member functions on inactive union members</em>.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/01/monthly-read-posts-in-jan-2017/">Monthly Read Posts in Jan 2017</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-02-01
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><a href="http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking/" target="_blank" rel="noopener">Library order in static linking</a></p>
<p>An object file both provides (exports) external symbols to other objects and libraries, and expects (imports) symbols from other objects and libraries.</p>
<p>During linking, the linker maintains a symbol table, which keeps two important lists:</p>
<ul>
<li>a list of symbols exported by all the objects and libraries encountered so far</li>
<li>a list of undefined symbols that objects and libraries demanded to import and were not found yet.</li>
</ul>
<p><strong>Case 1: the linker encouters a new object file</strong></p>
<p>linker first checks symbols the object file exports, and:</p>
<ol>
<li>add them to the list of exported symbols</li>
<li>remove them from undefined symbols, if necessary.</li>
</ol>
<p>Note that, if any symbol has already been in the exported list, then we get a multiple definition error.</p>
<p>Linker then checks symbols the file imports, and added them to the list of undefined symbols, unless they can be found in the exported symbol list.</p>
<p>we can see that for linking pure object files, link order doesn’t matter.</p>
<p><strong>Case 2: the linker encounters a new library</strong></p>
<p>Linker goes over all the object files in the library, and for each one, it first looks at the exported symbols:</p>
<ol>
<li>If any of the exported symbols are on the undefined list, then this object file is chosen, being added to the link, and is treated as normal object file as above(its exported symbols and imported symbols are processed as normal object file).</li>
<li>If any of the object files in the library has been included in the link, the library is rescanned again(because a lately added object file may require symbols exported from one early examined-but-skipped object file).</li>
</ol>
<p>when linking is done, if any symbols remain in the undefined list, the linker will throw an undefined reference error.</p>
<p>Note that after the linker has looked at a library, it won’t look at it again. Even if it exports symbols that may be needed by some later library.</p>
<p>An very important corollary: If object or library AA needs a symbol from library BB, then AA should come before library BB in the command-line invocation of the linker.</p>
<p><strong>Use Flags to Solve Circular Library Dependency</strong></p>
<p>Use flags such as <code>--start-group</code> and <code>--end-group</code> to repeatedly scan libraries, until no new import symbol was found.</p>
<p>But may take significant time to finish linking.</p>
<hr>
<p><a href="http://www.lurklurk.org/linkers/linkers.html" target="_blank" rel="noopener">Beginners’ guide to linkers</a></p>
<p>和前一篇着重分析链接顺序不同，这篇（其实更像是一个短 paper）介绍了整个链接的基础知识，适合扫盲。</p>
<p>但是如果有一定基础的话，这篇反而没有什么让人觉得惊奇的点。</p>
<hr>
<p><a href="http://shaharmike.com/cpp/unique-ptr/" target="_blank" rel="noopener">Exploring std::unique_ptr</a></p>
<p>同样是一篇基础扫盲 posts，适用于检查自己是否对 <code>std::unique_ptr</code> 的必备知识存在缺漏的情况。</p>
<p>如果认真阅读过 Scott Meyers 的 <a href="https://book.douban.com/subject/25923597/" target="_blank" rel="noopener">Effective Modern C++</a>，那么 post 里提到的，诸如“为什么使用 <code>std::make_unique()</code> 可以带来异常安全” 这种高级议题就变得显而易见了。</p>
<p>另外 post 对 custom deleter 的叙述的反而不够详细。</p>
<hr>
<p><a href="http://www.jmarshall.com/easy/http/" target="_blank" rel="noopener">HTTP Made Easy</a></p>
<p>非常赞的 HTTP 协议扫盲文章</p>
<p>这篇 post 从 HTTP 1.0 开始讲起，然后过渡到 HTTP 1.1，所以对于 HTTP 1.1 为什么要求 request header 一定要带 <code>Host</code> header 提供了一个非常直观的解释。</p>
<p>此外 post 还增加了 chunked transfer encoding 部分，印象中 Top-down approach 那本 computer networking 是没有提及这部分内容的。</p>
<hr>
<p><a href="http://www.csdn.net/article/2015-12-03/2826381" target="_blank" rel="noopener">C++ 11 之美</a></p>
<p>这篇 post 主要有三个点</p>
<ul>
<li>编译期的类成员存在性检查 &amp; 利用 SFINAE 做静态的分支选择（我的<a href="https://kingsamchen.github.io/2017/01/30/check-if-has-member-at-compile-time-in-cpp/">这篇 post</a> 里的实现就是从这篇 post 改进而来）</li>
<li>利用 <code>std::function&lt;&gt;</code> 实现 lazy-computation</li>
<li>演示了如何将字符串 <code>&quot;hello/test/20&quot;</code> 转换为函数调用 <code>hello(&quot;test&quot;, 20)</code></li>
</ul>
<hr>
<p><a href="http://www.trinea.cn/android/android-image-cache-compare/" target="_blank" rel="noopener">Android 三大图片缓存原理、特性对比</a></p>
<p>讲道理这篇文章很水….</p>
<p>一开始 mark 这篇文章是因为当时还在做安卓直播姬，转眼9个月过去了….</p>
<p>现在为了借鉴文中几个库的架构设计从 pocket 的回收站里挖出来看了一遍，不过想想也就那么回事了….</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/01/30/check-if-has-member-at-compile-time-in-cpp/">编译期判断是否存在某个成员函数</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-01-30
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>之前在<a href="https://kingsamchen.github.io/2016/06/14/template-type-constraints-and-type-traits/">某篇</a>文章描述了一个实际上不是那么好用的检查某个模板类型参数是否存在某个函数的方法。</p>
<p>这次会介绍一个相对有用的，在编译期检查某个类是否存在给定成员函数的做法，并且可以根据检查的结果执行不同的代码。</p>
<p>（简而言之就是如何拙劣的模拟一下 duck typing）</p>
<p>假设我们要检查某个类 <code>class Foo</code> 是否存在成员数 <code>bar(int)</code></p>
<p>实现辅助设施</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_member_bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    constexpr static auto check(const void*)-&gt;</span><br><span class="line">        <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;U&gt;().bar(<span class="built_in">std</span>::declval&lt;Args&gt;()...), <span class="built_in">std</span>::true_type());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function">false_type <span class="title">check</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="keyword">decltype</span>(check&lt;T&gt;(<span class="literal">nullptr</span>))::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查的方法是尝试生成函数 <code>T::bar</code> 的返回类型，如果不存在相应函数，则 <code>check()</code> 的重载决议会匹配到第二个函数上。</p>
<p>这里引入 variadic template 的原因是我们希望能够检查时同时确定函数的 signature（注意 signature 是不包含返回类型的）。</p>
<p>使用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> has_bar = has_member_bar&lt;Foo, <span class="keyword">int</span>&gt;::value;</span><br></pre></td></tr></table></figure>
<p>如果想把这部分做成通用的设施，那只能引入宏，根据需要生成辅助结构的代码；因为一个辅助结构只能检查一个函数成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_HAS_CLASS_MEMBER(NAME)                                                  \</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;                                                  \</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_member_</span>##<span class="title">NAME</span> &#123;</span>                                                              \</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;                                                                \</span><br><span class="line">    constexpr static auto check(const void*)-&gt;                                          \</span><br><span class="line">        <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;U&gt;().NAME(<span class="built_in">std</span>::declval&lt;Args&gt;()...), <span class="built_in">std</span>::true_type());    \</span><br><span class="line">                                                                                        \</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;                                                                \</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function">false_type <span class="title">check</span><span class="params">(...)</span></span>;                                        \</span><br><span class="line">                                                                                        \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="keyword">decltype</span>(check&lt;T&gt;(<span class="literal">nullptr</span>))::value;                   \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAS_CLASS_MEMBER(CLASS, MEMBER, ...) \</span></span><br><span class="line">    has_member_##MEMBER&lt;CLASS, __VA_ARGS__&gt;::value</span><br></pre></td></tr></table></figure>
<p>使用前需要先用 <code>DECLARE_HAS_CLASS_MEMBER(class_name)</code> 来创建一个辅助结构，再利用 <code>HAS_CLASS_MEMBER(Foo, bar, int)</code> 来判断是否存在 <code>Foo::bar(int)</code>。</p>
<p>如果希望能利用上面的设施在编译期做到根据函数是否存在执行不同的操作，那么则可以借助 SFINAE 来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_HAS_CLASS_MEMBER(foo);</span><br><span class="line">DECLARE_HAS_CLASS_MEMBER(bar);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bar::bar()\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bar::foo(const std::string&amp;, int)\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;HAS_CLASS_MEMBER(T, foo, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">int</span>)&gt;::<span class="function">type <span class="title">RunFoo</span><span class="params">(T&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.foo(<span class="string">"hello world"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;!HAS_CLASS_MEMBER(T, foo, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">int</span>)&gt;::<span class="function">type <span class="title">RunFoo</span><span class="params">(T&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    RunFoo(bar);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果想将 SFINAE 这部分做成通用的 static-if，还是比较 tricky 的；我一开始利用 lambda + SFINAE 倒是模拟了一个，但是因为 lambda 直接被无条件编译，导致即使在编译期已经确定不用某个分支的 lambda，仍然会编译这个 lambda 的代码，使得 static-if 功能大减。</p>
<p>我猜想使用 generic lambda 应该可以绕过去，但是实现上可能会更加 tricky，并且使用上不会太直观，或者满地坑。</p>
<p>其实 <code>HAS_CLASS_MEMBER</code> 最好的作用是等到 C++ 17 普及了 if-constexpr，这样整个流程都变得清晰了。</p>
<p>另外有一点不得不说，其实很多你认为需要通过编译期判断是否存在某个成员函数才能解决的问题，压根就走不到需要自己实现 SFINAE 那一步，通过一些（可能不是那么优雅）简单的构造，就可以利用 type traits 解决，例如，我在实现 <a href="https://github.com/kingsamchen/KBase/blob/master/src/kbase/singleton.h" target="_blank" rel="noopener">KBase Singleton</a> 的方案。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/01/14/automatically-start-installation-using-inno-setup/">自动开始安装 Inno Setup 打包的安装程序</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-01-14
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>有时候我们希望用户执行安装程序后，跳过路径选择等一系列确认，自动开始安装，已尽可能减少等待时间。</p>
<p>最明显的例子就是，用户在已经安装程序的情况下，下载了新版的安装包，需要执行更新操作。因为安装路径、设置选项等信息早在用户首次安装时就已经确定，升级安装过程中完全可以跳过。</p>
<p>某科学的直播姬在加入自动更新功能的同时，就需要安装包具备上述能力。</p>
<p>OK，那么如何在 inno setup 中实现自动安装？</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>Inno Setup 提供了 <code>ShouldSkipPage(PageID: Integer)</code> 函数，这个函数会在安装的不同阶段被调用，并且参数是当前安装程序页的 id，函数返回 <code>True</code>，则表示跳过此页。</p>
<p>于是只要重写这个函数，在更新模式下，自动跳过除了 <code>wpInstalling</code> 的所有页。</p>
<p>但是如果只这么做，会发现安装程序还是无法自动开始安装，它会停在 <code>wpReady</code> ，即确认页。</p>
<p>这是 a feature by design，因为 inno setup 的作者觉得不让用户确认就自动开始安装是一个很 evil 的行为；所以即使在 <code>ShouldSkipPage()</code> 里选择跳过确认页，inno setup 也会自动忽略这个要求。</p>
<p>真他喵的体贴啊。</p>
<p>既然只能手动点击安装，那我们就通过发送按钮点击事件来模拟用户点击就好了。</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>在函数 <code>CurPageChanged(CurPageID: Integer)</code> 中检查当前页，如果已经到了确认页，就发送按钮事件。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> CurPageID = wpReady <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">    param := <span class="number">0</span> <span class="keyword">or</span> BN_CLICKED <span class="keyword">shl</span> <span class="number">16</span>;</span><br><span class="line">    PostMessage(WizardForm.NextButton.Handle, CN_COMMAND, param, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>这里注意几个坑，按我当时被踩的先后顺序：</p>
<ol>
<li>如果你的安装程序定制了 UI，那么极有可能会隐藏原生的 next button 并且提供一个自己美化过的安装按钮；如果真的是这样，那么请通过设置 <code>WizardForm.NextButton.Height := 0</code> 来隐藏他，而不是直接 set invisible。因为后者会导致这个按钮直接不响应他的事件。</li>
<li>发送消息采用 <code>PostMessage</code>。我一开始用的 <code>SendMessage</code> 并没有成功，具体原因未知…</li>
</ol>
<h3 id="Rants"><a href="#Rants" class="headerlink" title="Rants"></a>Rants</h3><p>Inno Setup 这种试图通过提供一系列设置和受限的脚本的方式来生成安装包的行为，固然可以降低使用门槛，但是也增加了自定义的难度和复杂度。Joel Spolsky 那篇洞察一切的 <em>the law of leaky abstractions</em> 其实已经说明了一切。</p>
<p>其实如果不是接手项目的时候安装包早就已经固定了，我很可能自己就用 C++ 给撸了，如果真这样，也没有这么多七七八八的事情…</p>
<p>至于我为什么会亲自上阵做安装包…还不是因为没有人愿意做，并且之前的 iss 脚本质量实在一般，都快大坑小坑落玉盘了，总得有个人出来 clean the mess/ass，你说对伐（真怀念当年不想搞了可以把脏活直接丢给老大的日子…）。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/15/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/17/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
