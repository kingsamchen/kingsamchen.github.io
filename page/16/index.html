<!DOCTYPE html>
<html lang="default">
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gone with the ruins">













  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0">



<link rel="canonical" href="http://kingsamchen.github.io/page/16/">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0">






  



  









    <title> KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/24/terminate-child-processes-on-close-using-job-object/">利用 Job 内核对象实现父进程关闭时自动结束所有子进程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-24
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>投稿工具的压制功能一直来都有一个问题：如果主进程被强行结束了（例如利用任务管理器），那么创建的 ffmpeg 压制进程仍然会继续运行。</p>
<p>因为 ffmpeg 是以二进制的方式部署的，因此不存在修改它的代码，自己和主进程建立 IPC 监控的方式。</p>
<p>至于采用远线程注入的方式来强行 HACK，我一直对这种无视客观规律的霸道方式都不太感冒，毕竟我们又不是做安全软件。</p>
<p>所以我想到了曾经在 Windows 核心编程中看到的一个方法：使用 Job 内核对象。</p>
<p>核心方法总结起来就是一句话：将 ffmpeg 压制进程加入到一个 Job 对象中，利用 Job 对象的 <em>Kill-On-Close</em> 特性，在 Job 内核对象被释放时，Job 内的所有进程都会被系统结束。</p>
<p>于是我写了一个 demo snippet，解决了几个坑之后验证了我的想法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LaunchAndWait</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::wstring&amp; cmdline, HANDLE job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">wchar_t</span> buf[<span class="number">255</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wcscpy_s(buf, cmdline.c_str());</span><br><span class="line"></span><br><span class="line">    STARTUPINFO startup &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    startup.cb = <span class="keyword">sizeof</span>(startup);</span><br><span class="line">    PROCESS_INFORMATION process_information &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcessW(<span class="literal">nullptr</span>,</span><br><span class="line">                        buf,</span><br><span class="line">                        <span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="literal">nullptr</span>,</span><br><span class="line">                        FALSE,</span><br><span class="line">                        CREATE_SUSPENDED | CREATE_BREAKAWAY_FROM_JOB,   <span class="comment">// important</span></span><br><span class="line">                        <span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="literal">nullptr</span>,</span><br><span class="line">                        &amp;startup,</span><br><span class="line">                        &amp;process_information)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> err = GetLastError();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to create process: "</span> &lt;&lt; err;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AssignProcessToJobObject(job, process_information.hProcess)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to assign process to job: "</span> &lt;&lt; GetLastError();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResumeThread(process_information.hThread);</span><br><span class="line"></span><br><span class="line">    CloseHandle(process_information.hProcess);</span><br><span class="line">    CloseHandle(process_information.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL is_in_job;</span><br><span class="line">    IsProcessInJob(GetCurrentProcess(), <span class="literal">nullptr</span>, &amp;is_in_job);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Is the main process in job: "</span> &lt;&lt; is_in_job &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wait for constructing job object!\n"</span>;</span><br><span class="line"></span><br><span class="line">    HANDLE job = CreateJobObjectW(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!job) &#123;</span><br><span class="line">        <span class="keyword">auto</span> err = GetLastError();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to create job: "</span> &lt;&lt; err &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enforce limits.</span></span><br><span class="line">    JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limits;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;job_limits, <span class="number">0</span>, <span class="keyword">sizeof</span>(job_limits));</span><br><span class="line">    job_limits.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SetInformationJobObject(job, JobObjectExtendedLimitInformation, &amp;job_limits, <span class="keyword">sizeof</span>(job_limits))) &#123;</span><br><span class="line">        <span class="keyword">auto</span> err = GetLastError();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to set job information: "</span> &lt;&lt; err &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Job object created! Launch test subjects...\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> r = LaunchAndWait(<span class="string">LR"(C:\Windows\notepad.exe)"</span>, job);</span><br><span class="line">    assert(r);</span><br><span class="line"></span><br><span class="line">    _getch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的产品代码思路是完全一样的，当然代码不可能像上面这样随意。</p>
<p>这里有两个比较隐蔽的坑（MSDN 上不一定能看到）需要注意一下：</p>
<p>第一个是创建进程时最好带上 <code>CREATE_BREAKAWAY_FROM_JOB</code>，因为 Job 属性存在自动继承性：如果一个进程属于一个 Job，那么他创建的子进程会自动关联到这个 Job。</p>
<p><code>explorer</code> 和 VS 都是存在于 Job 中的，因此如果在这两个环境下运行程序， <code>IsProcessInJob()</code> 会返回 <code>true</code></p>
<p>第二个坑特别隐蔽：我一开始的 test subject 是 calc.exe，在 Windows 10 上这是一个 UWP 程序，然而无论我怎么做，calc 进程都活得好好的，一点不像是被约束的样子。。。甚至所有 API 的调用都并没有返回错误。</p>
<p>而当我将 test subject 换成 Win32 程序 notepad.exe 之后，功能就可以正常跑了….</p>
<p>我猜想这大概和 UWP 程序的一些安全特性有关，不过因为本身对安全并没有偏执的热爱，所以在这个点上就没有继续深入了。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/23/send-specific-cookie-in-urlfetcher/">Send Specific Cookie in URLFetcher</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-23
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>使用 <code>URLFetcher</code> 作为网络请求的基础组件有一个优势：如果 server 的 response header 指明了 <code>set-cookie</code>，那么 <code>URLFetcher</code> 在发出下一个请求时会自动往 request header 中设置 cookie。</p>
<p>这为使用某些需要在请求时附带 cookie 的 API 提供了便利；但是同时也在某一些场合下导致了一些问题。</p>
<p>如果你需要为某个 API 请求的 request header 中携带自定义的 cookie 数据，例如 <code>cookie: buvid=xxxx</code>，那么，即使你在发送请求前通过 <code>AddExtraRequestHeader()</code> 添加了 cookie 头，你也会惊奇地发现，出去的请求并没有携带你设置的 cookie，而是只有 <code>URLFetcher</code> 自己设置的，服务端提供的 cookie 值。</p>
<p>不要问为什么这个时候要用 cookie 传递这个信息，而不是某个独有的 request header，亦或者 query-string；你永远不知道和你对接的人是一个怎样的智障；毕竟，没有谁会真的去读 RFC。</p>
<p>自定义 cookie 丢失的原因大概如下：</p>
<ol>
<li>你首先设置了 cookie，然后发出请求</li>
<li><code>URLFetcher</code> 在内部实际进行网络请求前，会设置服务端的 cookie 值（因为之前的请求存在 <code>set-cookie</code>）</li>
<li>因为 RFC 规定，一个 request header 中， cookie header line 有且仅有一个，也就是说</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie: buvid=xxx</span><br><span class="line">cookie: sig=xxx</span><br></pre></td></tr></table></figure>
<p>是不合法的；虽然可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie: buvid=xxx; sig=xxx</span><br></pre></td></tr></table></figure>
<p>来传递多个value，但是这要求 <code>URLFetcher</code> 在添加 cookie 时要能够 aware 到这点；很可惜，根据情况来看这点不成立</p>
<ol>
<li>于是 <code>URLFetcher</code> 粗暴的替换了你设置的 cookie 值</li>
</ol>
<p>扫了一遍代码之后，我想到一个 workaround，实践证明确实可以：</p>
<p>发请求前设置 <code>URLFetcher</code> 的 load flag，加上 <code>LOAD_DO_NOT_SEND_COOKIE</code>，阻止 <code>URLFetcher</code> 自己设置 cookie 的行为，完全由自己控制请求的 cookie。</p>
<p>话说用 <code>URLFetcher</code> 被坑了好多次（算上 chromium 其他的 lib，次数可以翻翻），还好每次都能够凭借“优秀工程师的第六感”蒙中问题的 root cause，进而化险为夷。我突然感觉自己理解了什么叫 <em>文章本天成，妙笔偶得之</em>。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/07/bypass-proxy-in-urlfetcher/">Bypass Proxy in URLFetcher</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><code>net::URLFetcher</code> 默认情况下会使用系统代理，对于针对应用于浏览器而设计的网络组件来说，这是合情合理的；并且这也方便了测试对于网络接口的调试，因为只需要打开 Fiddler 或者 Charles，就可以看到应用发出去的 HTTP 请求。</p>
<p>但是有时候我们又希望默认情况下不开启代理支持，比如：在我用 <code>net::URLFetcher</code> 重写某直播姬的网络通信组件后，出现了不少傻逼用户因为不知道自己系统上为什么会各种乱七八糟的本地代理而导致无法登陆。</p>
<p>这个时候产品的策略就应该改为：默认不使用代理，如果有特殊需要，通过命令行参数启动。</p>
<p>因为产品项目用的 chromium 的代码比较老（估计是 2x 的），这个版本的 <code>net::URLFetcher</code> 只要是使用 <code>URLRequestContextBuilder</code> 创建的 <code>URLRequestContext</code>，那么就一定会使用系统代理，这是写死在代码里的…</p>
<p>而且 <code>URLRequestContextBuilder</code> 也没有提供额外的途径让我们修改；而一旦创建完 <code>URLRequestContext</code>，此时再设置新的 <code>ProxyService</code> 是没有用的…</p>
<p>我觉得这是一个设计上的失误，不知道新版本的代码有没有针对这块做了什么改动。</p>
<p>万幸，<code>URLFetcher</code> 对象可以通过 <code>SetLoadFlags()</code>，使用标志 <code>LOAD_BYPASS_PROXY</code> 来强迫当前 fetcher 对象绕过代理。</p>
<p>于是设计就变成：如果没有外部设置，fetcher 在发出请求前设置 <code>LOAD_BYPASS_PROXY</code>。</p>
<h3 id="Afterthoughts"><a href="#Afterthoughts" class="headerlink" title="Afterthoughts"></a>Afterthoughts</h3><p>在研究代码过程中我发现 <code>URLRequestContext</code> 理论上是可以使用自己定义的子类的；builder 创建的是内部实现的一个 <code>BasicURLRequestContext</code>。chromium 在这里的设计颇有点<strong>机制策略分离</strong>的意味。</p>
<p>不过因为这个问题发现在新版本即将提测前，因此就将这个想法列为后续的 TODO 了。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/02/monthly-read-posts-in-jun-2017/">Monthly Read Posts in June 2017</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-02
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><a href="https://github.com/nixzhu/dev-blog/blob/master/2015-10-08-navi.md" target="_blank" rel="noopener">一种头像缓存策略</a></p>
<p>本来还以为有什么惊天地的策略…这不是很普通的策略嘛…</p>
<p><a href="http://foonathan.net/blog/2016/07/23/move-safety.html" target="_blank" rel="noopener">Move Safety</a></p>
<p>这篇 post 引入了一个 move-safety 的概念；和 exception safety 类似，move safety 描述了一个实例被移动之后的 post-condition invariant.</p>
<p>Why do we need move safety? Because <code>std::move()</code> creates artificial temporaries, and we might want to use them again after the move operation.</p>
<p>4-Level Move Safety</p>
<ul>
<li>No move guarantee: copy only</li>
<li>Strong move safety: moved object is valid and well-defined; like std::unique_ptr</li>
<li>Basic move safety: moved object is valid, but its state is unspecified; like std::string, due to possible SSO.It is what the standard library guarantees for all types unless otherwise specified.</li>
<li>No move safety: the state is invalid, and you can only call its destructor, or assign it a new value.</li>
</ul>
<p><a href="https://blog.tartanllama.xyz/c++/2016/07/18/stack-and-heap/" target="_blank" rel="noopener">Stack and Heap</a></p>
<p>这篇 post 挺有意思。</p>
<p>作者观点是，无论 <em>heap</em> 还是 <em>stack</em> 来描述一个 C++ object 的 storage location 都是不准确的，因为标准并未规定 storage location 具体是什么，而规定了所谓的 storage duration：<strong>Storage duration defines the minimum potential lifetime of the storage that contains the object</strong>.</p>
<p>4 standard-defined storage duration:</p>
<ul>
<li>Static storage duration</li>
<li>Automatic storage duration</li>
<li>Thread storage duration</li>
<li>Dynamic storage duration</li>
</ul>
<p><a href="http://www.drdobbs.com/cpp/mixin-based-programming-in-c/184404445" target="_blank" rel="noopener">Mix-in Based Programming in C++</a><br><a href="https://yanniss.github.io/practical-fmtd.pdf" target="_blank" rel="noopener">Paper: Mixed based programming in C++</a></p>
<p>第一篇是介绍 mix-in 的 post，第二篇是在 mix-in 基础上提出一种 mix-in layer 的 paper。</p>
<p>mix-in 是一个挺有意思的 patter，但是因为没有自身语言支持，在 C++ 里的实现有时候会遇到比较 tricky 的问题。</p>
<p>第一篇 post 就提到了一个核心问题：如何有效地解决 mix-in classes 的 construction problem。但是讲真，post 里给出的 solution 有点诡异过头了；如果现实中的工程问题需要这样的一个解决方案，弃用 mix-in 弄不好是一个更靠谱的做法。</p>
<p>至于第二篇 paper，其实核心所谓的 mix-in layer，概括起来就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Next</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NUMBER</span> :</span> <span class="keyword">public</span> Next &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Workspace</span> :</span> <span class="keyword">public</span> Next::Workspace &#123;</span><br><span class="line">        <span class="comment">// Workspace role members</span></span><br><span class="line">    &#125;；</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> :</span> <span class="keyword">public</span> Next::Vertex &#123;</span><br><span class="line">        <span class="comment">// Vertex role members</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>paper 中还提到了对工程中使用 mix-in 的一些建议和 recommended practice，看看也还不错。</p>
<p><a href="https://insouciant.org/tech/connection-management-in-chromium/" target="_blank" rel="noopener">Connection Management in Chromium</a></p>
<p>Chromium 官方研发写的 post。</p>
<p>提到了他们试图解决 connection latency &amp; parallelism 的问题。</p>
<p>于是就有这么几个点：</p>
<p>Handshakes (including TCP handshake &amp; SSL handshake) are costly. Therefore, a better connection management is on demand.</p>
<p>Optimizations on transport layer (TCP or SPDY)</p>
<p>.etc</p>
<p><a href="https://www.preney.ca/paul/archives/486" target="_blank" rel="noopener">Apply tuple to function efficiently</a></p>
<p>Yet another implementation of apply-on-tuple</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/15/use-base-bind-with-std-function/">Use base::Bind With std::function</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-15
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><code>base::Bind()</code> 和 <code>base::Callback</code> 可以看作是对标准库 <code>std::bind()</code> 和 <code>std::function</code> 的模拟；因为 chromium 项目早在 C++ 11 正式通过前就已经存在好多年了。</p>
<p>我为直播姬设计新的网络通信基础组件时，接口的回调 handler 通常设计为 <code>std::function</code> 对象，因为它可以“吸收”任何函数对象，大多数情况下这个设计运转的非常良好；但是这里有一个略微棘手的问题： <code>base::Callback</code> 对象无法被 <code>std::function</code> 使用。</p>
<p>问题本质很简单，因为 <code>base::Callback</code> 不是一个 function object，因为它不支持以函数形式调用（没有提供 <code>operator()</code> 的重载），instead，它提供了一个 <code>Run()</code> 函数来执行这个 callback…</p>
<p>虽然我之前吐槽过好多次 chromium 的很多架构设计完全是 Java-Style 的，但是这里并不打算再拎出来批判一次，我们要聚焦的是如何解决这个问题。</p>
<p>解决思路很简单：既然它不是一个 function object，那么我们就给他包一层 function object 的皮就好了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/bind.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableCallback</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableCallback</span>&lt;R(Args...)&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">callback_t</span> = base::Callback&lt;R(Args...)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CallableCallback</span><span class="params">(<span class="keyword">callback_t</span> callback)</span></span></span><br><span class="line">        : callback_(callback)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callback_.Run(args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">callback_t</span> callback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callback&gt;</span><br><span class="line">auto MakeCallable(Callback callback)-&gt;CallableCallback&lt;typename Callback::RunType&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Sig = <span class="keyword">typename</span> Callback::RunType;</span><br><span class="line">    <span class="keyword">return</span> CallableCallback&lt;Sig&gt;(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助函数 <code>MakeCallable()</code> 可以将一个 <code>base::Callback</code> 对象转换成一个 function object。</p>
<p>一个简单的示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()</span><br><span class="line">        : msg_(<span class="string">"test"</span>), weak_ptr_factory_(<span class="keyword">this</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bark</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="string">":\t"</span> &lt;&lt; msg_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> msg_;</span><br><span class="line">    base::WeakPtrFactory&lt;Test&gt; weak_ptr_factory_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- test case 1 ---\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; fn(MakeCallable(base::Bind(&amp;Inc)));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn(<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- test case 2 ---\n"</span>;</span><br><span class="line">    Test* ptr = <span class="keyword">new</span> Test();</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; mfn(</span><br><span class="line">        MakeCallable(base::Bind(&amp;Test::Bark, ptr-&gt;weak_ptr_factory_.GetWeakPtr(), <span class="string">"inside"</span>)));</span><br><span class="line">    mfn();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"release test instance\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    mfn();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小巧优雅纯天然</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/05/activate-the-first-application-instance-when-there-is-one/">禁止程序多实例并存并且自动激活第一个实例</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-05
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>多实例检测非常常规，在程序启动时直接检查用来标记的内核对象是否存在即可，一般都是使用 <code>Mutex</code>。</p>
<p>麻烦的点在于如何激活第一个实例，显示它的主窗口。</p>
<p>某直播姬一开始的想法是利用 Pipe 建立 IPC 通讯连接，然后后续实例通过发送消息，让主实例 activate 自己的窗口。</p>
<p>嗯，看起来没毛病，但是做起来问题很多。</p>
<p>首先，IPC 建立需要时间，通讯需要时间，并且断开 IPC 后主实例（Windows 下）一定得需要重新创建一个 Pipe；更加诡异的是，我在本地编译的 Rlease 版本明明可以工作，利用构建机编译出来的版本，子实例管道连接一直失败….</p>
<p>于是看起来 IPC 是一个很自然地选择，实际上却是一个导致复杂度暴涨的下策。</p>
<p>另一个思路是创建一个 Event 内核对象，后续实例直接通过 signal 这个 event 内核对象来通知主实例。</p>
<p>但是这里实现起来有个麻烦的地方：如果要追求简单化，那么就需要一个单独的线程 wait 在这个内核对象上，负责接收通知，缺点是要浪费掉一个线程；如果不想资源浪费，那么考虑到很多框架都提供了 async i/o 的 wrapper，所以可以利用这个点，你开心的话可以挂到 IOCP 上。</p>
<p>嗯，等等，我们是想做啥来着？！</p>
<p>绕了一圈最后想想还是这样算了:</p>
<p>利用 <code>RegisterWindowMessage()</code> 注册一个自定义消息，主实例在 UI message loop / window message procedure 里监听这个消息；子实例启动后就利用 <code>BroadcastMessage()</code> 或者 <code>PostMessage()</code> 广播一下这个消息。</p>
<p>这样有个额外的好处，主实例收到消息直接是在 UI 线程，省掉一次 post task。</p>
<p>某直播姬最后采用的就是这个方案，为此我加了一个 class 起了个名字叫 <em>SingleInstanceGuarantor</em>，嗯，有点中二的感觉。</p>
<p>最后要注意一点，如果框架封装了 window procedure，将几个活动窗口的 window procedure 聚合到一个 message handler 里的话，可能会收到多条消息，可以利用消息的 timestamp 过滤一下。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/03/monthly-read-posts-in-may-2017/">Monthly Read Posts in May 2017</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-03
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><a href="http://cizixs.com/2015/10/06/http-resume-download" target="_blank" rel="noopener">http resumable download</a></p>
<p>虽然之前写直播姬自动更新时实现过续传下载，但是功能规范上并没有太完备；而这篇文章很好的补充了几个断点续传中，严格实现会遇到的几个 key points。</p>
<p>例如：不应当假设资源一定支持续传，要首先使用 request header <code>range</code> 检查目标资源是否支持续传，支持 <code>range</code> 的 http resonse code 是 206。</p>
<p>另外，两次断点下载期间，资源可能发生变化，需要在请求时同时附带上 <code>Etag</code> 或 <code>Last-modified</code> 记录，由服务器确定资源是否变化。</p>
<p><a href="http://mattwarren.org/2016/12/20/Why-Exceptions-should-be-Exceptional/" target="_blank" rel="noopener">Why Exceptions Should be Exceptional</a></p>
<p>文章从性能角度阐述了为什么不能将 exception 机制作为 routine control flow。</p>
<p>但是个人认为这个切入角度不好，因为很容易给人一种异常机制开销大的错觉，导致读者之后避开使用异常。</p>
<p>异常处理一直都是一个大麻烦，相比 error code handling 不够直观，没有足够的经验很难控制好，加上某些语言自身特性导致固有复杂度暴涨（例如 C++）。</p>
<p><a href="http://shaharmike.com/cpp/shared-ptr/" target="_blank" rel="noopener">shared-ptr</a></p>
<p>文章大部分的内容（除了 aliasing）其实 <em>Effective Modern C++</em> 里都有…</p>
<p><a href="https://adishavit.github.io/2016/magical-captureless-lambdas/" target="_blank" rel="noopener">Magical Captureless Lambdas</a></p>
<p>核心总结出来就是一句话：Captureless lambdas 能够自动转换为对应的 C-Style 函数指针，而在 MSVC 里，implicit cast 能够自动处理不同的 calling convention</p>
<p><a href="https://adishavit.github.io/2016/leaky-closures-captureless-lambdas/" target="_blank" rel="noopener">Leaky Closures Captureless Lambdas</a></p>
<p>An entity that is mentioned or used but is not ODR-used within the lambda body, does not need to be captured in the capture list.</p>
<p>Informally, an object is odr-used if its address is taken, or a reference is bound to it.</p>
<p><a href="http://videocortex.io/2016/lambdas-callbacks/" target="_blank" rel="noopener">Lambdas Callbacks</a></p>
<p>又名：如何用 capturing lambdas 作为 c-style callbacks</p>
<p><a href="https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html" target="_blank" rel="noopener">Combining Static and Dynamic Polymorphism with C++ Template Mixins</a><br><a href="http://www.thinkbottomup.com.au/site/blog/C%20%20_Mixins_-_Reuse_through_inheritance_is_good" target="_blank" rel="noopener">C++ Mixins - Reuse through inheritance is good when done the right way</a></p>
<p>Mixins pattern in C++ 快速导读</p>
<p><a href="https://mortoray.com/2016/08/10/the-very-real-mess-of-virtual-functions/" target="_blank" rel="noopener">The Very Real Mess of Virtual Functions</a></p>
<p>十足标题党</p>
<p>并且个人认为，作者试图解决一个前提错误的问题。</p>
<p>文中以 <code>Init()</code> 和 <code>UnInit()</code> 为例阐述观点，然而，这正好说明了为什么如无必要不应该使用 two-phase initialization</p>
<p>文中试图实现的机制不就是 ctor 和 dtor 所做的么……</p>
<p>而对于其他可能需要子类调用父类虚函数的场景，我认为，non-vitual-interface idiom已经足够了。</p>
<p>BTW：就工程领域而言，可能对 GUI 框架来说，文中的一些套路还是有用的；不过因为个人在这方面没有什么经验，因此持保留意见</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/15/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/17/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
