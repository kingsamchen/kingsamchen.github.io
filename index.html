<!DOCTYPE html>
<html lang="default">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gone with the ruins"/>













  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://kingsamchen.github.io/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/11/use-lambda-with-post-task/">Use Lambda With PostTask</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-11
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>曾经为了能在 <code>PostTask()</code> 里使用 lambda，实现了一个自动将 non-capturing lambda decay 到对应函数指针，在利用 <code>base::Bind()</code> 的方案<a href="https://kingsamchen.github.io/2017/01/11/automatically-convert-non-capturing-lambdas-to-normal-function-pointers/">[1]</a>。</p>
<p>但是在使用过程中发现这个方案有几个弊端：</p>
<ol>
<li>因为只能使用 non-capture lambda，因此如果需要上下文，只能通过参数传入，这样代码写起来会很蛋疼</li>
<li>VS 2013 + Resharper 的环境下，使用 <code>lambda_decay()</code> 的代码经常会出现静态分析的错误提示（不清楚是 VS2013 还是 Resharper 的问题），导致每段代码下面都会出现红色的曲线，非常惹眼</li>
</ol>
<p>这两天因为需要重构某个模块，又顺便思考了这个问题，后来发现之前一开始思路不太对。</p>
<p>没有必要做一个兼容 <code>base::Bind()</code> 的解决方案，因为需要的只是在 message-loop 的 PostTask 里使用，这样只要能够将 lambda 包裹到一个 <code>base::Callback&lt;R()&gt;</code> 里就可以了，至于是不是利用 <code>base::Bind()</code> 完成，并不重要！</p>
<p>结合之前做的 <code>base::Callback</code> 到 <code>std::function</code> 的<a href="https://kingsamchen.github.io/2017/06/15/use-base-bind-with-std-function/">转换</a>，很自然的想到一个最终解决方案。</p>
<p>代码其实非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line">auto InvokeLambda(const std::function&lt;R()&gt;&amp; fn) -&gt; R</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">auto BindLambda(F&amp;&amp; lambda) -&gt; base::Callback&lt;typename std::result_of&lt;F()&gt;::type()&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F()&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base::Bind(InvokeLambda&lt;return_type&gt;, <span class="built_in">std</span>::function&lt;return_type()&gt;(<span class="built_in">std</span>::forward&lt;F&gt;(lambda)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断返回类型是因为 <code>PostTaskAndReplyWithResult()</code> 会要求第一个 closure 有指定的返回值，以便第二个 clsoure 使用。</p>
<p>使用的时候就</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"hello, world"</span>;</span><br><span class="line">base::Closure closure = BindLambda([&amp;s] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value of s: "</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">closure.Run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cb = BindLambda([] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"with int result\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cb.Run();</span><br></pre></td></tr></table></figure>
<p>为了使用方便，我直接往 chromium base 开了一个 ext，作为以后的扩展。</p>
<p>因为现在 lambda 可以直接捕捉了，所以重构之后的代码看起来更具可读性；当然前提是要小心被捕捉对象的生命周期，通常这个上下文都应该使用 capture-by-value。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/03/compile-libx264-with-asm-optimization-with-vcpkg/">利用 vcpkg 编译带汇编优化的 libx264</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-03
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>使用 vcpkg 编译 libx264 有一个很重要的原因：可以获得 PDB，而且构建流程被大大精简了。</p>
<p>但是这里有一个坑：vcpkg 上的 libx264 模块编译默认是开启了 <code>--disable-asm</code>，意味着构建之后的二进制不会使用 SIMD 指令集，所以性能上会有很大的问题。</p>
<p>研究了一番之后找到了开启汇编优化的方案。</p>
<ol>
<li><p>从官网下载并安装 nasm-2.13</p>
<p> vcpkg 上通过 acquire-program 提供的 nasm 只有 2.12；而编译 vcpkg 上提供的 libx264-152 需要 nasm-2.13</p>
</li>
<li><p>编辑 libx264 的 portfile.cmake 文件</p>
<p> 在 set bash 的后面加一行</p>
 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;PATH&#125; <span class="string">"c:/Programs/NASM/;$ENV&#123;PATH&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p> 这里注意替换你的真实安装目录</p>
<p> 然后去掉构建参数中的 <code>--disable-asm</code></p>
</li>
</ol>
<p>如果还有地方出错，记得根据提示查日志！</p>
<p>开启汇编优化后生成的二进制会略大，大概 900 多 KB</p>
<p>最后赞扬一下微软出品的 vcpkg，真是解决了 Windows 下编译一众开源软件的痛点。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/01/monthly-read-posts-in-mar-2018/">Monthly Read Posts in Mar 2018</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-01
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><a href="http://akumuli.org/akumuli/2015/03/19/sequencer/" target="_blank" rel="noopener">Sorting, caching and concurrency</a></p>
<p>通过引入基于时间的 sliding window 来标记并剔除（大概率）由错误产生的数据；并且可以利用 SW 来 schedule 数据什么时候从内存持久化到磁盘。</p>
<p>Patience sort 是 merge-sort 的一种变体，适合对 slightly unordered data 进行排序，最坏情况下退化为 merge-sort。</p>
<p>实现 optimistic locking 来避免使用 reader-writer locks，进而防止写饥饿。</p>
<blockquote>
<p>引入一个原子的 sequence-number，初始状态为0；并且</p>
<ul>
<li>merge 操作开始时，sequence-number 自增</li>
<li>merge 操作结束时，sequence-number 同样自增<br>于是利用 sequence-number 的奇偶性来区分某个操作是否结束</li>
</ul>
<p>如果写操作开始但是未完成，则读操作进行退避&amp;重试。</p>
</blockquote>
<p>感觉作者这么做应该是结合了业务的上下文；这个 optimistic locking 的策略至少有这么几个前提：</p>
<ol>
<li>写操作很重要，不能有明显的延迟</li>
<li>写操作不会太慢，至少不会导致读操作的延迟超过无法承受的范围</li>
<li>平台提供的 reader-writer locks 对 writer starvation 的防治策略做的不够好</li>
</ol>
<hr>
<p><a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/" target="_blank" rel="noopener">An Introduction to Lock-Free Programming</a></p>
<p>非常赞的 Lock-free 入门文章。</p>
<p>覆盖了 concepts, CAS operations, memory ordering &amp; memory models</p>
<p>注：作者 preshing 是个 concurrency programming 领域的大触</p>
<hr>
<p><a href="https://getpocket.com/a/read/994738352" target="_blank" rel="noopener">Gentle Introduction to Lockless Concurrency</a></p>
<p>同样也是一篇 lock-free 的入门文章，但是这这篇文章比起上一篇就差太多了，明显不是一个层次的。</p>
<p>这篇是基于 Java 来谈 lockless，涉及的点明显局限在了语言自身，没有 preshing 那种站在 bare-metal 角度的犀利。</p>
<p>注：原文找不到了，大概率被作者自己删了，因此只有 pocket 的备份</p>
<hr>
<p><a href="https://www.brianstorti.com/the-actor-model/" target="_blank" rel="noopener">The actor model in 10 minutes</a></p>
<p>一篇非常赞的 actor model 的介绍文章。</p>
<p>直接开篇就把模型的本质是 actor，以及 actor 的核心（primitive unit for computation &amp; message passing）讲明了。</p>
<p>然后延伸到 fault tolerance 和 distribution 上的优势。</p>
<p>内容比 <em>7 Concurrency Models in 7 Weeks</em> 要好多了，讽刺的是这本书还是这篇文章的 reference 之一。</p>
<hr>
<p><a href="https://www.youtube.com/watch?v=_fu0gx-xseY" target="_blank" rel="noopener">CppCon 2015: Gor Nishanov “C++ Coroutines - a negative overhead abstraction”</a></p>
<p>总结起来就是：</p>
<ul>
<li>我们其实很早就开始应用 coroutines 了</li>
<li>Concurrency TS 里提供的 CPS 也不是万能药</li>
<li>Coroutine is good, and We want coroutines!</li>
</ul>
<hr>
<p><a href="https://www.youtube.com/watch?v=mPxIegd9J3w" target="_blank" rel="noopener">CppCon 2015: Artur Laksberg “Concurrency TS Editor’s Report”</a></p>
<p>Brief introduction to concurrency ts.</p>
<p>涵盖了三点：</p>
<ul>
<li>better std::future (with continutation &amp; async/await)</li>
<li>latch &amp; barrier</li>
<li>atomic shared_ptr</li>
</ul>
<hr>
<p><a href="https://www.youtube.com/watch?v=fZjYCQ8dzTc" target="_blank" rel="noopener">CppCon 2015: Scott Schurr “constexpr: Introduction”</a><br><a href="https://www.youtube.com/watch?v=qO-9yiAOQqc" target="_blank" rel="noopener">CppCon 2015: Scott Schurr “constexpr: Applications”</a></p>
<p>第一篇是 <code>constexpr</code> 入门介绍。</p>
<p>演讲者挺有意思。另外最后面利用 unresolved symbol 来 force as compile time error 有点意思</p>
<p>第二篇，重点来了，干货十足，compile-time containers 可以研究好一会儿。</p>
<p>这下基本能明白为什么这哥们要开两个 talk 了，因为一个 talk 这么多内容说不玩啊。</p>
<hr>
<p><a href="http://www.thinkingparallel.com/2007/02/19/please-dont-rely-on-memory-barriers-for-synchronization/" target="_blank" rel="noopener">Please Don’t Rely on Memory Barriers for Synchronization!</a></p>
<p>文章实际上是一片批判文，但是被批判的文章被作者删除了（估计是被喷得太惨了），所以不能拿来做交叉对比。。</p>
<p>文章核心是在强调原则性的做法，但是因为主要是为了批评，所以没有太多的干活，总结一下就是：</p>
<ul>
<li>多看书，不要当民科，自己<strong>发明</strong>轮子</li>
<li>如无必要，不要使用 memory barrier 这种过于底层且没有移植性的东西</li>
<li>锁不慢，这篇文章很容易给人错的观念</li>
<li>先写对，再写快（老生常谈）</li>
</ul>
<hr>
<p><a href="https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html" target="_blank" rel="noopener">Overview of syslog</a></p>
<p>（Unix/Linux）系统提供的日志存储仓，对应的 daemon 叫 syslogd，使用的 Unix Domain Socket 名是 <code>/dev/log</code>。</p>
<p>程序可以使用 syslog.h 文件中的 <code>syslog()</code> 或 <code>vsyslog()</code> 函数往 syslog 写消息，一条消息最重要的有两部分：</p>
<ul>
<li>facility，表明谁发的消息</li>
<li>priority，消息的重要程度</li>
</ul>
<hr>
<p><a href="https://www.youtube.com/watch?v=CZi6QqZSbFg" target="_blank" rel="noopener">C++ Metaprogramming - Fedor Pikus - CppCon 2015</a></p>
<p><a href="https://www.youtube.com/watch?v=cg1wOINjV9U" target="_blank" rel="noopener">C++ metaprogramming- a paradigm shift - Louis Dionne - CppCon 2015</a></p>
<p>两个和 C++ TMP 有关的 talk。</p>
<p>前者是 introduction 性质的，后者嘛。。。其实就是 Boost.Hana 的宣传广告</p>
<hr>
<p><a href="http://blog.csdn.net/myan/article/details/1482614" target="_blank" rel="noopener">Java替代C语言的可能性</a></p>
<p>作者（当时）认为这不存在可能性，总结了三个原因</p>
<ol>
<li>Java 程序员的平局水平比起 C 程序员的平均水平还有明显差距，尤其对底层、结构体系的理解</li>
<li>内存占用过高，带来一系列的性能问题，导致目前（当时）且一段时间内只能做上层应用</li>
<li>思维方式的问题，Java 程序员被厚重的框架束缚思维</li>
</ol>
<p>虽然这是一篇10年前的文章，但是不得不说作者眼光独到。</p>
<p>现在这三个问题依旧，而且目前 Java 在互联网公司的主战场主要是 Android 开发（受到 Kotlin 挑战）和服务端（中间件，上层 web 服务，受到 Go 冲击），确实还未侵入 C 的核心领域。</p>
<p>不过个人感觉，未来编程面对的抽象层次会越来越高。</p>
<hr>
<p><a href="https://blog.csdn.net/myan/article/details/1906" target="_blank" rel="noopener">垃圾收集机制(Garbage Collection)批判</a></p>
<p>作者（当时）吐槽主要来自于：繁忙时刻且内存没有明显压力时不会触发 GC，而当内存有明显压力感知的时候，一次 GC 会导致极大的开销。</p>
<hr>
<p><a href="https://coelhorjc.wordpress.com/2014/12/18/using-non-blocking-and-asynchronous-io-ck10-problem-in-linux-and-windows-with-epool-iocp-aiolibaio-libeventlibevlibuv-boost-asio/" target="_blank" rel="noopener">USING NON-BLOCKING AND ASYNCHRONOUS I/O (CK10 PROBLEM) IN LINUX AND WINDOWS (WITH EPOOL, IOCP, LIBEVENT/LIBEV/LIBUV/BOOST.ASIO AND LIBRT/LIBAIO)</a></p>
<p>C10K 问题下的各种解决方案。</p>
<p>从基础的 reactor（epoll / kqueue）到 proactor （IOCP）</p>
<p>同时涉及当前流行的网络框架：libev, libeio .etc</p>
<p>适合技术选型或者了解各平台下实现高性能并发处理的方式</p>
<hr>
<p><a href="http://www.sean-bollin.com/2017/05/01/reactor-vs-proactor-part-1-the-reactor/" target="_blank" rel="noopener">Reactor vs. Proactor: Part 1 – The Reactor</a></p>
<p>PART 1 简单给予 epoll 做了几个例子。</p>
<p>例子代码写得不好，甚至还出现了利用异常做控制流…</p>
<p>还好作者太监了没有后续。</p>
<hr>
<p><a href="http://insanecoding.blogspot.co.uk/2013/04/designing-c-functions-to-writesave-to.html" target="_blank" rel="noopener">Designing C++ functions to write/save to any storage mechanism</a></p>
<p>这篇文章写于 2011 年，这个背景很重要。</p>
<p>在进入 C++ 11 的时代前，相当一部分 C++ 程序员还是<strong>只适应</strong>通过 OO 去构造抽象；而本身就是设计反面教科书的 ostream 体系让相当一部分人在错误的道路上越走越远。</p>
<p>作者吐槽的就是这点。</p>
<p>后文给出的 solution 说穿了其实就是，利用 template 进行依赖注入。</p>
<p>所有写操作，无论是写文件还是写 DB 还是写网络，核心都基于一个具体的 function object，而这个 function object 可以通过 template parameter 进行依赖解耦。</p>
<p>C++ 11 引入的 <code>std::bind()</code>、 lambda、甚至 <code>std::function</code> 都更加明确了条路子。</p>
<p>这篇文章有点类似孟岩曾经写的利用 bind + function 去避免继承（运行时多态）的滥用。</p>
<hr>
<p><a href="https://computing.llnl.gov/tutorials/pthreads/" target="_blank" rel="noopener">POSIX Threads Programming</a></p>
<p>Pthreads 简明教程。</p>
<p>覆盖</p>
<ul>
<li>threads VS process (Why using threads)</li>
<li>pthreads 介绍</li>
<li>pthreads 创建/销毁</li>
<li>mutex</li>
<li>condition variable</li>
</ul>
<p>可以作为入门级读物。</p>
<hr>
<p><a href="http://insanecoding.blogspot.co.uk/2014/05/copying-code-copying-implementation.html" target="_blank" rel="noopener">Copying code != Copying implementation</a></p>
<p>一开始我还以为是作者专门写文章解释他为什么会 copy code，看完才发现不是这样。</p>
<p>作者的观点是：（遵守 license）从开源项目里抄代码直接用是不靠谱的，一定要注意，代码所处的上下文，搞清楚是不是有什么 prerequisites 或者 hidden requirements。</p>
<p>中间还专门举了几个例子。</p>
<hr>
<p><a href="https://medium.com/@AikoPath/visualising-and-prioritizing-technical-debt-afc82e542681" target="_blank" rel="noopener">Visualising and Prioritizing Technical Debt</a></p>
<p>核心：将技术债具象化，无论是采用四象限法还是技术债树。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/30/demystify-shared-ptr-and-weak-ptr-in-libstdcpp/">浅析 shared_ptr：Libstdc++ 篇</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-30
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>序言请移步<a href="https://kingsamchen.github.io/2018/03/13/shared-ptr-internals-introduction/">此处</a></p>
<p>MSVC STL 的分析版本请移步<a href="https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">此处</a></p>
<p>注：因为这不是第一篇分析，所以会直入主题，跳过文学写作常用的累赘的过渡。</p>
<h2 id="版本选择与源码位置"><a href="#版本选择与源码位置" class="headerlink" title="版本选择与源码位置"></a>版本选择与源码位置</h2><p>目前的工作机是 Linux Mint 18，对应的是 Ubuntu 16.04 LTS。</p>
<p>这个版本的系统上源包默认提供的是 GCC 5.4 和 clang 3.8，跟随的 libstdc++ 的大版本是 6。</p>
<p>考虑到 Linux 上 clang 也是默认使用 libstdc++，且 GCC 6/7/8 使用的 libstdc++ 的大版本都是 6，因此直接选用目录 <code>/usr/include/c++/5</code> 下的源码作为研究对象。</p>
<h2 id="How-shared-ptr-new-T-differs-from-make-shared"><a href="#How-shared-ptr-new-T-differs-from-make-shared" class="headerlink" title="How shared_ptr(new T()) differs from make_shared()"></a>How shared_ptr(new T()) differs from make_shared()</h2><p>函数 <code>make_shared()</code> 位于文件 shared_ptr.h：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Create an object that is owned by a shared_ptr.</span></span><br><span class="line"><span class="comment">*  @param  __args  Arguments for the @a _Tp object's constructor.</span></span><br><span class="line"><span class="comment">*  @return A shared_ptr that owns the newly created object.</span></span><br><span class="line"><span class="comment">*  @throw  std::bad_alloc, or an exception thrown from the</span></span><br><span class="line"><span class="comment">*          constructor of @a _Tp.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;</span><br><span class="line">make_shared(_Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_const&lt;_Tp&gt;::type _Tp_nc;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::allocate_shared&lt;_Tp&gt;(<span class="built_in">std</span>::allocator&lt;_Tp_nc&gt;(), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数内部直接将操作转交给了 <code>std::allocate_shared</code>。这个函数虽然是 <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared" target="_blank" rel="noopener">C++ 11 引入</a>的，但是似乎是从 boost 沿袭而来，我们在 MSVC STL 的分析里并未见到过。</p>
<p>注：reference 上对这个函数的描述简洁明了，点名了就是用来实现一次内存分配的。事实上截止到 Visual Studi 2017 15.6.3，这个函数还只在 TR1 名字空间里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Create an object that is owned by a shared_ptr.</span></span><br><span class="line"><span class="comment">*  @param  __a     An allocator.</span></span><br><span class="line"><span class="comment">*  @param  __args  Arguments for the @a _Tp object's constructor.</span></span><br><span class="line"><span class="comment">*  @return A shared_ptr that owns the newly created object.</span></span><br><span class="line"><span class="comment">*  @throw  An exception thrown from @a _Alloc::allocate or from the</span></span><br><span class="line"><span class="comment">*          constructor of @a _Tp.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  A copy of @a __a will be used to allocate memory for the shared_ptr</span></span><br><span class="line"><span class="comment">*  and the new object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;</span><br><span class="line">allocate_shared(<span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(_Sp_make_shared_tag(), __a,</span><br><span class="line">                <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by allocate_shared.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="built_in">shared_ptr</span>(_Sp_make_shared_tag __tag, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__tag, __a, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>__shared_ptr</code> 是 <code>shared_ptr</code> 的基类，相当于 MSVC STL 里的 <code>_Ptr_base</code>，包含在文件 <code>shared_ptr_base.h</code> 里。</p>
<p>我们分别看一下 <code>__shared_ptr</code> 的基本成员，以及这个非标准的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="comment">// Omit irrelavent code</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Tp*	   	   _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by allocate_shared.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_ptr(_Sp_make_shared_tag __tag, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : _M_ptr(),</span><br><span class="line">      _M_refcount(__tag, (_Tp*)<span class="number">0</span>, __a, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line">    <span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line">    <span class="keyword">void</span>* __p = _M_refcount._M_get_deleter(<span class="keyword">typeid</span>(__tag));</span><br><span class="line">    _M_ptr = <span class="keyword">static_cast</span>&lt;_Tp*&gt;(__p);</span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这个构造函数有两个版本的实现，分别对应是否开启 RTTI，这里选用默认的使用 RTTI 的版本。</p>
<p>基类也是有两个成员：</p>
<ol>
<li>实例指针</li>
<li>引用计数控制块</li>
</ol>
<p>实际的构造操作依旧由引用计数控制块 <code>__shared_count</code> 完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_count</span> &#123;</span></span><br><span class="line">    <span class="comment">// Omit irrelavent code</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;*  _M_pi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_count(_Sp_make_shared_tag, _Tp*, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">: _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;</span><br><span class="line">    <span class="keyword">typename</span> _Sp_cp_type::__allocator_type __a2(__a);</span><br><span class="line">    <span class="keyword">auto</span> __guard = <span class="built_in">std</span>::__allocate_guarded(__a2);</span><br><span class="line">    _Sp_cp_type* __mem = __guard.get();</span><br><span class="line">    ::<span class="keyword">new</span> (__mem) _Sp_cp_type(<span class="built_in">std</span>::move(__a),</span><br><span class="line">                <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    _M_pi = __mem;</span><br><span class="line">    __guard = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分实现比 MSVC STL 要复杂，因为牵扯到了 allocator。</p>
<p>实话说，我对 allocator 不熟悉，也从来没用过 customized allocator；同时这里使用的 allocator 相关函数大多是 libstdc++ 自己定义的，因此这块仅在宏观上提一下，不做深入分析。有兴趣的可以自己跟踪一下源代码。</p>
<p>首先，<code>_Sp_counted_ptr_inplace</code> 是 <code>_Sp_counted_base</code> 的子类，这个类有一个内部类，并且类自身只有一个这个内部类的成员（略去了不相关代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line">class _Sp_counted_base : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    _Atomic_word  _M_use_count;     <span class="comment">// #shared</span></span><br><span class="line">    _Atomic_word  _M_weak_count;    <span class="comment">// #weak + (#shared != 0)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Sp_counted_ptr_inplace</span> <span class="title">final</span> :</span> <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Impl</span> :</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Alloc&gt; &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Alloc&gt;	_A_base;</span><br><span class="line"></span><br><span class="line">        __gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _Impl _M_impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，父类 <code>_Sp_counted_base</code> 包含了两个计数成员，同时子类 <code>_Sp_counted_ptr_inplace</code> 通过内部的 <code>_Impl</code>，引入了一块存储空间，大小是最外层 <code>share_ptr</code> 要管理的对象实例的大小。</p>
<p>这样一来，被管理对象的内存和控制块的内存也被组织在了一块内存上。</p>
<p>接下来研究如何分配那整块的内存；这和前面三句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> _Sp_cp_type::__allocator_type __a2(__a);</span><br><span class="line"><span class="keyword">auto</span> __guard = <span class="built_in">std</span>::__allocate_guarded(__a2);</span><br><span class="line">_Sp_cp_type* __mem = __guard.get();</span><br></pre></td></tr></table></figure>
<p>有关。</p>
<p>上面通过 <code>_Sp_counted_ptr_inplace</code> 内部定义的 allocator，利用 <a href="http://en.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">allocator rebind</a>，获取能够以 <code>_Sp_counted_ptr_inplace</code> 为粒度进行分配的 allocator，并随后分配了一块内存，也就是 <code>_mem</code> 引用的那块。</p>
<p>有了内存块之后，剩下的就是调用 in-placement new 构造出 <code>_Sp_counted_ptr_inplace</code> 对象。</p>
<p>接下来看一下顶层的 <code>__Shared_ptr::_M_ptr</code> 是如何关联到 <code>_Sp_counted_ptr_inplace</code> 里的实例成员地址的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line"><span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line"><span class="keyword">void</span>* __p = _M_refcount._M_get_deleter(<span class="keyword">typeid</span>(__tag));</span><br><span class="line">_M_ptr = <span class="keyword">static_cast</span>&lt;_Tp*&gt;(__p);</span><br></pre></td></tr></table></figure>
<p>依赖 <code>_M_get_deleter</code> 是什么鬼…看一下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class __shared_count</span></span><br><span class="line"><span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp; __ti) <span class="keyword">const</span> <span class="keyword">const</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class _Sp_counted_ptr_inplace</span></span><br><span class="line"><span class="comment">// Sneaky trick so __shared_ptr can get the managed pointer</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp; __ti) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_rtti</span></span><br><span class="line">	<span class="keyword">if</span> (__ti == <span class="keyword">typeid</span>(_Sp_make_shared_tag))</span><br><span class="line">	  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Tp* _M_ptr() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_impl._M_storage._M_ptr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是拿到 <code>_Sp_counted_ptr_inplace::Impl</code> 内部 <code>__gnu_cxx::__aligned_buffer</code> 的数据地址。</p>
<p>这里的 RTTI 的操作看得我一脸懵逼……</p>
<p>接下来看一下针对形如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; sp(<span class="keyword">new</span> T());</span><br></pre></td></tr></table></figure>
<p>的内部实现流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Construct a %shared_ptr that owns the pointer @a __p.</span></span><br><span class="line"><span class="comment"> *  @param  __p  A pointer that is convertible to element_type*.</span></span><br><span class="line"><span class="comment"> *  @post   use_count() == 1 &amp;&amp; get() == __p</span></span><br><span class="line"><span class="comment"> *  @throw  std::bad_alloc, in which case @c delete @a __p is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="keyword">explicit</span> __shared_ptr(_Tp1* __p)</span><br><span class="line">    : _M_ptr(__p), _M_refcount(__p) <span class="comment">// &lt;- set up instance ptr &amp; ref-count object</span></span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="keyword">static_assert</span>( !is_void&lt;_Tp1&gt;::value, <span class="string">"incomplete type"</span> );</span><br><span class="line">    <span class="keyword">static_assert</span>( <span class="keyword">sizeof</span>(_Tp1) &gt; <span class="number">0</span>, <span class="string">"incomplete type"</span> );</span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line"><span class="keyword">explicit</span> __shared_count(_Ptr __p)</span><br><span class="line">    : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        _M_pi = <span class="keyword">new</span> _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);    <span class="comment">// &lt;- use _Sp_counted_ptr as ref-count object here</span></span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> __p;</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在这种使用场合下，ref-count 的具体数据类型是 <code>_Sp_counted_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counted ptr with no deleter or allocator support</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Sp_counted_ptr</span> <span class="title">final</span> :</span> <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> _Sp_counted_ptr(_Ptr __p) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_ptr(__p)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp;) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Sp_counted_ptr(<span class="keyword">const</span> _Sp_counted_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    _Sp_counted_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> _Sp_counted_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ptr _M_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仅仅调用构造函数初始化了内部保存的 <code>_M_ptr</code>，毕竟管理的实例对象已经创建完毕了。</p>
<p>至此整个初始化流程都已经结束了。</p>
<p><strong>Conclusion</strong></p>
<p>和 MSVC STL 的实现类似，<code>make_shared()</code> 内部保证只有一次内存分配，实例对象和计数控制块都在一块内存上，而 <code>shared_ptr()</code> 的构造就简单很多，只需要初始化计数块，同时设置对应的实例指针即可。</p>
<p>并且，两种 case 下，具体使用的 ref-count 的对象是不一样的，这可以做到针对性的优化。</p>
<p>不同点也比较明显：libstdc++ STL 多了一个 <code>shared_count</code> 中间层；同时 <code>make_shared()</code> 内部的内存分配大量依赖 allocator。</p>
<h2 id="Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer"><a href="#Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer" class="headerlink" title="Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer"></a>Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer</h2><p>这种 case 是通过 <code>shared_ptr</code> 的构造函数创建对象，只需要跟相关的 ctor 即可。</p>
<p>和 MSVC STL 类似，ctor 自身也是一个 template，参数为 <code>_Tp1</code>，并且这个参数一直通过 <code>__shared_ptr</code> - <code>__shared_count</code> - <code>_Sp_counted_ptr</code> 的 ctor template 将实际类型保存到了 <code>_Sp_counted_ptr::_M_ptr</code> 中。</p>
<p>释放实例的 <code>_Sp_counted_ptr::_M_dispose()</code> 仅仅简单的调用了一下 delete expression</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type"><a href="#How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type" class="headerlink" title="How Custom Deleter Works and Why It Is Not Part of the Type"></a>How Custom Deleter Works and Why It Is Not Part of the Type</h2><p>支持 custom deleter 同样需要通过构造函数创建对应的 <code>shared_ptr</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Construct a %shared_ptr that owns the pointer @a __p</span></span><br><span class="line"><span class="comment"> *          and the deleter @a __d.</span></span><br><span class="line"><span class="comment"> *  @param  __p  A pointer.</span></span><br><span class="line"><span class="comment"> *  @param  __d  A deleter.</span></span><br><span class="line"><span class="comment"> *  @post   use_count() == 1 &amp;&amp; get() == __p</span></span><br><span class="line"><span class="comment"> *  @throw  std::bad_alloc, in which case @a __d(__p) is called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Requirements: _Deleter's copy constructor and destructor must</span></span><br><span class="line"><span class="comment"> *  not throw</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  __shared_ptr will release __p by calling __d(__p)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line"><span class="built_in">shared_ptr</span>(_Tp1* __p, _Deleter __d)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__p, __d)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，直接托管给负责干活的父类 <code>__shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line">__shared_ptr(_Tp1* __p, _Deleter __d)</span><br><span class="line">    : _M_ptr(__p),</span><br><span class="line">      _M_refcount(__p, __d)</span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="comment">// TODO requires _Deleter CopyConstructible and __d(__p) well-formed</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着又通过构造函数参数转入计数控制块 <code>_M_refcount</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter&gt;</span><br><span class="line">__shared_count(_Ptr __p, _Deleter __d)</span><br><span class="line">    : __shared_count(__p, <span class="built_in">std</span>::move(__d), allocator&lt;<span class="keyword">void</span>&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">__shared_count(_Ptr __p, _Deleter __d, _Alloc __a)</span><br><span class="line">    : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typename</span> _Sp_cd_type::__allocator_type __a2(__a);</span><br><span class="line">        <span class="keyword">auto</span> __guard = <span class="built_in">std</span>::__allocate_guarded(__a2);</span><br><span class="line">        _Sp_cd_type* __mem = __guard.get();</span><br><span class="line">        ::<span class="keyword">new</span> (__mem) _Sp_cd_type(__p, <span class="built_in">std</span>::move(__d), <span class="built_in">std</span>::move(__a));</span><br><span class="line">        _M_pi = __mem;</span><br><span class="line">        __guard = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        __d(__p); <span class="comment">// Call _Deleter on __p.</span></span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出：</p>
<ol>
<li>这种情况下使用的具体 ref-count 类型是 <code>_Sp_counted_deleter</code></li>
<li>这里的内存分配依然是通过 allocator</li>
<li>deleter 和托管实例的类型通过 template paramter 一路保存了下来。因为 deleter 可能只认识创建时传递的指针类型（考虑 aliasing construction）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support for custom deleter and/or allocator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span> _Deleter, <span class="keyword">typename</span> _Alloc, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Sp_counted_deleter</span> <span class="title">final</span> :</span> <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Impl</span> :</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Deleter&gt;, _Sp_ebo_helper&lt;<span class="number">1</span>, _Alloc&gt; &#123;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">0</span>, _Deleter&gt; _Del_base;</span><br><span class="line">        <span class="keyword">typedef</span> _Sp_ebo_helper&lt;<span class="number">1</span>, _Alloc&gt; _Alloc_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        _Impl(_Ptr __p, _Deleter __d, <span class="keyword">const</span> _Alloc&amp; __a) <span class="keyword">noexcept</span></span><br><span class="line">            : _M_ptr(__p),</span><br><span class="line">              _Del_base(__d),</span><br><span class="line">              _Alloc_base(__a)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        _Deleter&amp; _M_del() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> _Del_base::_S_get(*<span class="keyword">this</span>); &#125;</span><br><span class="line">        _Alloc&amp; _M_alloc() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> _Alloc_base::_S_get(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">        _Ptr _M_ptr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __d(__p) must not throw.</span></span><br><span class="line">    _Sp_counted_deleter(_Ptr __p, _Deleter __d) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_impl(__p, __d, _Alloc()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __d(__p) must not throw.</span></span><br><span class="line">    _Sp_counted_deleter(_Ptr __p, _Deleter __d, <span class="keyword">const</span> _Alloc&amp; __a) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_impl(__p, __d, __a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~_Sp_counted_deleter() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _M_impl._M_del()(_M_impl._M_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span>* _M_get_deleter(<span class="keyword">const</span> <span class="built_in">std</span>::type_info&amp; __ti) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_rtti</span></span><br><span class="line">        <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">        <span class="comment">// 2400. shared_ptr's get_deleter() should use addressof()</span></span><br><span class="line">        <span class="keyword">return</span> __ti == <span class="keyword">typeid</span>(_Deleter)</span><br><span class="line">            ? <span class="built_in">std</span>::__addressof(_M_impl._M_del())</span><br><span class="line">            : <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Impl _M_impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，deleter 和 allocator 直接通过基类“组合”进了 ref-count 块。</p>
<p><strong>Conclusion</strong></p>
<p><code>shared_ptr&lt;T&gt;</code> 仅决定 <code>__shared_ptr::_M_ptr</code> 的类型，实例的运行时类型和 deleter 均保存在 <code>_Sp_counted_delter</code> 中，这个类通过 <code>__shared_ptr::_M_refcont</code> 关联。</p>
<h2 id="How-enable-shared-from-this-works"><a href="#How-enable-shared-from-this-works" class="headerlink" title="How enable_shared_from_this works"></a>How enable_shared_from_this works</h2><p>回顾一下我们知道，使用 <code>enable_shared_from_this</code> 需要满足两个条件：</p>
<ol>
<li>某个类从 <code>enable_shared_from_this</code> 继承</li>
<li>这个类的实例必须要通过 <code>shared_ptr</code> 托管。</li>
</ol>
<p>对于第一点，我们看一下这个类的成员结构（其他的部分对继承几乎没什么影响）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief Base class allowing use of member function shared_from_this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">enable_shared_from_this</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some omitted</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Tp2&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> __enable_shared_from_this_helper(<span class="keyword">const</span> __shared_count&lt;&gt;&amp;,</span><br><span class="line">                                                 <span class="keyword">const</span> enable_shared_from_this&lt;_Tp1&gt;*,</span><br><span class="line">                                                 <span class="keyword">const</span> _Tp2*) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt;  _M_weak_this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有一个 <code>weak_ptr</code> 成员，类型是需要继承的子类，CRTP 的典型用法咯。</p>
<p>还有一个 friend function 后面会提到。</p>
<p>接着看第二点，这里拿 <code>make_shared()</code> 的 case 做例子，看一段前面看过的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">__shared_ptr(_Sp_make_shared_tag __tag, <span class="keyword">const</span> _Alloc&amp; __a, _Args&amp;&amp;... __args)</span><br><span class="line">    : _M_ptr(),</span><br><span class="line">      _M_refcount(__tag, (_Tp*)<span class="number">0</span>, __a, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _M_ptr needs to point to the newly constructed object.</span></span><br><span class="line">    <span class="comment">// This relies on _Sp_counted_ptr_inplace::_M_get_deleter.</span></span><br><span class="line">    <span class="keyword">void</span>* __p = _M_refcount._M_get_deleter(<span class="keyword">typeid</span>(__tag));</span><br><span class="line">    _M_ptr = <span class="keyword">static_cast</span>&lt;_Tp*&gt;(__p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;- attention  here</span></span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出核心是 <code>__enable_shared_from_this_helper()</code> 这个函数，并且：</p>
<ul>
<li>调用这个函数的之前，对象实例和 ref-count 块都已经创建完毕了</li>
<li>这个函数就是前面说的那个 friend function，所以这个而函数可以直接修改 <code>enable_shared_from_this</code> 里的 <code>_M_weak_this</code>。</li>
</ul>
<p>另外，如果托管对象并不需要这个特性，则函数重载会匹配到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __enable_shared_from_this_helper(<span class="keyword">const</span> __shared_count&lt;_Lp&gt;&amp;, ...) <span class="keyword">noexcept</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>看一下函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1, <span class="keyword">typename</span> _Tp2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __enable_shared_from_this_helper(<span class="keyword">const</span> __shared_count&lt;&gt;&amp; __pn,</span><br><span class="line">                                             <span class="keyword">const</span> enable_shared_from_this&lt;_Tp1&gt;* __pe,</span><br><span class="line">                                             <span class="keyword">const</span> _Tp2* __px) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__pe != <span class="literal">nullptr</span>)</span><br><span class="line">        __pe-&gt;_M_weak_assign(<span class="keyword">const_cast</span>&lt;_Tp2*&gt;(__px), __pn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from class enable_shared_from_this</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="keyword">void</span> _M_weak_assign(_Tp1* __p, <span class="keyword">const</span> __shared_count&lt;&gt;&amp; __n) <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _M_weak_this._M_assign(__p, __n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">weak_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Used by __enable_shared_from_this.</span></span><br><span class="line">    <span class="keyword">void</span> _M_assign(_Tp* __ptr, <span class="keyword">const</span> __shared_count&lt;_Lp&gt;&amp; __refcount) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        _M_ptr = __ptr;</span><br><span class="line">        _M_refcount = __refcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Tp*	 	 _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __weak_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__weak_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_count&lt;_Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">        __tmp-&gt;_M_weak_add_ref();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        _M_pi-&gt;_M_weak_release();</span><br><span class="line"></span><br><span class="line">    _M_pi = __tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面完成了托管对象的父类 <code>enable_shared_from_this</code> 中的 <code>weak_ptr</code> 和前面通过创建 <code>shared_ptr</code> 对象时创建的 ref-count 结构关联。</p>
<p>并且可以看出，完成关联后，weak-count 的计数是2：</p>
<ol>
<li>父类 enable_shared_from_this 的构造不作任何处理</li>
<li><code>shared_ptr</code> 闯将完毕后 usage-count 和 weak-count 都是 1，然后关联的时候通过 <code>_M_wak_add_ref()</code> 增加了 weak-count</li>
</ol>
<p>另外，虽然 <code>weak_ptr</code> 的父类是 <code>__weak_ptr</code>，但是这个类和 <code>__shared_ptr</code> 一样有两个成员，并且 <code>__weak_count</code> 的成员也是 <code>_Sp_counted_base</code>，和 <code>__shared_count</code> 一样。</p>
<p>这里和 MSVC STL 稍有不同，猜测可能是 libstdc++ 为了获取 <code>shared_ptr</code> 和 <code>weak_ptr</code> 之间更大的独立性？</p>
<p>接下来看一下函数 <code>shared_from_this()</code> 的工作原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from class enable_shared_from_this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;_Tp&gt; shared_from_this()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接利用了从 <code>weak-ptr</code> 构造 <code>shared_ptr</code> 的技法。</p>
<p><strong>Conclusion</strong></p>
<p>这部分的思路和 MSVC STL 一致，<code>enable_shared_from_this</code> 中保存一个 <code>weak_ptr</code> 成员，并且在构造 <code>shared_ptr</code> 对象时和 ref-count 关联。</p>
<p><code>shared_from_this()</code> 直接复用从 <code>weak-ptr</code> 构造 <code>shared_ptr</code> 的逻辑，只不过这个时候基本不存在 usage count 为 0 的情况。</p>
<p>注：libstdc++ 里有一个类似的类叫 <code>__enable_shared_from_this</code>，形式上和 <code>enable_shared_from_this</code> 很相似，只不过成员已经直接是 <code>__weak_ptr</code>。</p>
<p>至于为什么会有这个 duplication，表示不是很懂。</p>
<h2 id="How-Reference-Counting-Works"><a href="#How-Reference-Counting-Works" class="headerlink" title="How Reference Counting Works"></a>How Reference Counting Works</h2><p>通过前面的分析可以知道，引用计数是由 <code>__shared_count</code> 保存的成员指针 <code>_Sp_counted_base</code> 管理。</p>
<p>计数 usage-count 和 weak-count 的类型都是 <code>_Atomic_word</code>，这个类型定义在 <code>atomic_word.h</code> 中，实际上是 <code>int</code>。</p>
<p><code>_Sp_counted_base</code> 在构造时将两个计数都设置为 1。</p>
<p>同时提供</p>
<ul>
<li><code>_M_add_ref_copy()</code>，<code>_M_add_ref_lock()</code> 和 <code>_M_release()</code> 由上层根据上下文对 usage-count 进行增减</li>
<li><code>_M_weak_add_ref()</code> 和 <code>_M_weak_release()</code> 由上层根据上下文对 weak-count 进行增减</li>
</ul>
<p>NOTE：因为 libstdc++ 使用范围更广，所以提供了单线程版本、用锁的版本和使用原子操作的版本。同时因为具体的 atomic 实现在 libstdc++ 里有点乱，这里不研究 atomic operations 的细节，仅假设其能工作正常（废话），并站在高层抽象语义角度去分析对应的原子操作。</p>
<p>先看一下 usage-count 的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_add_ref_copy()</span><br><span class="line">&#123;</span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_Sp_counted_base&lt;_S_atomic&gt;::</span><br><span class="line">_M_add_ref_lock()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Perform lock-free add-if-not-zero operation.</span></span><br><span class="line">    _Atomic_word __count = _M_get_use_count();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__count == <span class="number">0</span>)</span><br><span class="line">            __throw_bad_weak_ptr();</span><br><span class="line">        <span class="comment">// Replace the current counter value with the old value + 1, as</span></span><br><span class="line">        <span class="comment">// long as it's not changed meanwhile.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + <span class="number">1</span>,</span><br><span class="line">                                        <span class="literal">true</span>, __ATOMIC_ACQ_REL,</span><br><span class="line">                                        __ATOMIC_RELAXED));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_Sp_counted_base&lt;_S_atomic&gt;::</span><br><span class="line">_M_add_ref_lock_nothrow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Perform lock-free add-if-not-zero operation.</span></span><br><span class="line">    _Atomic_word __count = _M_get_use_count();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Replace the current counter value with the old value + 1, as</span></span><br><span class="line">        <span class="comment">// long as it's not changed meanwhile.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + <span class="number">1</span>,</span><br><span class="line">                                        <span class="literal">true</span>, __ATOMIC_ACQ_REL,</span><br><span class="line">                                        __ATOMIC_RELAXED));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">        _M_dispose();</span><br><span class="line">        <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">        <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">        <span class="comment">// thread that runs destroy().</span></span><br><span class="line">        <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            _GLIBCXX_READ_MEM_BARRIER;</span><br><span class="line">            _GLIBCXX_WRITE_MEM_BARRIER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">        <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,</span><br><span class="line">                <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">            _M_destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_M_add_ref_copy()</code> 就是单纯的自增 usage-count，发生在 <code>__shared_count</code> 的拷贝创建或者赋值时；而 <code>_M_add_ref_lock()</code> 以来一个完整的 CAS，根据之前对 MSVC STL 的分析，我们这里可以猜测这个函数是用来 promote 一个 <code>weak_ptr</code> 到 <code>shared_ptr</code> 的，后面可以验证一下这个猜想。</p>
<p><code>_M_release()</code> 会首先自减 usage-count，如果减到0了，就释放托管的对象实例；同时再自减 weak-count，如果此时也为 0，那么说明这个 ref-count 已经凉了，就可以整个销毁了。</p>
<p>然后是 weak-count 的计数操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_weak_add_ref() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_M_weak_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Be race-detector-friendly. For more info see bits/c++config.</span></span><br><span class="line">    _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">        <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// See _M_release(),</span></span><br><span class="line">            <span class="comment">// destroy() must observe results of dispose()</span></span><br><span class="line">            _GLIBCXX_READ_MEM_BARRIER;</span><br><span class="line">            _GLIBCXX_WRITE_MEM_BARRIER;</span><br><span class="line">        &#125;</span><br><span class="line">        _M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本和上面一致。</p>
<p><code>_M_weak_add_ref()</code> 的调用时机基本是：</p>
<ul>
<li>从 <code>__weak_count</code> 或 <code>__shared_count</code> 拷贝构造得到一个 <code>__weak_count</code></li>
<li>将一个 <code>__weak_count</code> 或 <code>__shared_count</code> 赋值给另外一个 <code>__weak_count</code> （这种情况伴随着 <code>_M_weak_release()</code> 调用）</li>
</ul>
<p><code>_M_weak_release()</code> 除了赋值时会调用外，剩下的就是析构时。</p>
<p><strong>Conclusion</strong></p>
<p>两个引用计数的操作基本转换成了 <code>__shared_count</code> 对象和 <code>__weak_count</code> 对象之间的交互。</p>
<p>一般情况下，实现采用的方案都是通过 atomic operations 实现计数，但是根据源码我们也发现了专门针对单线程版本和不支持 atomic 的有锁版本。</p>
<h2 id="How-weak-ptr-relates-with-shared-ptr"><a href="#How-weak-ptr-relates-with-shared-ptr" class="headerlink" title="How weak_ptr relates with shared_ptr"></a>How weak_ptr relates with shared_ptr</h2><p>这部分和上一个 ref-count 的分析部分其实关系非常紧密。</p>
<p>promotion 在外部的表象就是通过 <code>weak_ptr::lock()</code> 完成。虽然通过 <code>shared_ptr</code> 的构造函数也可以，但是如果对象已经死了，构造函数会抛异常，徒增复杂度，我想应该没谁会这么折腾吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from weak_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;_Tp&gt;</span><br><span class="line">lock() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(*<span class="keyword">this</span>, <span class="built_in">std</span>::nothrow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from shared_ptr</span></span><br><span class="line"><span class="comment">// This constructor is non-standard, it is used by weak_ptr::lock().</span></span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="keyword">const</span> weak_ptr&lt;_Tp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : __shared_ptr&lt;_Tp&gt;(__r, <span class="built_in">std</span>::nothrow) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from __shared_ptr</span></span><br><span class="line"><span class="comment">// This constructor is used by __weak_ptr::lock() and</span></span><br><span class="line"><span class="comment">// shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).</span></span><br><span class="line">__shared_ptr(<span class="keyword">const</span> __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : _M_refcount(__r._M_refcount, <span class="built_in">std</span>::nothrow)</span><br><span class="line">&#123;</span><br><span class="line">    _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that __weak_count is defined we can define this constructor:</span></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">__shared_count&lt;_Lp&gt;::</span><br><span class="line">__shared_count(<span class="keyword">const</span> __weak_count&lt;_Lp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : _M_pi(__r._M_pi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">if</span> (!_M_pi-&gt;_M_add_ref_lock_nothrow())</span><br><span class="line">            _M_pi = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这里和 MSVC STL 大致上还是类似的。</p>
<p>利用 CAS 去加 usage-count，如果成功了，说明对象还活着，成功 promotion；反之，计数为0，自增函数返回 false，构造一个空对象。</p>
<h2 id="Thread-safety-of-shared-ptr-Instances"><a href="#Thread-safety-of-shared-ptr-Instances" class="headerlink" title="Thread-safety of shared_ptr Instances"></a>Thread-safety of shared_ptr Instances</h2><p>假设对一个 <code>shared_ptr</code> 对象 sp 又读又写：</p>
<ol>
<li>从 sp 创建一个拷贝</li>
<li>将 sp 设置为另一个 <code>shared_ptr</code> 实例</li>
</ol>
<p>这两点涉及 <code>shared_ptr</code> 的拷贝构造或拷贝赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__shared_ptr(<span class="keyword">const</span> __shared_ptr&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">__shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_ptr&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>直接采用编译器提供的实现。</p>
<p>因为 <code>__shared_ptr</code> 存有实例对象指针和计数控制块指针，复制操作做不到原子的改变两个值。</p>
<p>至于多个对象独立的析构，前面我们可以看到，这个是通过原子的改变引用计数完成，可以保证线程安全性。</p>
<p>同时，通过上一节可以看出 <code>weak_ptr</code> 到 <code>shared_ptr</code> 的 promotion 也是通过 CAS 操作保证了安全性。</p>
<h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>Libstdc++ 的分析版本到这里也结束了。</p>
<p>相比 MSVC STL，我觉得 libstdc++ 版本分析起来更困难，原因总结有三：</p>
<ol>
<li>源码分析环境不如直接在 Windows 那么友好，一些 gnu-extension 啥的文件需要翻来覆去的找</li>
<li>部分内存分配采用 allocator，我对 allocator 真心不熟悉<br>举例：有多少人知道 allocator 一开始不是为了 a mean of allocation 出现，而是为了屏蔽 near/far 地址</li>
<li>因为 libstdc++ 涉及更多的平台，并且有一些扩展实现，增加了代码分析的量</li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">浅析 shared_ptr：MSVC STL 篇</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>序言请移步<a href="https://kingsamchen.github.io/2018/03/13/shared-ptr-internals-introduction/">此处</a></p>
<p>因为这是系列第一篇，所以会带一些功能的 demo，以方便叙述。</p>
<h2 id="How-shared-ptr-new-T-differs-from-make-shared"><a href="#How-shared-ptr-new-T-differs-from-make-shared" class="headerlink" title="How shared_ptr(new T()) differs from make_shared()"></a>How shared_ptr<t>(new T()) differs from make_shared<t>()</t></t></h2><p>首先考虑 <code>shared_ptr</code> 对象的创建，对于给定类型 <code>T</code>，假设通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_shared&lt;T&gt;(...);</span><br></pre></td></tr></table></figure>
<p>创建一个实例。</p>
<p>看一下函数代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class">         <span class="title">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> <span class="title">shared_ptr</span>&lt;_Ty&gt; <span class="title">make_shared</span>(_<span class="title">Types</span>&amp;&amp;... _<span class="title">Args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// make a shared_ptr</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> _Rx = <span class="keyword">new</span> _Ref_count_obj&lt;_Ty&gt;(_STD forward&lt;_Types&gt;(_Args)...);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;_Ty&gt; _Ret;</span><br><span class="line">    _Ret._Set_ptr_rep_and_enable_shared(_Rx-&gt;_Getptr(), _Rx);</span><br><span class="line">    <span class="keyword">return</span> (_Ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先在 heap 上创建了一个 <code>_Ref_count_obj&lt;_Ty&gt;</code> 对象，通过 <code>std::forward()</code> 将 <code>make_shared()</code> 的参数转发作为构造函数；接着通过 default contructor 创建了一个 <code>shared_ptr&lt;_Ty&gt;</code>，并调用 <code>_Set_ptr_rep_and_enable_shared()</code> 设置相关数据。</p>
<p>因为创建 <code>_Ty</code> 实例需要的参数 <code>_Args</code> 被转发到了 <code>_Ref_count_obj</code> 的构造函数中，且 <code>shared_ptr</code> 的 default constructor 实质上是一个 <em>constexpr function</em>，因此猜测 <code>shared_ptr</code> 自身并不负责创建其管理的 object instance，而是将这部分操作“委托”给 <code>_Ref_count_obj</code>。</p>
<p>下面看一下 <code>_Ref_count_obj</code> 的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Ref_count_base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> _Destroy() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> _Delete_this() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Atomic_counter_t is actually unsigned long</span></span><br><span class="line">	_Atomic_counter_t _Uses;</span><br><span class="line">	_Atomic_counter_t _Weaks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Ref_count_obj</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> _Ref_count_base &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">aligned_union_t</span>&lt;<span class="number">1</span>, _Ty&gt; _Storage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用计数的信息保存在了基类 <code>_Ref_count_base</code> 中，并且只是一个普通的 <code>unsigned long</code>，估计加减的相关原子操作是直接利用 <code>Interlocked*</code> 系列的 API 来完成。</p>
<p>计数相关的细节后面会分析，这里先略过。</p>
<p><code>_Ref_count_obj</code> 自己只有一个成员，不过这个成员很有意思。</p>
<p><code>aligned_union_t&lt;1, _Ty&gt;</code> 会在内部提供一个</p>
<ul>
<li>地址按照 <code>_Ty</code> 要求对齐</li>
<li>大小为 <code>max(1, sizeof(_Ty))</code> 的 buffer</li>
</ul>
<p>所以 <code>_Storage</code> 其实就是一个大小可以容纳一个 <code>_Ty</code> 实例，且地址经过对齐的 buffer，并且这个 buffer 就是用来保存 <code>shared_ptr</code> 要管理的 <code>_Ty</code> 的实例。</p>
<p>这可以结合 <code>_Ref_count_obj</code> 的构造函数看出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">explicit</span> _<span class="title">Ref_count_obj</span>(_<span class="title">Types</span>&amp;&amp;... _<span class="title">Args</span>)</span></span><br><span class="line"><span class="class">    :</span> _Ref_count_base()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// construct from argument list</span></span><br><span class="line">    ::<span class="keyword">new</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(&amp;_Storage)) _Ty(_STD forward&lt;_Types&gt;(_Args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Ty * _Getptr()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get pointer</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">reinterpret_cast</span>&lt;_Ty *&gt;(&amp;_Storage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数里通过 <em>placement new</em> 在前面说的 buffer 里构造了出了目标实例。</p>
<p>并且，<strong>实例和（计数）控制块实质上是一起存放在一块“大”内存上的</strong>。</p>
<p>至此，<code>_Rx</code> 的构造就结束了。</p>
<p>接下来看一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;_Ty&gt; _Ret;</span><br><span class="line">_Ret._Set_ptr_rep_and_enable_shared(_Rx-&gt;_Getptr(), _Rx);</span><br></pre></td></tr></table></figure>
<p>是如何将 <code>_Rx</code> 和自己关联上的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From class shared_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Set_ptr_rep_and_enable_shared</span>(_<span class="title">Ux</span>* _<span class="title">Px</span>, _<span class="title">Ref_count_base</span>* _<span class="title">Rx</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// take ownership of _Px</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_Set_ptr_rep(_Px, _Rx);</span><br><span class="line">    _Enable_shared_from_this(*<span class="keyword">this</span>, _Px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Ptr_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> element_type = <span class="keyword">remove_extent_t</span>&lt;_Ty&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _Set_ptr_rep(element_type* _Other_ptr, _Ref_count_base* _Other_rep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// take new resource</span></span><br><span class="line">        _Ptr = _Other_ptr;</span><br><span class="line">        _Rep = _Other_rep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type* _Ptr &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    _Ref_count_base* _Rep &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>shared_ptr</code> 的基类 <code>_Ptr_base</code> 有且仅有两个成员，分别是 1) 指向 object instance 的指针 2) 指向 ref-counted 控制块的指针；这两个指针被分别设置为前面 <code>_Ref_count_obj</code> 有关的地址。</p>
<p>最后那个 <code>_Enable_shared_from_this()</code> 调用和 <code>std::enable_shared_from_this</code> 有关，后面会分析，这里先忽略。</p>
<p>到这里，函数 <code>std::make_shared()</code> 的整个流程我们已经清楚了，接下来就是研究并且对比一下，直接通过构造函数创建会有什么不同，亦即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; sp(<span class="keyword">new</span> T(...));</span><br></pre></td></tr></table></figure>
<p>对应调用的构造函数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>,</span></span><br><span class="line"><span class="class">    <span class="title">enable_if_t</span>&lt;conjunction_v&lt;conditional_t&lt;is_array_v&lt;_Ty&gt;, _Can_array_delete&lt;_Ux&gt;, _Can_scalar_delete&lt;_Ux&gt;&gt;,</span></span><br><span class="line"><span class="class">    _SP_convertible&lt;_Ux, _Ty&gt;&gt;, int&gt; = 0&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">shared_ptr</span>(_<span class="title">Ux</span>* _<span class="title">Px</span>)</span></span><br><span class="line"><span class="class">&#123;</span>	<span class="comment">// construct shared_ptr object that owns _Px</span></span><br><span class="line">    _Setp(_Px, is_array&lt;_Ty&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实现我们至少可以发现两点：</p>
<ol>
<li>没有专门（dedicated）的通过 <code>_Ty*</code> 创建对象的构造函数，而且凡是能够 implicit cast 到 <code>_Ty*</code> 的 <code>_Ux*</code> 都是被支持的</li>
<li>C++ 17 开始 <code>shared_ptr</code> 能够<a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr" target="_blank" rel="noopener">支持数组类型</a>了。不知道这是个好消息还是坏消息……</li>
</ol>
<p>由于 C++ 17 还没全面铺开，这里假设当作 C++ 11/14，不考虑类型是数组的 case。</p>
<p>接下来看一下 <code>_Setp()</code> 这个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Setp</span>(_<span class="title">Ux</span>* _<span class="title">Px</span>, <span class="title">false_type</span>) &#123;</span>  <span class="comment">// take ownership of _Px</span></span><br><span class="line">  _TRY_BEGIN                        <span class="comment">// allocate control block and set</span></span><br><span class="line">      _Set_ptr_rep_and_enable_shared(_Px, <span class="keyword">new</span> _Ref_count&lt;_Ux&gt;(_Px));</span><br><span class="line">  _CATCH_ALL  <span class="comment">// allocation failed, delete resource</span></span><br><span class="line">      <span class="keyword">delete</span> _Px;</span><br><span class="line">  _RERAISE;</span><br><span class="line">  _CATCH_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>_Set_ptr_rep_and_enable_shared()</code> 前面分析过，是用来关联 <code>shared_ptr</code> instance 和它的 ref-count 控制块。</p>
<p>这里做了一个异常处理，应该是考虑到 <code>new _Ref_count&lt;_Ux&gt;(_Px))</code> 可能会出现异常。</p>
<p>类型 <code>_Ref_count</code> 和前面分析过的 <code>_Ref_count_obj</code> 一样，都是 <code>_Ref_count_base</code> 的子类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLASS TEMPLATE _Ref_count</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Ref_count</span> :</span> <span class="keyword">public</span> _Ref_count_base &#123;  <span class="comment">// handle reference counting for</span></span><br><span class="line">                                             <span class="comment">// pointer without deleter</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) &#123;  <span class="comment">// construct</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> _Destroy() _NOEXCEPT override &#123;  <span class="comment">// destroy managed resource</span></span><br><span class="line">    <span class="keyword">delete</span> _Ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> _Delete_this() _NOEXCEPT override &#123;  <span class="comment">// destroy self</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Ty* _Ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个类结构比较简单，只有一个指针成员，指向一开始 heap 上分配的对象。</p>
<p>Conclusion: 通过上面的分析，我们可以看出，两种方式的影响主要在于 <code>shared_ptr</code> 内部使用的 ref-count control block。</p>
<p>通过 <code>make_shared()</code> 创建，使用的是 <code>_Ref_count_obj</code>，内部已经包含了对象实例的内存区域，整体上只有一次内存分配。</p>
<p>而通过构造函数创建，使用的是 <code>_Ref_count</code>，内部仅有一个指针引用预先创建的对象；整体上有两次内存分配。</p>
<h2 id="Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer"><a href="#Why-Virtual-Dtor-is-Not-Necessary-When-Deleting-From-a-Base-Pointer" class="headerlink" title="Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer"></a>Why Virtual Dtor is Not Necessary When Deleting From a Base Pointer</h2><p>通过构造函数创建 <code>shared_ptr</code> 对象有一个牛逼的副作用：<code>shared_ptr</code> 可以正确地通过基类指针析构整个对象，即使基类没有定义 virtual destructor。</p>
<p>换句话说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="comment">// no virtual here</span></span><br><span class="line">    ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"~Base\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    ~Derived()</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"~Derived\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Would call ~Derived() then ~Base() once sp goes out of scope.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Base&gt; sp(<span class="keyword">new</span> Derived());</span><br></pre></td></tr></table></figure>
<p>这个“特性”目前是 <code>shared_ptr</code> 独有的，我们可以通过研究代码来理解为什么可以这样做。</p>
<p>回顾前面分析<em>从构造函数创建 <code>shared_ptr</code></em> 的代码，可以发现，从一开始 <code>shared_ptr</code> 的构造函数到这里的 <code>_Ref_count</code>，所有相关函数都是 template，类型逐层传递保证 <code>_Ref_count::_Ptr</code> 是 heap 对象的<strong>实际类型</strong>，这意味着这个 <code>shared_ptr</code> 实现了在内部保存了管理对象的实际类型，并且 <code>_Ref_count::_Destroy()</code> 是直接对实际类型进行 delete expression。</p>
<p>所以，哪怕基类的析构函数不是 virtual，<code>sp</code> 一样能够正确析构。</p>
<p>Note，释放相关的细节因为和引用计数有关，留到后面说。</p>
<h2 id="How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type"><a href="#How-Custom-Deleter-Works-and-Why-It-Is-Not-Part-of-the-Type" class="headerlink" title="How Custom Deleter Works and Why It Is Not Part of the Type"></a>How Custom Deleter Works and Why It Is Not Part of the Type</h2><p>假设我们有一个 custom deleter，我们可以这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">custom_deleter</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(C* ptr)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;C&gt; sp(<span class="keyword">new</span> C(), custom_deleter());</span><br></pre></td></tr></table></figure>
<p>看一下目标构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Dx</span>,</span></span><br><span class="line"><span class="class">          <span class="title">enable_if_t</span>&lt;conjunction_v&lt;is_move_constructible&lt;_Dx&gt;,</span></span><br><span class="line"><span class="class">                                    _Can_call_function_object&lt;_Dx&amp;, _Ux*&amp;&gt;,</span></span><br><span class="line"><span class="class">                                    _SP_convertible&lt;_Ux, _Ty&gt;&gt;,</span></span><br><span class="line"><span class="class">                      int&gt; = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>(_<span class="title">Ux</span>* _<span class="title">Px</span>, _<span class="title">Dx</span> _<span class="title">Dt</span>) &#123;</span>  <span class="comment">// construct with _Px, deleter</span></span><br><span class="line">  _Setpd(_Px, _STD move(_Dt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Aside：由于 deleter 的定位一直是 function object，所以正确的实现是要支持 value semantics 并且控制拷贝的 cost，所以这里直接传值 + move。</p>
<p>这里通过函数 <code>_Setpd()</code> 设置对象指针和 deleter。</p>
<p>这个函数是不是觉得似曾相识？前面仅设置对象指针的函数叫 <code>_Setp()</code>，因此我们可以大胆猜测，相关的函数序列应该是形如 <code>_Setxyz()</code>，并且用 <code>p</code> 表示对象指针，<code>d</code> 表示 deleter；如果后面要研究 custom allocator，那么就会看到用 <code>a</code> 代替 allocator。</p>
<p>继续看一下 <code>_Setpd()</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">UxptrOrNullptr</span>, <span class="title">class</span> _<span class="title">Dx</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Setpd</span>(_<span class="title">UxptrOrNullptr</span> _<span class="title">Px</span>,</span></span><br><span class="line"><span class="class">            _<span class="title">Dx</span> _<span class="title">Dt</span>) &#123;</span>  <span class="comment">// take ownership of _Px, deleter _Dt</span></span><br><span class="line">  _TRY_BEGIN            <span class="comment">// allocate control block and set</span></span><br><span class="line">      _Set_ptr_rep_and_enable_shared(</span><br><span class="line">          _Px,</span><br><span class="line">          <span class="keyword">new</span> _Ref_count_resource&lt;_UxptrOrNullptr, _Dx&gt;(_Px, _STD move(_Dt)));</span><br><span class="line">  _CATCH_ALL  <span class="comment">// allocation failed, delete resource</span></span><br><span class="line">      _Dt(_Px);</span><br><span class="line">  _RERAISE;</span><br><span class="line">  _CATCH_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体实现和 <code>_Setp()</code> 非常像。不过 ref-count 的数据类型换成了 <code>_Ref_count_resource</code>，靠猜都知道它肯定也是 <code>_Ref_count_base</code> 的子类。</p>
<p>另外，因为要兼容对象指针为 <code>nullptr</code> 的情况，因此这里模板参数将指针类型整体保存了下来，即 <code>_UxptrOrNullptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLASS TEMPLATE _Ref_count_resource</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Resource</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> _<span class="title">Dx</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Ref_count_resource</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> _Ref_count_base &#123;  <span class="comment">// handle reference counting for object with</span></span><br><span class="line">                                <span class="comment">// deleter</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  _Ref_count_resource(_Resource _Px, _Dx _Dt)</span><br><span class="line">      : _Ref_count_base(),</span><br><span class="line">        _Mypair(_One_then_variadic_args_t(),</span><br><span class="line">                _STD move(_Dt),</span><br><span class="line">                _Px) &#123;  <span class="comment">// construct</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other irrelavent code</span></span><br><span class="line"></span><br><span class="line">  _Compressed_pair&lt;_Dx, _Resource&gt; _Mypair;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似的，这里的管理对象的类型 <code>_Dx</code> 也是对象的实际类型。</p>
<p>比较有意思的是 <code>_Compressed_pair</code>，它是 MSVC utility 内部使用而一个辅助结构，核心就是一个 pair，不过和标准的 <code>std::pair</code> 不同，<code>_Compressed_pair</code> 做了EBO，亦即：当 <code>_Dx</code> 是一个空结构的情况下，压缩成员，只保留一个对象指针。</p>
<p>到这里就可以下结论：(custom) deleter 保存在 <code>_Ref_count_resource</code> 中，通过 <code>_Ptr_base</code> 的 <code>_Ref_count_base*</code> 去引用。因为 <code>_Ptr_base</code> 这个基类的存在，使得最外层的 <code>shared_ptr</code> 无需通过自身保存 deleter 类型的方式就可以访问到 deleter。</p>
<p>这种 indirection layer 实在是太常见了。</p>
<h2 id="How-enable-shared-from-this-works"><a href="#How-enable-shared-from-this-works" class="headerlink" title="How enable_shared_from_this works"></a>How enable_shared_from_this works</h2><p>如果一个类需要在某个成员函数中返回指向自己 (this) 的 <code>shared_ptr</code>（常见于需要在成员函数中通过 <code>std::bind()</code> 创建一个 function object），那么就需要使用 <code>std::enable_shared_from_this</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SharedThisD</span> :</span> <span class="built_in">std</span>::enable_shared_from_this&lt;SharedThisD&gt; &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SharedThisD&gt; getptr() &#123;</span><br><span class="line">        <span class="keyword">return</span> shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;SharedThisD&gt;();</span><br><span class="line"><span class="keyword">auto</span> sp2 = sp.getptr();</span><br></pre></td></tr></table></figure>
<p>不过这里要注意的是，对象本身一定要首先是通过 <code>shared_ptr</code> 托管的，后面会看到为什么。</p>
<p>首先简单过一下 <code>enable_shared_from_this</code> 这个类的基本结构（略去无关代码):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLASS TEMPLATE enable_shared_from_this</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">enable_shared_from_this</span> &#123;</span>  <span class="comment">// provide member functions that create</span></span><br><span class="line">                                 <span class="comment">// shared_ptr to this</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// &lt;-- 记住这个 type alias</span></span><br><span class="line">  <span class="keyword">using</span> _Esft_type = enable_shared_from_this;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Omit irrelavent code</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  constexpr enable_shared_from_this() _NOEXCEPT : _Wptr() &#123;  // construct</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enable_shared_from_this(<span class="keyword">const</span> enable_shared_from_this&amp;) _NOEXCEPT</span><br><span class="line">      : _Wptr() &#123;  <span class="comment">// construct (must value-initialize _Wptr)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enable_shared_from_this&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> enable_shared_from_this&amp;)</span><br><span class="line">      _NOEXCEPT &#123;  <span class="comment">// assign (must not change _Wptr)</span></span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~enable_shared_from_this() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// &lt;-- 注意这个 friend</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Other</span>, <span class="title">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">friend</span> <span class="title">void</span> _<span class="title">Enable_shared_from_this1</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Other&gt;&amp; _<span class="title">This</span>,</span></span><br><span class="line"><span class="class">                                        _<span class="title">Yty</span>* _<span class="title">Ptr</span>,</span></span><br><span class="line"><span class="class">                                        <span class="title">true_type</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> weak_ptr&lt;_Ty&gt; _Wptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个类很简单，default constructor 甚至都是强安全的；但是这里存了一个 <code>weak_ptr</code>，所以我们再看一下 <code>weak_ptr</code> 的简单结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLASS TEMPLATE weak_ptr</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">weak_ptr</span> :</span> <span class="keyword">public</span> _Ptr_base&lt;</span><br><span class="line">                     _Ty&gt; &#123;  <span class="comment">// class for pointer to reference counted resource</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">weak_ptr</span><span class="params">()</span> _NOEXCEPT </span>&#123;  <span class="comment">// construct empty weak_ptr object</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Omit irrelavent code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>weak_ptr</code> 一样是 <code>_Ptr_base</code> 的子类，这点和 <code>shared_ptr</code> 同构。</p>
<p>回顾前面第一节 <em>How shared_ptr\<t>(new T()) differs from make_shared\<t>()</t></t></em> 里我们留了一个点，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From class shared_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ux</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Set_ptr_rep_and_enable_shared</span>(_<span class="title">Ux</span>* _<span class="title">Px</span>, _<span class="title">Ref_count_base</span>* _<span class="title">Rx</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// take ownership of _Px</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_Set_ptr_rep(_Px, _Rx);</span><br><span class="line">    _Enable_shared_from_this(*<span class="keyword">this</span>, _Px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Enable_shared_from_this()</code>，这个函数就是 <code>enable_shared_from_this</code> 能够正常运转的核心。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Other</span>, <span class="title">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Enable_shared_from_this</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Other&gt;&amp; _<span class="title">This</span>,</span></span><br><span class="line"><span class="class">                              _<span class="title">Yty</span>* _<span class="title">Ptr</span>) &#123;</span>  <span class="comment">// possibly enable shared_from_this</span></span><br><span class="line">  _Enable_shared_from_this1(</span><br><span class="line">      _This, _Ptr,</span><br><span class="line">      _Conjunction_t&lt;negation&lt;is_array&lt;_Other&gt;&gt;, negation&lt;is_volatile&lt;_Yty&gt;&gt;,</span><br><span class="line">                     _Can_enable_shared&lt;_Yty&gt;&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们知道无论管理的对象是否使用 <code>enable_shared_from_this</code>，都会调用这个函数，那么为了做到正确区分，这里使用了 SFINAE。</p>
<p>如果不考虑 array 和 volatile 的情况，那么判断核心就是 <code>_Can_enable_shared</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>, <span class="title">class</span> = <span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Can_enable_shared</span></span></span><br><span class="line"><span class="class">    :</span> false_type &#123;  <span class="comment">// detect unambiguous and accessible inheritance from</span></span><br><span class="line">                    <span class="comment">// enable_shared_from_this</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">Can_enable_shared</span>&lt;_Yty, void_t&lt;typename _Yty::_Esft_type&gt;&gt;</span></span><br><span class="line"><span class="class">    :</span> is_convertible&lt;<span class="keyword">remove_cv_t</span>&lt;_Yty&gt;*,</span><br><span class="line">                     <span class="keyword">typename</span> _Yty::_Esft_type*&gt;::type &#123;  <span class="comment">// is_convertible is</span></span><br><span class="line">                                                          <span class="comment">// necessary to verify</span></span><br><span class="line">                                                          <span class="comment">// unambiguous</span></span><br><span class="line">                                                          <span class="comment">// inheritance</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过这个 SFINAE 看出，匹配的原则是： <code>_Esft_type*</code> （其实就是 <code>class enable_shared_from_this</code>）能够 cast 到 <code>_Yty*</code>；这个做法其实也是自己实现 <code>is_derived</code> 常用的技法。</p>
<p>Aside：这里用了 C++ 17 引入的 <code>void_t</code>，部分程度上简化了 SFINAE 的构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Other</span>, <span class="title">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Enable_shared_from_this1</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Other&gt;&amp; _<span class="title">This</span>,</span></span><br><span class="line"><span class="class">                               _<span class="title">Yty</span>* _<span class="title">Ptr</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">true_type</span>) &#123;</span>  <span class="comment">// enable shared_from_this</span></span><br><span class="line">  <span class="keyword">if</span> (_Ptr &amp;&amp; _Ptr-&gt;_Wptr.expired()) &#123;</span><br><span class="line">    _Ptr-&gt;_Wptr = <span class="built_in">shared_ptr</span>&lt;<span class="keyword">remove_cv_t</span>&lt;_Yty&gt;&gt;(</span><br><span class="line">        _This, <span class="keyword">const_cast</span>&lt;<span class="keyword">remove_cv_t</span>&lt;_Yty&gt;*&gt;(_Ptr));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Other</span>, <span class="title">class</span> _<span class="title">Yty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Enable_shared_from_this1</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Other&gt;&amp;,</span></span><br><span class="line"><span class="class">                               _<span class="title">Yty</span>*,</span></span><br><span class="line"><span class="class">                               <span class="title">false_type</span>) &#123;</span>  <span class="comment">// don't enable shared_from_this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为管理实例对象是 <code>enable_shared_from_this</code> 的子类，而 <code>_Enable_shared_from_this1()</code> 这个函数又是一个 friend（往前翻翻），所以可以直接访问到 <code>_Wptr</code>。</p>
<p>接着是非常精彩的一幕：将 <code>eanble_shared_from_this</code> 的 <code>weak_ptr _Wptr</code> 和前面创建完的整个 <code>shared_ptr</code> 关联。</p>
<p>这个关联涉及两个点：</p>
<ol>
<li>通过 <code>_This</code> 和 <code>_Ptr</code> aliasing contruct 一个 <code>shared_ptr</code></li>
<li>将 (1) 创建的 <code>shared_ptr</code> 转存为 <code>weak_ptr</code></li>
</ol>
<p>两步的核心代码结合在一起如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Ty2&gt;&amp; _<span class="title">Right</span>, <span class="title">element_type</span>* _<span class="title">Px</span>)</span></span><br><span class="line"><span class="class">    _<span class="title">NOEXCEPT</span> &#123;</span>  <span class="comment">// construct shared_ptr object that aliases _Right</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;_Alias_construct_from(_Right, _Px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Alias_construct_from</span>(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Ty2&gt;&amp; _<span class="title">Other</span>,</span></span><br><span class="line"><span class="class">    <span class="title">element_type</span>* _<span class="title">Px</span>) &#123;</span>  <span class="comment">// implement shared_ptr's aliasing ctor</span></span><br><span class="line">  <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">    _Other._Rep-&gt;_Incref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Ptr = _Px;</span><br><span class="line">  _Rep = _Other._Rep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Weakly_construct_from</span>(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> _<span class="title">Ptr_base</span>&lt;_Ty2&gt;&amp; _<span class="title">Other</span>) &#123;</span>  <span class="comment">// implement weak_ptr's ctors</span></span><br><span class="line">  <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">    _Other._Rep-&gt;_Incwref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Ptr = _Other._Ptr;   <span class="comment">// &lt;-- 管理对象的指针</span></span><br><span class="line">  _Rep = _Other._Rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果画一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;SharedThisD&gt;();</span><br></pre></td></tr></table></figure>
<p>sp 的结构图，那么大概是这样（部分手绘，忽略渣效果）：</p>
<p><img src="/img/enable_shared_from_this_msvc.png" alt=""></p>
<p>可以看出，完成构造之后 <code>enable_shared_from_this</code> 保存了指向子类的 weak-ptr，加上用来管理的 <code>shared_ptr</code>，ref-count 控制块里：</p>
<ul>
<li>use-count 是 1</li>
<li>weak-count 是 2</li>
</ul>
<p>因为没有修改 use-count，所以不会阻碍实例的正确清理。</p>
<p>Bonus：这里可以想一下，如果 <code>enable_shared_from_this</code> 里存的是 <code>shared_ptr</code> 会怎么样。</p>
<p>同时，那个 weak-ptr 里（via <code>_Ptr_base</code>）保存了子类实例的地址。</p>
<p>在当前的例子里，如果考虑 sp 和 sp 里头存的 <code>_Ref_count_obj</code>，那么就有三分实例地址信息。</p>
<p>NOTE：上面几个信息可以很方便的在 VS 里通过调试器检查验证。</p>
<p>接着看一下 <code>shared_from_this()</code> 这个函数是怎么实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_NODISCARD <span class="built_in">shared_ptr</span>&lt;_Ty&gt; shared_from_this() &#123;  <span class="comment">// return shared_ptr</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">shared_ptr</span>&lt;_Ty&gt;(_Wptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_NODISCARD <span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> _Ty&gt; shared_from_this()</span><br><span class="line">    <span class="keyword">const</span> &#123;  <span class="comment">// return shared_ptr</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> _Ty&gt;(_Wptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个函数的核心就是直接通过 <code>weak_ptr _Wptr</code> 构造了一个 <code>shared_ptr</code> 对象。</p>
<p>Conclusion：概括一下使用 <code>enable_shared_from_this</code> 的核心是这个类作为子类之后内部的 <code>weak_ptr</code> 保存了对外部实例进行管理的 <code>shared_ptr</code> 的引用。</p>
<h2 id="How-Reference-Counting-Works"><a href="#How-Reference-Counting-Works" class="headerlink" title="How Reference Counting Works"></a>How Reference Counting Works</h2><p>终于到了大家都关心的如何实现引用计数的部份。</p>
<p>回顾前面我们知道，<code>shared_ptr</code> 内部保存了一个指向引用技术块 <code>_Ref_count_base</code> 的指针，而计数相关的实现就是由 <code>_Ref_count_base</code> 提供。</p>
<p>现在看一下这个基类的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLASS _Ref_count_base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Ref_count_base</span> &#123;</span>  <span class="comment">// common code for reference counting</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> _Destroy() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> _Delete_this() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _Atomic_counter_t _Uses;</span><br><span class="line">  _Atomic_counter_t _Weaks;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  _Ref_count_base()</span><br><span class="line">      : _Uses(<span class="number">1</span>),</span><br><span class="line">        _Weaks(<span class="number">1</span>)  <span class="comment">// non-atomic initializations construct</span></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~_Ref_count_base() _NOEXCEPT &#123;  <span class="comment">// TRANSITION, should be non-virtual</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span></span><br><span class="line">  _Incref_nz() &#123;  <span class="comment">// increment use count if not zero, return true if successful</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">// loop until state is known</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _USE_INTERLOCKED_REFCOUNTING</span></span><br><span class="line">      _Atomic_integral_t _Count =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">volatile</span> _Atomic_counter_t&amp;&gt;(_Uses);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;_Atomic_integral_t&gt;(_InterlockedCompareExchange(</span><br><span class="line">              <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">volatile</span> <span class="keyword">long</span>*&gt;(&amp;_Uses), _Count + <span class="number">1</span>, _Count)) ==</span><br><span class="line">          _Count)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* _USE_INTERLOCKED_REFCOUNTING */</span></span></span><br><span class="line">      _Atomic_integral_t _Count = _Load_atomic_counter(_Uses);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_Compare_increment_atomic_counter(_Uses, _Count))</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _USE_INTERLOCKED_REFCOUNTING */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _Incref() &#123;  <span class="comment">// increment use count</span></span><br><span class="line">    _MT_INCR(_Uses);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _Incwref() &#123;  <span class="comment">// increment weak reference count</span></span><br><span class="line">    _MT_INCR(_Weaks);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _Decref() &#123;  <span class="comment">// decrement use count</span></span><br><span class="line">    <span class="keyword">if</span> (_MT_DECR(_Uses) ==</span><br><span class="line">        <span class="number">0</span>) &#123;  <span class="comment">// destroy managed resource, decrement weak reference count</span></span><br><span class="line">      _Destroy();</span><br><span class="line">      _Decwref();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _Decwref() &#123;  <span class="comment">// decrement weak reference count</span></span><br><span class="line">    <span class="keyword">if</span> (_MT_DECR(_Weaks) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Delete_this();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Omit irrelavent code.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类初始化的时候，uses 和 weaks 都是 1；引用计数的增减操作是直接利用 <code>_InterlockedIncrement()</code> 和 <code>_InterlockedDecrement()</code> 这两个 intrinsic API。</p>
<p>减计数涉及到对象的销毁，因此逻辑会多一些。从上面可以看出，通常时候，uses 和 weaks 的增减是独立的；除了计数递减至 0 时。</p>
<p>（1） 如果 uses 计数递减归零，则会<strong>销毁</strong>管理的对象，同时减少 weaks。</p>
<p>注意，这里的销毁不一定会释放管理对象的资源，具体的操作和子类重写的函数有关。</p>
<p>比如，前面提到的 <code>_Ref_count_obj</code> 的 <code>_Destroy()</code> 仅仅调用了自己的析构函数，不释放内存，因为对象的内存和控制块在一起。</p>
<p>（2）如果 weaks 计数递减归零，那么说明整块引用计数控制块都没有存在的必要了，于是就可以“自杀”释放了内存了。</p>
<p>考虑到 uses 计数也是存放在技术控制块中，因此可以发现：<strong>当且仅当 weaks 计数归零时，才是真正意义上 <code>shared_ptr</code> 对象的释放</strong>。</p>
<p>所以这里可以看出使用 <code>make_shared()</code> 创建对象的一个缺点：只要有一个 <code>weak_ptr</code> 关联着，哪怕对象实例已经归天了，整块内存还是活得好好的。</p>
<p>接下来可以看一下这几个引用计数的增减函数在何时会被上头调用：</p>
<ul>
<li><code>_Incref()</code> 会在“从一个 <code>shared_ptr</code> 构造”时被调用，无论是 copy construction 还是 aliasing construction</li>
<li><code>_Decref()</code> 仅会在 <code>shared_ptr</code> 实例析构的时候被调用，不过这里有点意思是的是，<code>shared_ptr</code> 调用的是 <code>_Ptr_base</code> 自己定义的 <code>_Decref()</code>， which internally 调用了真正干活的 <code>_Decref()</code></li>
<li><code>_Incwref()</code> 仅会在函数 <code>_Weakly_construct_from()</code> 中被调用</li>
<li><code>_Decwref()</code> 会在一个 <code>weak_ptr</code> 析构时；或 uses 计数归零时被调用；类似的 <code>_Ptr_base</code> 自己也定义了一层 <code>_Decwref()</code></li>
</ul>
<p>还有一个 <code>_Incref_nz()</code> 和 <code>weak_ptr</code> 到 <code>shared_ptr</code> 的 promotion 有关，后面再分析。</p>
<h2 id="How-weak-ptr-relates-with-shared-ptr"><a href="#How-weak-ptr-relates-with-shared-ptr" class="headerlink" title="How weak_ptr relates with shared_ptr"></a>How weak_ptr relates with shared_ptr</h2><p>众所周知，一个 <code>weak_ptr</code> 可以从一个 <code>shared_ptr</code> 构造；同时也可以从一个 <code>weak_ptr</code> 提升得到 <code>shared_ptr</code>。</p>
<p>先看看第一点。</p>
<p>因为标准规定 <code>weak_ptr::operator=(const shared_ptr&amp; r)</code> 等价于 <code>std::weak_ptr&lt;T&gt;(r).swap(*this)</code>，所以需要分析的标准接口只有构造函数一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">enable_if_t</span>&lt;_SP_pointer_compatible&lt;_Ty2, _Ty&gt;::value, int&gt; = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">weak_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Ty2&gt;&amp; _<span class="title">Other</span>)</span></span><br><span class="line"><span class="class">    _<span class="title">NOEXCEPT</span> &#123;</span>  <span class="comment">// construct weak_ptr object for resource owned by _Other</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;_Weakly_construct_from(_Other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _Ptr_base</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Weakly_construct_from</span>(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> _<span class="title">Ptr_base</span>&lt;_Ty2&gt;&amp; _<span class="title">Other</span>) &#123;</span>  <span class="comment">// implement weak_ptr's ctors</span></span><br><span class="line">  <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">    _Other._Rep-&gt;_Incwref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Ptr = _Other._Ptr;</span><br><span class="line">  _Rep = _Other._Rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制了一下两个成员，以及底层 weaks 计数。</p>
<p>因为 <code>weak_ptr</code> 和 <code>shared_ptr</code> 同源（<code>_Ptr_base</code>），所以信息交换的时候不需要啥中间商。</p>
<p>接着看一下很重要的 promotion 过程，这部分操作由 <code>weak_ptr::lock()</code> 提供：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_NODISCARD <span class="built_in">shared_ptr</span>&lt;_Ty&gt; lock() <span class="keyword">const</span> _NOEXCEPT &#123;  <span class="comment">// convert to shared_ptr</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;_Ty&gt; _Ret;</span><br><span class="line">  (<span class="keyword">void</span>)_Ret._Construct_from_weak(*<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> (_Ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重担又还到了 <code>shared_ptr::_Construct_from_weak()</code> 身上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from _Ptr_base</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> _<span class="title">Construct_from_weak</span>(<span class="title">const</span> <span class="title">weak_ptr</span>&lt;_Ty2&gt;&amp; _<span class="title">Other</span>) &#123;</span></span><br><span class="line">  <span class="comment">// implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()</span></span><br><span class="line">  <span class="keyword">if</span> (_Other._Rep &amp;&amp; _Other._Rep-&gt;_Incref_nz()) &#123;</span><br><span class="line">    _Ptr = _Other._Ptr;</span><br><span class="line">    _Rep = _Other._Rep;</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候可以回顾一下前面分析 <code>weak_ptr</code> 提到的 <code>_Incref_nz()</code> 了。</p>
<p>函数操作很简单，如果 uses 计数为 0，说明管理的对象已经死了，那么这个时候直接返回。</p>
<p>如果对象还在，那么就通过 CAS 对计数进行自增。</p>
<p>为什么这里要用 CAS 而不是简单的 increment，留到后面分析 thread-safe 的时候再说。</p>
<p>Conclusion：说到底其实还是引用计数的事儿，不过因为牵扯到一些线程安全的问题，所以有点说不清道不明。</p>
<h2 id="Thread-safety-of-shared-ptr-Instances"><a href="#Thread-safety-of-shared-ptr-Instances" class="headerlink" title="Thread-safety of shared_ptr Instances"></a>Thread-safety of shared_ptr Instances</h2><p>先抛结论：</p>
<ol>
<li>多个线程同时读写多个（引用同一个管理对象）<code>shared_ptr</code> 实例是线程安全的</li>
<li>多个线程同时读写一个 <code>shared_ptr</code> 实例是非线程安全的</li>
</ol>
<p>且以上仅针对 <code>shared_ptr</code> 自身而言，非期管理的对象。</p>
<p>先看 case 2，假设有代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Foo&gt; g_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// locals</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Foo&gt; x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Foo&gt; y;</span><br><span class="line"></span><br><span class="line">x = g_ptr;</span><br><span class="line">g_ptr = y</span><br></pre></td></tr></table></figure>
<p><code>shared_ptr::operator=</code> 内部会创建临时对象，内部通过 <code>_Copy_construct_from()</code> 完成复制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> _<span class="title">Copy_construct_from</span>(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">shared_ptr</span>&lt;_Ty2&gt;&amp;</span></span><br><span class="line"><span class="class">        _<span class="title">Other</span>) &#123;</span>  <span class="comment">// implement shared_ptr's (converting) copy ctor</span></span><br><span class="line">  <span class="keyword">if</span> (_Other._Rep) &#123;</span><br><span class="line">    _Other._Rep-&gt;_Incref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _Ptr = _Other._Ptr;</span><br><span class="line">  _Rep = _Other._Rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，<code>_Ptr</code> 和 <code>_Rep</code> 的更新期间， <code>_Other</code> 完全可以发生改变，引用计数的增减原子性在这里没有什么卵用。</p>
<p>再考虑 case 1，假设我们有一个 sp 管理一个对象实例，那么符合的情况大抵只有：</p>
<ol>
<li>sp 的某个 <code>shared_ptr</code> 的拷贝对象析构了</li>
<li>某个引用 sp 的 <code>weak_ptr</code> 通过 <code>lock()</code> 获得了一个 <code>shared_ptr</code></li>
</ol>
<p>对于第一点，析构会调用前面说的 <code>_Decref()</code>，对 uses 计数做原子减操作，这一步是安全的。</p>
<p>那么有没有可能存在递减为0之后要执行 <code>_Destroy()</code> 的时候和其他打算做递增的操作冲突呢？</p>
<p>答案是不存在。</p>
<p>原因如下：我们已经排除了多个线程对同一个 sp 读写的可能（因为已经论证了这个是非线程安全），那么说明至少存在一个 sp 的拷贝，因此 uses 的计数恒大于等于 2。</p>
<p>第二点也是类似的情况，除了 —— 要考虑 promotion 的时候对象已经消亡了。</p>
<p>因为，<code>lock()</code> 当且仅当在 uses 还有效时才会做一次递增，而这种“判断-递增”操作是需要 CAS 才能保证原子性的。</p>
<h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>至此，MSVC STL 版本的 <code>shared_ptr</code> 和 <code>weak_ptr</code> 几处核心代码就分析完了。</p>
<p>To be continued…</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/13/shared-ptr-internals-introduction/">浅析 shared_ptr：序论</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>单看标准库而言，<code>shared_ptr</code>/<code>weak_ptr</code>（后文除特指外，不再同时带上 <code>weak_ptr</code>） 一开始作为 TR1 的一员引入，低调行事多年后自 C++ 11 开始成为标准库正式成员。</p>
<p>在历史意义上，引入 <code>shared_ptr</code> 不光规范化了 resource ownership 作为 abstraction conception，同时解决了困扰广大 C++ programmers 多年的难题：<em>如何知道一个对象已经被析构了</em>。</p>
<p>此外，<code>shared_ptr</code> 的某些独特实现技巧，也提供了一些神奇的 idioms，例如</p>
<ul>
<li>deleter 不作为自身类型的一部分</li>
<li>可以正确的析构 cast 到基类的子类对象，即使基类没有提供 virtual destructor</li>
<li>.etc</li>
</ul>
<p>前几天偶然有个想法，既然自己用了这么久的 <code>shared_ptr</code>，那为什么不去看看它内部是如何实现的呢？能涨涨姿势也是好的嘛。</p>
<p>为了让目标更明确，不至于迷失在浩瀚细节中，我整理了一下当前几个比较重要且有意思的点，作为代码阅读的 targets：</p>
<ol>
<li>How <code>shared_ptr&lt;T&gt;(new T())</code> differs from <code>make_shared&lt;T&gt;()</code></li>
<li>Why virtual dtor is not necessary to correctly destruct a casted derived object instance</li>
<li>How custom deleter works and why it is not part of the pointer type</li>
<li>How <code>enable_shared_from_this</code> works</li>
<li>How reference counting works</li>
<li>How <code>weak_ptr</code> relates with <code>shared_ptr</code> (promotes <code>weak_ptr</code> to <code>shared_ptr</code>)</li>
<li>Thread-safety of <code>shared_ptr</code> instances</li>
</ol>
<p>考虑到存在多方的实现和平台的常见程度，目前选择了 4 个实现版本：</p>
<ul>
<li>MSVC STL：Windows 上使用 Visual Studio 的版本</li>
<li>Libstdc++：Linux 上的标配</li>
<li>Boost：先驱者</li>
<li>Chromium Base：严格来说 Chromium Base 的实现和标准库的完全不同，放在这里只是因为我对 chromium 这个项目有一种特殊的情感/好感。这个团队是真的知道工程化团队的重要性以及能够推进团队工程化，代码一致性极高，很少出现炫技的情况（望向 Facebook 和 Microsoft）。即使部分代码的架构和实现不能算是 C++ Best Practices，也不能掩盖他们整体的工程能力。</li>
</ul>
<p>后面会为每个实现版本写一篇单独的 post，至于最后有没有一篇 summing up，就看后面有没有时间，或者这个必要了 :-)</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/08/tiny-concurrent-http-server-on-windows-and-linux/">Tiny Concurrent Http Server on Windows and Linux</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-08
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>前段时间趁着春节，分别基于 IOCP 和 epoll 实现了 demo 级别的 http server（在遵守 http 1.1 socket 复用基础上只提供了某个指定目录下文件的 GET），算是简单的过了一下 proactor 和 reactor 模型下的 TCP 并发服务。</p>
<p>功能做的很粗糙，并且没有封装类似 event-loop 的东西，连接管理也基本算是纸糊的，原因还是前面说过的，只是想过一下两种模型，并且，在不研究当前流行的 paradigm 的前提下，凭借自己的 first understanding / hunch 去实现；等对这块有一段时间的研究后，作为参照，来回对比以加深理解。</p>
<p>我觉得这是一种不错的学习方式。</p>
<p>代码可以看 <a href="https://github.com/kingsamchen/Eureka/tree/master/ConcurrentHttpServer" target="_blank" rel="noopener">这里</a></p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
