<!DOCTYPE html>
<html lang="default">
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gone with the ruins">













  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0">



<link rel="canonical" href="http://kingsamchen.github.io/">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0">






  



  









    <title> KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/08/16/passkey-idiom-part-2/">再谈 passkey idiom</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-08-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>我在 <a href="/2020/07/02/passkey-idiom-for-make-functions/" title="Passkey Idiom">Passkey Idiom</a> 这篇文章中介绍了如何使用 passkey idiom 以及使用需要的注意项。</p>
<p>其中最强调的就是 <code>Token</code> 类的 ctor 必须<strong>同时满足</strong> 1) <code>private access level</code> 2) 存在显式定义；否则用户可以使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(&#123;&#125;, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>绕过。</p>
<p>其实这里我们还可以将 <code>Token</code> 的默认构造函数标记为 <code>explicit</code> 来解决；即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Token</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">        <span class="keyword">friend</span> Widget;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(&#123;&#125;, <span class="number">0</span>)</span></span>;    <span class="comment">// error: cannot convert argument 1 from 'initializer list' to 'Token'</span></span><br></pre></td></tr></table></figure>
<p>因为前面通过 <code>{}</code> 构造一个 <code>Token</code> 对象实际上使用了 <a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener"><em>copy-list-initialization</em></a></p>
<p>注：根据 reference 文档，如果 <code>class T</code> 是一个 aggregate，那么 list initilization 的 effect 就是 perform aggregate initialization；所以这里和前面说的 aggregation initialization 并不矛盾。</p>
<p>将构造函数标记为 <code>explicit</code> 可以屏蔽/阻止使用 copy-list-initialization，即这里的使用场景。</p>
<p>为了便于记忆可以认为 <code>explicit default constructor</code> 会阻止 <code>{} -&gt; class T</code> 的创建。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/07/14/the-std-byte/">The std::byte For Byte Addressing</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-07-14
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>时隔多年，C++ 17 终于迎来了专门用于 byte-oriented access 的数据类型 <code>std::byte</code>。</p>
<p>之所以引入一个新的类型是因为之前不管是 <code>char</code> 还是 <code>unsigned char</code>，都承载了三种角色</p>
<ol>
<li>字节寻址 byte addressing</li>
<li>算术操作类型</li>
<li>展示字符类型</li>
</ol>
<p>这样很容易引发混乱和错误。</p>
<p>另外即使是 <code>uint8_t</code>，也至少承担了算术操作类型；因此标准委员会觉得需要一个<strong>仅用于字节寻址</strong>的 byte 类型。</p>
<p>官方口径叫：<em>to distinguish byte-oriented access to memory from accessing memory as a character or integral value</em>.</p>
<p>实现上你会发现 <code>std::byte</code> 其实是基于底层类型为 <code>unsigned char</code> 的 enum class：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">byte</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;&#125; ;</span><br></pre></td></tr></table></figure>
<p>这似乎有意而为之。</p>
<p>第一是限制 <code>std::byte</code> 的算数操作能力；同时因为字节通常会涉及到位运算，因此额外提供了位运算的操作符重载。</p>
<p>这避免意外运算导致的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">byte <span class="title">read_mistake</span><span class="params">(<span class="built_in">std</span>::byte* b, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// should be *(b + offset)</span></span><br><span class="line">    <span class="keyword">return</span> *b + offset;     <span class="comment">// &lt;- compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外 enum class 的出身导致了 implicit conversion 都不被允许，到 integer 的转换必须使用 <code>to_integer()</code> 以及强制类型转换。</p>
<p>同时初始化如果不借助强制类型转换就必须使用 braced-initialization，即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::byte b &#123;<span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个原因是采用 enum class 可以保证外部类型和底层类型的大小和内存对齐一致。</p>
<p>细节见: <a href="https://stackoverflow.com/questions/44508172/why-is-stdbyte-an-enum-class-instead-of-a-class" target="_blank" rel="noopener">https://stackoverflow.com/questions/44508172/why-is-stdbyte-an-enum-class-instead-of-a-class</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/07/02/passkey-idiom-for-make-functions/">Passkey Idiom</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-07-02
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>如果出于某些目的希望将某个类的构造函数设置为 private，并提供工厂函数 <code>Make()</code> 创建最终对象；工厂函数中通常会使用 <code>std::make_unique()</code> 或者 <code>std::make_shared()</code> 来创建由对应智能指针托管的对象。</p>
<p>但是因为构造函数被设置成了 private，因此这两个 make 函数<strong>内部</strong>创建对象会编译失败。</p>
<p>如果我们实在不希望使用 <code>new</code> 去构造对象，可以使用 passkey 手法规避无法编译的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    Token() &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Widget;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; Make() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;Widget&gt;(Token&#123;&#125;, GenerateId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget(Token, <span class="keyword">int</span> id) : id_(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GenerateId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面例子使用的是 <code>make_shared()</code>，<code>make_unique()</code> 也是类似。</p>
<p>需要注意，不管 <code>Token</code> 类是否是 <code>Widget</code> 的 private 成员，<code>Token</code> 自身的构造函数必须满足</p>
<ul>
<li>private access level</li>
<li>显式定义（即不能使用 <code>= default</code>）</li>
</ul>
<p>否则会存在一个漏洞，即下面的代码能够编译通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Token() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="keyword">friend</span> Widget;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(&#123;&#125;, <span class="number">0</span>)</span></span>;    <span class="comment">// Compiled.</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>{}</code> 被认为是 aggregate initialization，进而无视 default constructor 的访问级别。</p>
<p>显式定义构造函数可以避免 <code>{}</code> 被“理解”为 aggregate initialization。</p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><p>使用 <code>make_unique</code> 的最大优点是可以做到异常安全；对于这样的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeavyRender</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; w, Foobar&amp;&amp; fb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If an exception is thrown from `AcquireFoobar()`, the newed memory would leak</span></span><br><span class="line">HeavyRender(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget()), AcquireFoobar());</span><br></pre></td></tr></table></figure>
<p>编译器无法保证函数 <code>AcquireFoobar()</code> 执行的时候 <code>new</code> 返回的地址已经被用于构造 <code>unique_ptr&lt;Widget&gt;</code>；因此如果此时前者抛出了一个异常，动态分配的对象就泄露了。</p>
<p>不过通常来说，只要记住涉及 new 的语句只有一个 side-effect 就可以很大程度避免这个问题。</p>
<p>对于 <code>make_shared()</code>，除了异常安全的优势之外，内部只做一次内存分配带来的性能提升可能是大多数人使用这个函数的初衷。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/06/30/golang-options-pattern/">Golang's Options Pattern</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-06-30
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>可以将 Golang 的 <em>Options Pattern</em> 视作（有副作用）函数式版的 <em>Builder Pattern</em>，其核心是：特定的 option-function 调用会生成对应的类型为 Option 的闭包，执行闭包会修改内部的 Options 结构。</p>
<p>Golang 的函数支持同一类型的不定参数，因此上面的闭包类型一致。</p>
<p>区别传统 Builder Pattern：</p>
<ul>
<li><p>builder pattern 通过成员函数调用直接修改 builder 对象的属性成员；或者通过成员函数直接修改实例对象的成员</p>
</li>
<li><p>options pattern 是通过函数调用生成闭包，内部通过执行闭包来修改对应成员</p>
</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientOptions defines options of a client instance</span></span><br><span class="line"><span class="keyword">type</span> ClientOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    Timeout time.Duration</span><br><span class="line">    Retry   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientOption <span class="function"><span class="keyword">func</span><span class="params">(*ClientOptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(dur time.Duration)</span> <span class="title">ClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(opts *ClientOptions)</span></span> &#123;</span><br><span class="line">        opts.Timeout = dur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRetry</span><span class="params">(cnt <span class="keyword">int</span>)</span> <span class="title">ClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(opts *ClientOptions)</span></span> &#123;</span><br><span class="line">        opts.Retry = cnt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    opts *ClientOptions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(opts ...ClientOption)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">    <span class="comment">// can use some default values for options</span></span><br><span class="line">    cli := &amp;Client&#123;</span><br><span class="line">        opts: &amp;ClientOptions&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply options</span></span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        opt(cli.opts)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cli</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli := NewClient(WithTimeout(time.Second * <span class="number">3</span>))</span><br><span class="line">    fmt.Println(cli.opts.Timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于-interface-的扩展"><a href="#基于-interface-的扩展" class="headerlink" title="基于 interface 的扩展"></a>基于 interface 的扩展</h2><p>除了生成闭包，option 函数也可以生成实现了对应接口的结构：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">    apply(*Options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考 uber-golang-style 里的 <a href="https://github.com/uber-go/guide/blob/master/style.md#functional-options" target="_blank" rel="noopener">functional options</a></p>
<h2 id="Rant"><a href="#Rant" class="headerlink" title="Rant"></a>Rant</h2><p>根据 @vizze 的说法，golang 创建闭包的开销比直接函数调用高不少。默认 golang 行尾自动添加分号的策略导致多个函数调用换行写法难看。</p>
<p>另，对于 C++ 来说也可以使用 golang 这种风格。不定模板参数解决不定参数问题，同时这里需要的是一个 callable concept，lambda 或者 <code>std::function&lt;&gt;</code> 都可以做到，前者应该可以做到 zero-cost abstraction，后者会有一些额外开销。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/06/28/keep-asio-io-context-running/">保持 ASIO io_context 无任务时运行</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-06-28
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>ASIO 的 <code>io_context::run()</code> 如果发现没有 pending 的任务就会返回，对于 server 的监听线程来说这是符合常理的，因为无论如何至少有个 <code>acceptor::async_accept()</code> 在 pending。</p>
<p>但是如果想利用多核能力，那么一个常用的设计是：master 线程只负责 accept 进来的请求；将接受的 conn_sock 传递到 worker pool 里由其中一个 worker thread 处理。</p>
<p>每个 worker thread 其实也跑了一个 <code>io_context</code>，但是因为我们无法保证每个 worker 都有 pending task，所以如果不做特殊处理，<code>io_context::run()</code> 会直接返回，导致 worker thread 也退出，这和我们希望的背道而驰。</p>
<p>ASIO 中的 work guard 就是用了该解决这个问题：一个 work guard 能防止其关联的 io_context 在没有任务时退出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[maybe_unused]] <span class="keyword">auto</span> work_guard = asio::make_work_guard(io_ctx_);</span><br><span class="line">io_ctx_.run();</span><br></pre></td></tr></table></figure>
<ol>
<li><code>work_guard</code> 不影响 <code>io_context::stop()</code> 的功能和语义；如果需要结束 io_context loop，推荐的依然是使用这个方法</li>
<li>如果向去掉 <code>work_guard</code> 的影响，使用 <code>work_guard::reset()</code> 即可；调用后 <code>io_context::run()</code> 会在没有 pending task 时返回</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://dens.website/tutorials/cpp-asio/work" target="_blank" rel="noopener">Prevent io_context::run from returning</a></li>
</ol>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/05/04/atoi-with-overflow-handled/">atoi With Overflow Handled</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-04
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>leetcode 上有一题是让你实现一个 <code>atoi()</code>，但是因为函数类型是 32-bit int，所以可以直接内部转换到 64-bit int，避免需要直接处理溢出的情况。</p>
<p>如果要针对 <code>int64</code> 实现一个 <code>atoi()</code> 又该如何做？</p>
<p>我翻了一下 golang 的标准库源码，大致梳理了一下</p>
<p>(1) 如果对象是 <code>int32</code>，并且输入字符串有效数据长度小于10位，则一定不会溢出，所以可以直接处理</p>
<p>(2) 否则统一走 <code>int64</code> 处理；<code>int64</code> 内部会先处理掉符号位 <code>neg</code>，然后转成 <code>uint64</code></p>
<p>(3) 溢出处理的核心部分：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cutoff is the smallest number such that cutoff*base &gt; maxUint64.</span></span><br><span class="line"><span class="comment">// Use compile-time constants for common cases.</span></span><br><span class="line"><span class="keyword">var</span> cutoff <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">switch</span> base &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	cutoff = maxUint64/<span class="number">10</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">	cutoff = maxUint64/<span class="number">16</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	cutoff = maxUint64/<span class="keyword">uint64</span>(base) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &gt;= cutoff &#123;</span><br><span class="line">	<span class="comment">// n*base overflows</span></span><br><span class="line">	<span class="keyword">return</span> maxVal, rangeError(fnParseUint, s0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxVal := <span class="keyword">uint64</span>(<span class="number">1</span>)&lt;&lt;<span class="keyword">uint</span>(bitSize) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">n *= <span class="keyword">uint64</span>(base)</span><br><span class="line"></span><br><span class="line">n1 := n + <span class="keyword">uint64</span>(d)</span><br><span class="line"><span class="keyword">if</span> n1 &lt; n || n1 &gt; maxVal &#123;</span><br><span class="line">	<span class="comment">// n+v overflows</span></span><br><span class="line">	<span class="keyword">return</span> maxVal, rangeError(fnParseUint, s0)</span><br><span class="line">&#125;</span><br><span class="line">n = n1</span><br></pre></td></tr></table></figure>
<p>(4) <code>cutoff</code> 是防止溢出的第一重栅栏</p>
<p>对于 <code>uint64</code> 来说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cutoff     = 1844674407370955162</span><br><span class="line">UINT64_MAX = 18446744073709551615</span><br></pre></td></tr></table></figure>
<p>parse 的时候如果当前数已经 &gt;= cutoff 那么后面的数字不管是几都绝对溢出。</p>
<p>但是即使 cutoff 这里满足，加上后一位数字之后仍然可能会溢出，所以这里要做溢出处理。</p>
<p>因为类型是 uint64，所以只可能发生上溢出，数值会 wrap-around，所以用 <code>n + uint64(d) &lt; n</code> 来判断</p>
<p><code>n1 &gt; maxVal</code> 是用来处理 int32 的时候的情况（函数的输入类型已经被转成了 64-bit）</p>
<p>(5) 如果输入类型本身就是无符号，那么到这里就结束了。</p>
<p>如果是有符号，需要判断最终结果是否落在范围里，另外要注意补码体系下两端的值是不对称的。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/04/19/allow-connections-from-lan-for-trojan-qt5/">Allow Connections From LAN for Trojan-qt5</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/CODE-LIFE/">CODE-LIFE</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>因为众所周知的原因，机场的服务商把协议从 SS 切换到了 Trojan。但是之前的 SS windows 客户端只支持 SS 协议，所以切换后只能换 Trojan-qt5 作为客户端。</p>
<p>但是这个客户端做的实在不怎么样，作者似乎是在原来的 ss-qt5 的基础上做的修改，集成了 libtrojan；以至于之前 SS-Windows 用的好好的 <em>Allow Connections From LAN</em> 功能到这里没法用了。</p>
<p>更改 socks5 监听地址为 <code>INETADDR_ANY</code> 确实能让局域网内的其他主机链接 socks5 代理，但是 HTTP 代理就神奇的不能用了…</p>
<p>试验了一番结果发现要使 HTTP 代理能够正常工作，socks5 代理监听地址必须是 <code>localhost</code>… 🤪</p>
<p>因为我的 Linux 开发环境是搭建在虚拟机里并通过 X11 转发到宿主机的，所以不能使用来自 LAN 的连接会严重影响开发效率。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>自己写一个 tcp socket 运行在宿主机上，并监听 <code>INETADDR_ANY</code>，Mint 把转发器作为代理</li>
<li>用 netcat 实现</li>
<li>找其他替代品</li>
</ol>
<p>先考虑 (1)，然而发现 netcat 可以实现单次连接转发，但是后续的同一个连接的通信会直接 hang 住，可能哪里姿势不对</p>
<p>再考虑 (2)，发现可以用 socat。</p>
<p>WSL 里通过 apt 安装，然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp<span class="_">-l</span>:10086,fork,reuseaddr tcp:127.0.0.1:10081</span><br></pre></td></tr></table></figure>
<p>Mint 把宿主机的 10086 端口作为代理端口</p>
<p>嗯，发现工作非常顺畅…</p>
<p>这样就不用考虑 (3) 了，不然哪怕用 ASIO 也差不多要百来行代码。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
