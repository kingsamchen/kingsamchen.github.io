<!DOCTYPE html>
<html lang="default">
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Gone with the ruins">













  <link rel="alternate" href="/atom.xml" title="KC的废墟堆">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0">



<link rel="canonical" href="http://kingsamchen.github.io/">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0">






  



  









    <title> KC的废墟堆 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">KC的废墟堆</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/friends/">
        <li class="mobile-menu-item">
          
          
            Friends
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KC的废墟堆</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            
            
              Friends
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/08/22/src-study-redigo-wait-on-avail-conn/">Redigo 源码学习：阻塞等待连接可用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-08-22
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>通过<a href="https://www.notion.so/400e99c27cf445d0ba9388b81dc8cc76" target="_blank" rel="noopener">连接池管理</a> 了解如何回收连接到连接池以及从连接池复用连接后，可以回过头来研究一下 Redigo 支持的阻塞等待可用连接的设计与实现。</p>
<p>通过设置 <code>Pool.Wait == true</code> 之后如果当前连接池满了， <code>Pool.Get()</code> 不会返回连接池耗尽错误，而是阻塞在调用上，直到超时或者存在可用连接才会返回。</p>
<p>这个属于经典的 resource counting 问题，并且最大的 resource count 由 <code>Pool.MaxActive</code> 决定。</p>
<h2 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h2><p>现在看一下 <code>Pool.GetContext()</code> 如何处理这种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">GetContext</span><span class="params">(ctx context.Context)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Wait until there is a vacant connection in the pool.</span></span><br><span class="line">	waited, err := p.waitVacantConn(ctx)    <span class="comment">// &lt;-- wait at here</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errorConn&#123;err&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.mu.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> waited &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p.waitCount++</span><br><span class="line">		p.waitDuration += waited</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	p.active++</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次获取连接都会调用 <code>Pool.waitVacantConn()</code> 确保：</p>
<ul>
<li>如果当前获取一个连接后仍未超过配置上限则理解从函数返回，执行获取连接逻辑</li>
<li>阻塞等待直到有可用连接出现，或者等到超时</li>
</ul>
<p>即，只要 <code>waitVacantCount()</code> 函数正常返回则代表当前一定能获取一个可用连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// waitVacantConn waits for a vacant connection in pool if waiting</span></span><br><span class="line"><span class="comment">// is enabled and pool size is limited, otherwise returns instantly.</span></span><br><span class="line"><span class="comment">// If ctx expires before that, an error is returned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there were no vacant connection in the pool right away it returns the time spent waiting</span></span><br><span class="line"><span class="comment">// for that connection to appear in the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">waitVacantConn</span><span class="params">(ctx context.Context)</span> <span class="params">(waited time.Duration, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !p.Wait || p.MaxActive &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// No wait or no connection limit.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.lazyInit()</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx == <span class="literal">nil</span> &#123;</span><br><span class="line">		&lt;-p.ch</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-p.ch:</span><br><span class="line">			<span class="comment">// Additionally check that context hasn't expired while we were waiting,</span></span><br><span class="line">			<span class="comment">// because `select` picks a random `case` if several of them are "ready".</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>, ctx.Err()</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, ctx.Err()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个函数的核心就是从 <code>p.ch</code> 这个 channel 中获取一个类型为 <code>struct{}</code> 的 token 对象;</p>
<p>显然这里使用一个 <em>bounded channel</em> 作为限流器。</p>
<p>猜想基于这个 channel 的整套限流机制应该是：</p>
<ul>
<li>channel 里 token 对象的个数代表还有多少连接可以分配</li>
<li>消耗连接 quota 对应地直接从 channel 中拿出 token 对象；回收连接则往 channel 再寸一个 token 对象</li>
</ul>
<p>接下来我们考虑一下 channel 的初始化：因为 <code>p.ch</code> 只能被初始化一遍，并且要考虑到这个初始化必须满足 goroutine-safe。</p>
<p>这个 channel 的初始化流程则是在 <code>p.lazyInit()</code> 中完成的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">lazyInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast path.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;p.chInitialized) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path.</span></span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> p.chInitialized == <span class="number">0</span> &#123;</span><br><span class="line">		p.ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, p.MaxActive)</span><br><span class="line">		<span class="keyword">if</span> p.closed &#123;</span><br><span class="line">			<span class="built_in">close</span>(p.ch)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.MaxActive; i++ &#123;</span><br><span class="line">				p.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.StoreUint32(&amp;p.chInitialized, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>p.chInitialized</code> 是一个 <code>uint32</code> 类型的 flag。</p>
<p>这里很明显可以看出这是一个典型的 _double-checked locking pattern_，常用于 singleton 模式。</p>
<p>这里是因为希望这个 channel 的初始化是 lazy 的。</p>
<p>可以看到这个 channel 的 buffer-size 是 <code>p.MaxActive</code> 即配置的连接池大小；并且创建 buffer 后会直接往 channel 中塞满 <code>p.MaxActive</code> 个 token 对象。</p>
<p>前面分析 <code>Pool.GetCountext()</code> 代码时我们忽略了一种case：拿到 token 后通过 <code>dial()</code> 创建一个底层连接失败；这个时候我们需要往 channel 中补偿一个 token 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c, err := p.dial(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	c = <span class="literal">nil</span></span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	p.active--</span><br><span class="line">	<span class="keyword">if</span> p.ch != <span class="literal">nil</span> &amp;&amp; !p.closed &#123;</span><br><span class="line">		p.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;    <span class="comment">// &lt;-- 补偿</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> errorConn&#123;err&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回收连接"><a href="#回收连接" class="headerlink" title="回收连接"></a>回收连接</h2><p>回收连接部份的逻辑仍然是在 <code>Pool.put()</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">put</span><span class="params">(pc *poolConn, forceClose <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> pc != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">		pc.c.Close()</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		p.active--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p.ch != <span class="literal">nil</span> &amp;&amp; !p.closed &#123;</span><br><span class="line">		p.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回收连接中对应的逻辑比较简单：只要 <code>idleList</code> 中某个连接被清理了，就往 channel 中塞一个 token 对象进行补偿。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redigo 使用 bounded channel 实现了 resource counting 机制；并且满足</p>
<script type="math/tex; mode=display">p.active + \text{len}(p.ch)=p.MaxActive</script><p>对于其他语言来说，可以使用 condition_variable 甚至 Semaphore 来实现 resource counting。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/08/21/src-study-redigo-redis-pool/">Redigo 源码学习：连接池的设计</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-08-21
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><p>暴露给外部用户的 <code>Pool</code> 对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Maximum number of idle connections in the pool.</span></span><br><span class="line">	MaxIdle <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Maximum number of connections allocated by the pool at a given time.</span></span><br><span class="line">	<span class="comment">// When zero, there is no limit on the number of connections in the pool.</span></span><br><span class="line">	MaxActive <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close connections after remaining idle for this duration. If the value</span></span><br><span class="line">	<span class="comment">// is zero, then idle connections are not closed. Applications should set</span></span><br><span class="line">	<span class="comment">// the timeout to a value less than the server's timeout.</span></span><br><span class="line">	IdleTimeout time.Duration</span><br><span class="line"></span><br><span class="line">	mu           sync.Mutex    <span class="comment">// mu protects the following fields</span></span><br><span class="line">	active       <span class="keyword">int</span>           <span class="comment">// the number of open connections in the pool</span></span><br><span class="line">	idle         idleList      <span class="comment">// idle connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部维护空闲/待复用的列表数据结构 <code>idleList</code><br>
          <div class="read-more">
            <a href="/2020/08/21/src-study-redigo-redis-pool/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </p></div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/08/21/src-study-redigo/">Redigo 源码学习</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-08-21
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>Redigo 是目前比较流行的一个 Redis Client。</p>
<p>虽然我个人不太喜欢它的 API 设计，奈何这个库简单易用，连公司的 redis 基础库都是在 Redigo 上做的的一个魔改。</p>
<p>注：原生的 Redigo 并不支持 Redis Cluster，某B站的做法是通过 side-car 的方式启动一个 redis proxy 伴生容器，屏蔽 Redis Cluster 的通信细节。</p>
<p>既然用都用了，不如抽个时间研究一下这个库，看看其中是否有些设计值得借鉴。想想如此流行的一个基础组件库，如果代码质量过不去的话大概 issue 已经被愤怒的用户挤爆了…</p>
<p>因为我比较懒，所以只会挑一些个人感兴趣的部分研究。</p>
<p>本篇为总起大纲，具体分析学习的内容请自行跳转至指定页面。</p>
<ul>
<li><a href="/2020/08/21/src-study-redigo-redis-pool/" title="连接池的设计">连接池的设计</a>
</li>
</ul>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/08/16/passkey-idiom-part-2/">再谈 passkey idiom</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-08-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>我在 <a href="/2020/07/02/passkey-idiom-for-make-functions/" title="Passkey Idiom">Passkey Idiom</a> 这篇文章中介绍了如何使用 passkey idiom 以及使用需要的注意项。</p>
<p>其中最强调的就是 <code>Token</code> 类的 ctor 必须<strong>同时满足</strong> 1) <code>private access level</code> 2) 存在显式定义；否则用户可以使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(&#123;&#125;, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>绕过。</p>
<p>其实这里我们还可以将 <code>Token</code> 的默认构造函数标记为 <code>explicit</code> 来解决；即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Token</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">        <span class="keyword">friend</span> Widget;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(&#123;&#125;, <span class="number">0</span>)</span></span>;    <span class="comment">// error: cannot convert argument 1 from 'initializer list' to 'Token'</span></span><br></pre></td></tr></table></figure>
<p>因为前面通过 <code>{}</code> 构造一个 <code>Token</code> 对象实际上使用了 <a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener">_copy-list-initialization_</a></p>
<p>注：根据 reference 文档，如果 <code>class T</code> 是一个 aggregate，那么 list initilization 的 effect 就是 perform aggregate initialization；所以这里和前面说的 aggregation initialization 并不矛盾。</p>
<p>将构造函数标记为 <code>explicit</code> 可以屏蔽/阻止使用 copy-list-initialization，即这里的使用场景。</p>
<p>为了便于记忆可以认为 <code>explicit default constructor</code> 会阻止 <code>{} -&gt; class T</code> 的创建。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/07/14/the-std-byte/">The std::byte For Byte Addressing</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-07-14
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>时隔多年，C++ 17 终于迎来了专门用于 byte-oriented access 的数据类型 <code>std::byte</code>。</p>
<p>之所以引入一个新的类型是因为之前不管是 <code>char</code> 还是 <code>unsigned char</code>，都承载了三种角色</p>
<ol>
<li>字节寻址 byte addressing</li>
<li>算术操作类型</li>
<li>展示字符类型</li>
</ol>
<p>这样很容易引发混乱和错误。</p>
<p>另外即使是 <code>uint8_t</code>，也至少承担了算术操作类型；因此标准委员会觉得需要一个<strong>仅用于字节寻址</strong>的 byte 类型。</p>
<p>官方口径叫：_to distinguish byte-oriented access to memory from accessing memory as a character or integral value_.</p>
<p>实现上你会发现 <code>std::byte</code> 其实是基于底层类型为 <code>unsigned char</code> 的 enum class：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">byte</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;&#125; ;</span><br></pre></td></tr></table></figure>
<p>这似乎有意而为之。</p>
<p>第一是限制 <code>std::byte</code> 的算数操作能力；同时因为字节通常会涉及到位运算，因此额外提供了位运算的操作符重载。</p>
<p>这避免意外运算导致的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::byte <span class="title">read_mistake</span><span class="params">(<span class="built_in">std</span>::byte* b, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// should be *(b + offset)</span></span><br><span class="line">    <span class="keyword">return</span> *b + offset;     <span class="comment">// &lt;- compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外 enum class 的出身导致了 implicit conversion 都不被允许，到 integer 的转换必须使用 <code>to_integer()</code> 以及强制类型转换。</p>
<p>同时初始化如果不借助强制类型转换就必须使用 braced-initialization，即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::byte b &#123;<span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个原因是采用 enum class 可以保证外部类型和底层类型的大小和内存对齐一致。</p>
<p>细节见: <a href="https://stackoverflow.com/questions/44508172/why-is-stdbyte-an-enum-class-instead-of-a-class" target="_blank" rel="noopener">https://stackoverflow.com/questions/44508172/why-is-stdbyte-an-enum-class-instead-of-a-class</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/07/02/passkey-idiom-for-make-functions/">Passkey Idiom</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-07-02
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>如果出于某些目的希望将某个类的构造函数设置为 private，并提供工厂函数 <code>Make()</code> 创建最终对象；工厂函数中通常会使用 <code>std::make_unique()</code> 或者 <code>std::make_shared()</code> 来创建由对应智能指针托管的对象。</p>
<p>但是因为构造函数被设置成了 private，因此这两个 make 函数<strong>内部</strong>创建对象会编译失败。</p>
<p>如果我们实在不希望使用 <code>new</code> 去构造对象，可以使用 passkey 手法规避无法编译的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    Token() &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Widget;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">Make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;Widget&gt;(Token&#123;&#125;, GenerateId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget(Token, <span class="keyword">int</span> id) : id_(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GenerateId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面例子使用的是 <code>make_shared()</code>，<code>make_unique()</code> 也是类似。</p>
<p>需要注意，不管 <code>Token</code> 类是否是 <code>Widget</code> 的 private 成员，<code>Token</code> 自身的构造函数必须满足</p>
<ul>
<li>private access level</li>
<li>显式定义（即不能使用 <code>= default</code>）</li>
</ul>
<p>否则会存在一个漏洞，即下面的代码能够编译通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Token() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="keyword">friend</span> Widget;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(&#123;&#125;, <span class="number">0</span>)</span></span>;    <span class="comment">// Compiled.</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>{}</code> 被认为是 aggregate initialization，进而无视 default constructor 的访问级别。</p>
<p>显式定义构造函数可以避免 <code>{}</code> 被“理解”为 aggregate initialization。</p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><p>使用 <code>make_unique</code> 的最大优点是可以做到异常安全；对于这样的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeavyRender</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; w, Foobar&amp;&amp; fb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If an exception is thrown from `AcquireFoobar()`, the newed memory would leak</span></span><br><span class="line">HeavyRender(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget()), AcquireFoobar());</span><br></pre></td></tr></table></figure>
<p>编译器无法保证函数 <code>AcquireFoobar()</code> 执行的时候 <code>new</code> 返回的地址已经被用于构造 <code>unique_ptr&lt;Widget&gt;</code>；因此如果此时前者抛出了一个异常，动态分配的对象就泄露了。</p>
<p>不过通常来说，只要记住涉及 new 的语句只有一个 side-effect 就可以很大程度避免这个问题。</p>
<p>对于 <code>make_shared()</code>，除了异常安全的优势之外，内部只做一次内存分配带来的性能提升可能是大多数人使用这个函数的初衷。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2020/06/30/golang-options-pattern/">Golang's Options Pattern</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-06-30
        </span>
        
          <div class="post-category">
            
              <a href="/categories/PROGRAMMING/">PROGRAMMING</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>可以将 Golang 的 _Options Pattern_ 视作（有副作用）函数式版的 _Builder Pattern_，其核心是：特定的 option-function 调用会生成对应的类型为 Option 的闭包，执行闭包会修改内部的 Options 结构。</p>
<p>Golang 的函数支持同一类型的不定参数，因此上面的闭包类型一致。</p>
<p>区别传统 Builder Pattern：</p>
<ul>
<li><p>builder pattern 通过成员函数调用直接修改 builder 对象的属性成员；或者通过成员函数直接修改实例对象的成员</p>
</li>
<li><p>options pattern 是通过函数调用生成闭包，内部通过执行闭包来修改对应成员</p>
</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientOptions defines options of a client instance</span></span><br><span class="line"><span class="keyword">type</span> ClientOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    Timeout time.Duration</span><br><span class="line">    Retry   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientOption <span class="function"><span class="keyword">func</span><span class="params">(*ClientOptions)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(dur time.Duration)</span> <span class="title">ClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(opts *ClientOptions)</span></span> &#123;</span><br><span class="line">        opts.Timeout = dur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRetry</span><span class="params">(cnt <span class="keyword">int</span>)</span> <span class="title">ClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(opts *ClientOptions)</span></span> &#123;</span><br><span class="line">        opts.Retry = cnt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    opts *ClientOptions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(opts ...ClientOption)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">    <span class="comment">// can use some default values for options</span></span><br><span class="line">    cli := &amp;Client&#123;</span><br><span class="line">        opts: &amp;ClientOptions&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply options</span></span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        opt(cli.opts)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cli</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli := NewClient(WithTimeout(time.Second * <span class="number">3</span>))</span><br><span class="line">    fmt.Println(cli.opts.Timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于-interface-的扩展"><a href="#基于-interface-的扩展" class="headerlink" title="基于 interface 的扩展"></a>基于 interface 的扩展</h2><p>除了生成闭包，option 函数也可以生成实现了对应接口的结构：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">    apply(*Options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考 uber-golang-style 里的 <a href="https://github.com/uber-go/guide/blob/master/style.md#functional-options" target="_blank" rel="noopener">functional options</a></p>
<h2 id="Rant"><a href="#Rant" class="headerlink" title="Rant"></a>Rant</h2><p>根据 @vizze 的说法，golang 创建闭包的开销比直接函数调用高不少。默认 golang 行尾自动添加分号的策略导致多个函数调用换行写法难看。</p>
<p>另，对于 C++ 来说也可以使用 golang 这种风格。不定模板参数解决不定参数问题，同时这里需要的是一个 callable concept，lambda 或者 <code>std::function&lt;&gt;</code> 都可以做到，前者应该可以做到 zero-cost abstraction，后者会有一些额外开销。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2020

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kingsley Chen</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
