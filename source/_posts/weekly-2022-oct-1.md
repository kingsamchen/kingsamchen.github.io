---
title: 一周杂记 in Week 1 Oct 2022
categories: CODE-LIFE
date: 2022-10-02 23:49:33
tags: [杂记]
---
本周是十月第一周，因为周末两天刚好开始十一长假。

## Life

\#1

上一次回老家还是21年11月的时候回来参加媳妇儿堂哥的婚礼，因为22年春节杭州疫情考虑所以就只能选择继续呆在杭州。

因为这次提前确定要回老家，所以一早就买了高铁票，又因为买的一等座（我实在受不了大假日的高铁二等座了），所以往返都比较顺利。

两边车站的出入都算比较顺利，并且因为是省内，所以老家落地后只要核酸在48小时内就不需要单独单独做核酸。

出站后和媳妇儿找了家老家风味小吃店吃了点小吃，非常过瘾。

老家还是当初那个小县城，只是如今在时代大背景下多了几分萧条。

\#2

之前说到8月体检的时候情况非常不好，所以9月份一直在加强运动和饮食控制。

趁着10.2要去高铁站的间隙，顺道去媳妇儿医院做了个血常规。

因为有“connections”加持，所以整个流程用时不到十分钟。

下午在高铁上检查结果就出来了，媳妇儿说低密度蛋白这个关键指标有明显下降，是个很好的信号；虽然尿酸和甘油三酯依然过高。

不过这算是开了个好头吧，接下来Q4三个月会继续保持9月份的这种锻炼节奏，争取来年1月份重新检查时体检数据能有一个全面的改进；到时顺带做一个心电图，看看是否有明显改进 XD

\#3

10.1 的时候去 KT 家看望了一次“石老师”，毕竟一年一度的大事，尤其今年石老师还找到了她的专属老伴 😊

不过遗憾的是一早老婆就接到消息说她1号这天得去富阳支援一下当校医，因为原定的那个人这天生病了，无法按时报到...

无奈老婆只好收拾出发，错过了拜见石老师的机会。（不过好在第二天能赶回来一起回家，不然就真的亏大发了）

剩下的就不用言语描述，只看看石老师的美照 :P

![](/img/20221001_070550773_iOS.jpg)
![](/img/20221001_081657479_iOS.jpg)
![](/img/20221001_081907284_iOS.jpg)
![](/img/20221001_082248254_iOS.jpg)

\#4

这周周三在公司看了 Fall，算是一部很合我胃口的电影，小制作，网剧水准，但是节奏紧凑，剧本没有太大的硬伤（小BUG那自然是一堆）

我个人评分能到 7.5/10 吧。

周五的时候自己在家看完了 The Guest，一部我觉得一开始有点格局/想法但是导演编剧把控力不行的电影...

整体看下来就是 WTF ??

在我这只能 5/10

## Work

\#1

这周最大的一个事情是我们的产品终于 internal beta 了。

虽然 internal beta 目前看比较 smooth 但是我们都知道目前架构和实现上都有不少的坑。

杭州这边的同事其实都挺担心后续正式 RTM 之后凭目前的情况大概率是要出现各种奇怪的问题的；这不，9.30 最后一个工作日的时候，我们发现一个很重要的 consumer 的 segfault 会导致 email 丢失...

幸运的是目前看起来我不用趟这个浑水，但是不幸的是大家都是一条船上的....

后面正式上线后几个 cluster 之间的 replication 感觉会成为我们一段时间内的噩梦，先把 FLAG 立这里。

\#2

本周学习的进度如下：

- 继续 _趣谈网络协议_ 收获一般... 我最近有一种体会，简言之是随着极客时间用户量提高，他的课程干货和质量一定是下滑的。
  等我哪天有时间了我来讲一下我的想法。
- 看完了 _大规模分布式存储系统 | Chapter 5 分布式键值系统_
  这一章介绍了 Dynamo 和 Tair 的架构；看内容作者其实不太推荐 P2P 架构
- 看了两个 Talk _CppCon 2020 | Fuzzing Class Interfaces for Generating and Running Tests with libFuzzer - Barnabás Bágyi_ 和 _陈硕 2022 C++ 技术大会演讲：C++ 性能、工具、库【现场直播版】_
  第一个 talk 本质就是介绍了 clang 现在支持的 fuzzer 能力，不用看完整个 talk，快速过一下 slides 就行
  第二个是陈硕最近的一个分享，质量很高；感觉未来业务开发和系统开发会慢慢演化成两种完全不同的 Devs...
- 看了篇 post: [Measuring std::unordered_map Badness](https://artificial-mind.net/blog/2021/10/09/unordered-map-badness)
  这篇讲的是除了要考虑 hash 函数的均匀性之外，还要考虑 hash 函数产生的 index 在实际 bucket 中的分布。
  如果 bucket 太少，那么 64-bit 的 hash function 生成的 index 的高字节约等于完全没有用，导致低字节数据相近的会挤到一个 bucket，极大增大冲突概率。
  文章中提出一个衡量 key 在 bucket 分布均匀度的方法：
  ```c++
    template <class Map>
    double unordered_map_badness(Map const& map)
    {
        auto const lambda = map.size() / double(map.bucket_count());

        auto cost = 0.;
        for (auto const& [k, _] : map)
            cost += map.bucket_size(map.bucket(k));
        cost /= map.size();

        return std::max(0., cost / (1 + lambda) - 1);
    }
  ```

\#3

这周没有太多时间继续研究 absl/mutex，所以只能暂时等到十一放假期间在老家做这个事情了。

希望老家有足够的环境可以让我做这个...

---

本周就是这样，下周见
